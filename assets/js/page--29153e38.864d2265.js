(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{734:function(a,t,s){"use strict";s.r(t);var r=s(1),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("对象头的 Mark Work 部分是锁的实现关键。")]),a._v(" "),s("p",[a._v("32 位系统中 Mark Word：")]),a._v(" "),s("p",[a._v("![在这里插入图片描述](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\jvm\\memory\\images\\22d70c7550294a1e9e92eceb3ed044d8.png?lastModify=1649060717)")]),a._v(" "),s("h4",{attrs:{id:"偏向锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[a._v("#")]),a._v(" 偏向锁：")]),a._v(" "),s("p",[a._v("若是某一锁被线程获取后，便进入偏向模式，当此线程再次请求这个锁时候，无需再进行相关的同步操作，从而节省了时间。如果在此之间有其他线程进行了锁请求，则锁退出偏向模式。(可使用 -XX:+UseBiasedLocking 启用偏向锁)。")]),a._v(" "),s("h4",{attrs:{id:"轻量级锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[a._v("#")]),a._v(" 轻量级锁：")]),a._v(" "),s("p",[a._v("如果偏向失败，java虚拟机会让线程申请轻量级锁。轻量级锁在虚拟机内部使用 BasicObjectLock 的对象实现，这个对象内部由一个 BasicLock 对象和一个持有该锁的 Java 对象(其实就是线程需要加锁的对象)组成。BasicObjectLock 对象放置在 Java 栈的栈帧中。在 BasicLock 对象内部还维护着 displaced_header 字段，它用户备份对象头部的 Mark Word。")]),a._v(" "),s("p",[a._v("当一个线程持有一个对象的锁时，这时候 Mark Word 指向的是 BasicLock 对象的指针。由于 BasicObjectLock 对象在线程中，因此该指针必然指向持有该锁的线程栈空间。当需要判断某一线程是否持有该对象锁时，也只需简单的判断对象头的指针是否在当前线程的栈地址范围内即可。同时，BasicLock 对象的 displaced_header 字段，备份了原对象的 Mark Word 内容。BasicObjectLock 对象的 obj 字段则指向该对象。")]),a._v(" "),s("p",[a._v("轻量级锁核心代码：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("markOop mark "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" obj"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("mark")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nlock"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("set_displaced_header")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("mark"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("mark "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("markOop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Atomic")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("cmpxchg_ptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("obj")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("mark_addr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("mark"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("TEVENT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("slow_enter"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("release stackLock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("首先，通过 obj 获取锁对象的Mark Word 数据并保存到 displaced_header。这里的 lock 指的应该是 BasicLock。")]),a._v(" "),s("p",[a._v("其次，使用 CAS 操作，尝试将 BasicLock 的地址复制到对象头的 Mark Word。")]),a._v(" "),s("p",[a._v("如果复制成功，那么加锁成功，否则认为加锁失败，那么轻量级锁就有可能被膨胀为重量级锁。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/image-20220404173440792.png",alt:"image-20220404173440792"}}),a._v(" "),s("p",[a._v("这里的持有锁的对象的头部就是之前被线程更改了 Mark Word 的那个对象，也就是所有线程竞争的对象。")]),a._v(" "),s("h5",{attrs:{id:"字节码层面轻量级锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字节码层面轻量级锁"}},[a._v("#")]),a._v(" 字节码层面轻量级锁：")]),a._v(" "),s("p",[a._v("这里的 LockRecord 是 BasicObjectLock？？？")]),a._v(" "),s("p",[a._v("LockRecord 用于轻量级锁优化，当解释器执行 monitorenter 字节码轻度锁住一个对象时，就会在获取锁的"),s("a",{attrs:{href:"https://www.zhihu.com/search?q=%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1359657467%7D",target:"_blank",rel:"noopener noreferrer"}},[a._v("线程"),s("OutboundLink")],1),a._v("的栈上显式或者隐式分配一个LockRecord 。这个 LockRecord 存储锁对象 markword 的拷贝(Displaced Mark Word)，在拷贝完成后，首先会挂起持有偏向锁的线程，因为要进行尝试修改锁记录指针，MarkWord 会有变化，所有线程会利用 CAS 尝试将 MarkWord 的锁记录指针改为指向自己(线程)的锁记录，然后lockrecord 的 owner 指向对象的 markword，修改成功的线程将获得轻量级锁。失败则线程升级为重量级锁。释放时会检查 markword 中的lockrecord 指针是否指向自己(获得锁的线程 lockrecord)，使用原子的CAS将 Displaced Mark Word 替换回对象头，如果成功，则表示没有竞争发生，如果替换失败则升级为重量级锁。整个过程中，LockRecord是一个线程内独享的存储，每一个线程都有一个可用"),s("code",[a._v("Monitor Record")]),a._v("列表。")]),a._v(" "),s("h4",{attrs:{id:"重量级锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁"}},[a._v("#")]),a._v(" 重量级锁：")]),a._v(" "),s("p",[a._v("当使用重量级锁的时候，第一步是废弃前面 BasicLock 备份的对象头信息，第二步则正式启用重量级锁。启用过程分两步：首先通过 infate() 方法进行锁膨胀，目的是获得对象的 ObjectMonitor；然后使用 enter() 方法尝试进入该锁。在 enter() 方法中，线程很可能会在操作系统层面被挂起。这样线程间切换和调度成本就比较高。")]),a._v(" "),s("h4",{attrs:{id:"自旋锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[a._v("#")]),a._v(" 自旋锁")]),a._v(" "),s("p",[a._v("线程没有获得锁时，不被挂起，而去执行一个空循环（即所谓的自旋），若干个空循环后，线程如果可以获得，则继续执行。若依然不能获得锁，才会被挂起。")]),a._v(" "),s("h4",{attrs:{id:"锁消除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁消除"}},[a._v("#")]),a._v(" 锁消除")]),a._v(" "),s("p",[a._v("Java 虚拟机在 JIT 编译(某段代码即将第一次被执行时编译)时，通过对运行时上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。")]),a._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结：")]),a._v(" "),s("p",[a._v("JDK1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁。")]),a._v(" "),s("p",[a._v("JVM一般是这样使用锁和 Mark Word 的：")]),a._v(" "),s("p",[a._v("1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的 HashCode，锁标志位是01，是否偏向锁那一位是0。")]),a._v(" "),s("p",[a._v("2，当对象被当做同步锁并有一个线程 A 抢到了锁时，锁标志位还是 01，但是否偏向锁那一位改成 1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。")]),a._v(" "),s("p",[a._v("3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word 中记录的线程 id 就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。")]),a._v(" "),s("p",[a._v("4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。")]),a._v(" "),s("p",[a._v("5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。")]),a._v(" "),s("p",[a._v("6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。")]),a._v(" "),s("p",[a._v("7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。")])])}),[],!1,null,null,null);t.default=e.exports}}]);