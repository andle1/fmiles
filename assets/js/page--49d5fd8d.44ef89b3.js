(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{482:function(s,t,a){s.exports=a.p+"assets/img/1289934-20190621163930814-1395015700.5001f5e4.png"},483:function(s,t,a){s.exports=a.p+"assets/img/bbb4844d8e7c44c5ac006bf8cf70593a.194998b6.png"},484:function(s,t,a){s.exports=a.p+"assets/img/26cf03bb30fd4b91b189fb83c3d3828c.c7fab106.png"},485:function(s,t,a){s.exports=a.p+"assets/img/9177cbe9fa3a446f88fb9f130058df24.d39c0534.png"},669:function(s,t,a){"use strict";a.r(t);var v=a(1),_=Object(v.a)({},(function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("p",[s._v("单线程模型，aof，rdb，rewrite，主从，cluster，哪些类型，不要再说常规的5个了，多说几个让你区别其他小哥，包含一些缓存常见的问题击穿、穿透、雪崩、数据一致性等，你必须会，不会基本没戏，一致性hash，布隆过滤器的原理，为此我还去了解了geohash的原理以及google s2的原理，底层数据结构sds和跳表等")]),s._v(" "),v("h2",{attrs:{id:"数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[s._v("#")]),s._v(" 数据结构")]),s._v(" "),v("h4",{attrs:{id:"常见的数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的数据结构"}},[s._v("#")]),s._v(" 常见的数据结构？")]),s._v(" "),v("p",[s._v("1、string")]),s._v(" "),v("p",[s._v("2、list")]),s._v(" "),v("p",[s._v("3、hash")]),s._v(" "),v("p",[s._v("4、set")]),s._v(" "),v("p",[s._v("5、sortedSet")]),s._v(" "),v("p",[v("img",{attrs:{src:a(482),alt:"img",loading:"lazy"}})]),s._v(" "),v("h4",{attrs:{id:"redis-数据结构和内部实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-数据结构和内部实现"}},[s._v("#")]),s._v(" Redis 数据结构和内部实现")]),s._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/a4f2f206eedc4b7a9b01c103517aaffe.png",alt:"img"}}),s._v(" "),v("h3",{attrs:{id:"string"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[s._v("#")]),s._v(" String：")]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("简介")]),s._v(":String是Redis最基础的数据结构类型，它是二进制安全的，可以存储图片或者序列化的对象，值最大存储为512M")]),s._v(" "),v("li",[v("strong",[s._v("简单使用举例:")]),s._v(" set key value 、 get key 等")]),s._v(" "),v("li",[v("strong",[s._v("应用场景")]),s._v("：共享session、分布式锁，计数器、限流。")])]),s._v(" "),v("p",[s._v("C语言的字符串是 char[] 实现的，而Redis使用 **SDS（simple dynamic string）**封装，sds源码如下")]),s._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[s._v("struct sdshdr"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    unsigned "),v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" len"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 标记buf的长度")]),s._v("\n\n    unsigned "),v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" free"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//标记buf中未使用的元素个数")]),s._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" buf"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 存放元素的坑")]),s._v("\n\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br"),v("span",{staticClass:"line-number"},[s._v("2")]),v("br"),v("span",{staticClass:"line-number"},[s._v("3")]),v("br"),v("span",{staticClass:"line-number"},[s._v("4")]),v("br"),v("span",{staticClass:"line-number"},[s._v("5")]),v("br"),v("span",{staticClass:"line-number"},[s._v("6")]),v("br"),v("span",{staticClass:"line-number"},[s._v("7")]),v("br"),v("span",{staticClass:"line-number"},[s._v("8")]),v("br"),v("span",{staticClass:"line-number"},[s._v("9")]),v("br")])]),v("p",[s._v("SDS 结构图如下：")]),s._v(" "),v("p",[v("img",{attrs:{src:a(483),alt:"img",loading:"lazy"}})]),s._v(" "),v("p",[s._v("Redis为什么选择 "),v("strong",[s._v("SDS")]),s._v("结构，而C语言原生的 char[] 不香吗？")]),s._v(" "),v("blockquote",[v("p",[s._v("举例其中一点，SDS中，O(1)时间复杂度，就可以获取字符串长度；而C 字符串，需要遍历整个字符串，时间复杂度为O(n)")])]),s._v(" "),v("h3",{attrs:{id:"hash"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[s._v("#")]),s._v(" Hash：")]),s._v(" "),v("ul",[v("li",[s._v("简介：在Redis中，哈希类型是指v（值）本身又是一个键值对（k-v）结构")]),s._v(" "),v("li",[s._v("简单使用举例： hset key field value 、 hget key field")]),s._v(" "),v("li",[s._v("内部编码： ziplist（压缩列表） 、 hashtable（哈希表）")]),s._v(" "),v("li",[s._v("应用场景：缓存用户信息等。")])]),s._v(" "),v("h3",{attrs:{id:"list"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[s._v("#")]),s._v(" List：")]),s._v(" "),v("ul",[v("li",[s._v("简介：列表（list）类型是用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素。")]),s._v(" "),v("li",[s._v("简单实用举例： lpush key value [value ...] 、 lrange key start end")]),s._v(" "),v("li",[s._v("内部编码：ziplist（压缩列表）、linkedlist（链表）")]),s._v(" "),v("li",[s._v("应用场景：消息队列，文章列表")])]),s._v(" "),v("p",[s._v("一图看懂list类型的插入与弹出：")]),s._v(" "),v("p",[v("img",{attrs:{src:a(484),alt:"img",loading:"lazy"}})]),s._v(" "),v("p",[s._v("list应用场景参考以下：")]),s._v(" "),v("blockquote",[v("ul",[v("li",[s._v("lpush+lpop=Stack（栈）")]),s._v(" "),v("li",[s._v("lpush+rpop=Queue（队列）")]),s._v(" "),v("li",[s._v("lpsh+ltrim=Capped Collection（有限集合）")]),s._v(" "),v("li",[s._v("lpush+brpop=Message Queue（消息队列）")])])]),s._v(" "),v("h3",{attrs:{id:"set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[s._v("#")]),s._v(" Set：")]),s._v(" "),v("ul",[v("li",[s._v("简介：集合（set）类型也是用来保存多个的字符串元素，但是不允许重复元素")]),s._v(" "),v("li",[s._v("简单使用举例： sadd key element [element ...] 、 smembers key")]),s._v(" "),v("li",[s._v("内部编码： intset（整数集合） 、 hashtable（哈希表）")]),s._v(" "),v("li",[v("strong",[s._v("注意点")]),s._v("：smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，可以使用sscan来完成。")]),s._v(" "),v("li",[s._v("应用场景：用户标签,生成随机数抽奖、社交需求。")])]),s._v(" "),v("h3",{attrs:{id:"sorterset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sorterset"}},[s._v("#")]),s._v(" SorterSet：")]),s._v(" "),v("ul",[v("li",[s._v("简介：已排序的字符串集合，同时元素不能重复。和 set 区别是多了权重值。")]),s._v(" "),v("li",[s._v("简单格式举例： zadd key score member [score member ...] ， zrank key member")]),s._v(" "),v("li",[s._v("底层内部编码： ziplist（压缩列表） 、 skiplist（跳跃表）")]),s._v(" "),v("li",[s._v("应用场景：排行榜，社交需求（如用户点赞）。")])]),s._v(" "),v("p",[s._v("https://www.sohu.com/a/486868862_121124376")]),s._v(" "),v("h5",{attrs:{id:"redis-的三种特殊数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-的三种特殊数据类型"}},[s._v("#")]),s._v(" Redis 的三种特殊数据类型")]),s._v(" "),v("ul",[v("li",[s._v("Geo：Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作。")]),s._v(" "),v("li",[s._v("HyperLogLog：用来做基数统计算法的数据结构，如统计网站的UV。")]),s._v(" "),v("li",[s._v("Bitmaps ：用一个比特位来映射某个元素的状态，在Redis中，它的底层是基于字符串类型实现的，可以把bitmaps成作一个以比特位为单位的数组")])]),s._v(" "),v("h3",{attrs:{id:"redis-的常用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-的常用场景"}},[s._v("#")]),s._v(" Redis 的常用场景")]),s._v(" "),v("h2",{attrs:{id:"单线程模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单线程模型"}},[s._v("#")]),s._v(" 单线程模型")]),s._v(" "),v("p",[v("strong",[s._v("Redis")]),s._v(" 内部使用文件事件处理器 "),v("code",[s._v("file event handler")]),s._v("，这个文件事件处理器是单线程的，所以 "),v("strong",[s._v("Redis")]),s._v(" 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 "),v("strong",[s._v("Socket")]),s._v("，根据 "),v("strong",[s._v("Socket")]),s._v(" 上的事件来选择对应的事件处理器进行处理。")]),s._v(" "),v("p",[s._v("文件事件处理器的结构包含 4 个部分：")]),s._v(" "),v("ul",[v("li",[s._v("多个 "),v("strong",[s._v("Socket")])]),s._v(" "),v("li",[s._v("IO 多路复用程序")]),s._v(" "),v("li",[s._v("文件事件分派器")]),s._v(" "),v("li",[s._v("事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）")])]),s._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/f747102c58bf4811b2b4a0ec8aae14bd.png",alt:"img"}}),s._v(" "),v("h5",{attrs:{id:"i-o-多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#i-o-多路复用"}},[s._v("#")]),s._v(" I/O 多路复用")]),s._v(" "),v("p",[s._v("多路I/O复用技术可以让单个线程高效的处理多个连接请求，而 Redis 使用用 epoll 作为I/O多路复用技术的实现。并且，Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。")]),s._v(" "),v("h5",{attrs:{id:"什么是i-o多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是i-o多路复用"}},[s._v("#")]),s._v(" 什么是I/O多路复用？")]),s._v(" "),v("blockquote",[v("ul",[v("li",[s._v("I/O ：网络 I/O")]),s._v(" "),v("li",[s._v("多路 ：多个网络连接")]),s._v(" "),v("li",[s._v("复用：复用同一个线程。")])])]),s._v(" "),v("p",[s._v("IO多路复用其实就是一种同步IO模型，它实现了一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；而没有文件句柄就绪时,就会阻塞应用程序，交出cpu。")]),s._v(" "),v("h5",{attrs:{id:"追问-为什么-redis-6-0-之后引入了多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#追问-为什么-redis-6-0-之后引入了多线程"}},[s._v("#")]),s._v(" 追问：为什么 Redis 6.0 之后引入了多线程？")]),s._v(" "),v("p",[s._v("主要是为了提高网络 IO 读写性能。")]),s._v(" "),v("h5",{attrs:{id:"追问2-为什么-6-0-之前不用多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#追问2-为什么-6-0-之前不用多线程"}},[s._v("#")]),s._v(" 追问2：为什么 6.0 之前不用多线程？")]),s._v(" "),v("ol",[v("li",[s._v("单线程编程容易并且更容易维护；")]),s._v(" "),v("li",[s._v("Redis 的性能瓶颈不在 CPU ，主要在内存和网络；")]),s._v(" "),v("li",[s._v("多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。")])]),s._v(" "),v("h2",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[s._v("#")])]),s._v(" "),v("h2",{attrs:{id:"持久化机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#持久化机制"}},[s._v("#")]),s._v(" 持久化机制")]),s._v(" "),v("h4",{attrs:{id:"持久化机制是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#持久化机制是什么"}},[s._v("#")]),s._v(" 持久化机制是什么？")]),s._v(" "),v("p",[s._v("Redis是基于内存的非关系型K-V数据库，既然它是基于内存的，如果Redis服务器挂了，数据就会丢失。为了避免数据丢失了，Redis提供了 "),v("strong",[s._v("持久化")]),s._v("，即把数据保存到磁盘。")]),s._v(" "),v("h4",{attrs:{id:"redis-持久化机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制"}},[s._v("#")]),s._v(" redis 持久化机制？")]),s._v(" "),v("p",[s._v("Redis提供了 "),v("strong",[s._v("RDB和AOF")]),s._v("两种持久化机制，它持久化文件加载流程如下：")]),s._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/8507312ca27441d9b6fe3f2a8bbb076c.png",alt:"img"}}),s._v(" "),v("h3",{attrs:{id:"rdb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[s._v("#")]),s._v(" RDB")]),s._v(" "),v("p",[s._v("RDB：就是把内存数据以快照的形式保存到磁盘上。")]),s._v(" "),v("p",[s._v("RDB 持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是 Redis 默认的持久化方式。执行完操作后，在指定目录下会生成一个 dump.rdb 文件，Redis 重启的时候，通过加载 dump.rdb 文件来恢复数据。")]),s._v(" "),v("h5",{attrs:{id:"原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[s._v("#")]),s._v(" 原理：")]),s._v(" "),v("p",[s._v("fork是指redis通过创建子进程来进行RDB操作，cow指的是"),v("strong",[s._v("copy on write")]),s._v("，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。")]),s._v(" "),v("h5",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[s._v("#")]),s._v(" 优点：")]),s._v(" "),v("p",[s._v("AOF："),v("strong",[s._v("AOF")]),s._v(" 机制对每条写入命令作为日志，以 "),v("strong",[s._v("append-only")]),s._v(" 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的"),v("strong",[s._v("binlog")])]),s._v(" "),v("p",[v("strong",[s._v("这里很好理解，把 RDB 理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功； AOF/RDB文件存在错误时，Redis启动失败并打印错误信息")])]),s._v(" "),v("h5",{attrs:{id:"_1-1-那如果突然机器掉电会怎样"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-那如果突然机器掉电会怎样"}},[s._v("#")]),s._v(" 1.1 那如果突然机器掉电会怎样？")]),s._v(" "),v("p",[s._v("取决于AOF日志 sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。")]),s._v(" "),v("h5",{attrs:{id:"_1-3-rdb-和-aof-机制的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-rdb-和-aof-机制的优缺点"}},[s._v("#")]),s._v(" 1.3 RDB 和 AOF 机制的优缺点？")]),s._v(" "),v("h5",{attrs:{id:"rdb-优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdb-优点"}},[s._v("#")]),s._v(" RDB 优点：")]),s._v(" "),v("p",[s._v("他会生成多个数据文件，每个数据文件分别都代表了某一时刻"),v("strong",[s._v("Redis")]),s._v("里面的数据，这种方式，有没有觉得很适合做"),v("strong",[s._v("冷备")]),s._v("，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。")]),s._v(" "),v("p",[v("strong",[s._v("RDB")]),s._v("对"),v("strong",[s._v("Redis")]),s._v("的性能影响非常小，是因为在同步数据的时候他只是"),v("strong",[s._v("fork")]),s._v("了一个子进程去做持久化的，而且他在数据恢复的时候速度比"),v("strong",[s._v("AOF")]),s._v("来的快。")]),s._v(" "),v("h5",{attrs:{id:"rdb-缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdb-缺点"}},[s._v("#")]),s._v(" RDB 缺点：")]),s._v(" "),v("p",[v("strong",[s._v("RDB")]),s._v("都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。"),v("strong",[s._v("AOF")]),s._v("则最多丢一秒的数据，"),v("strong",[s._v("数据完整性")]),s._v("上高下立判。")]),s._v(" "),v("p",[s._v("还有就是"),v("strong",[s._v("RDB")]),s._v("在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候"),v("strong",[s._v("fork")]),s._v("了一个子进程去生成一个大快照，哦豁，出大问题。")]),s._v(" "),v("p",[s._v("我们再来说说"),v("strong",[s._v("AOF")])]),s._v(" "),v("h5",{attrs:{id:"aof-优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aof-优点"}},[s._v("#")]),s._v(" AOF 优点：")]),s._v(" "),v("p",[s._v("上面提到了，"),v("strong",[s._v("RDB")]),s._v("五分钟一次生成快照，但是"),v("strong",[s._v("AOF")]),s._v("是一秒一次去通过一个后台的线程"),v("code",[s._v("fsync")]),s._v("操作，那最多丢这一秒的数据。")]),s._v(" "),v("p",[v("strong",[s._v("AOF")]),s._v("在对日志文件进行操作的时候是以"),v("code",[s._v("append-only")]),s._v("的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。")]),s._v(" "),v("p",[v("strong",[s._v("AOF")]),s._v("的日志是通过一个叫"),v("strong",[s._v("非常可读")]),s._v("的方式记录的，这样的特性就适合做"),v("strong",[s._v("灾难性数据误删除")]),s._v("的紧急恢复了，比如公司的实习生通过"),v("strong",[s._v("flushall")]),s._v("清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份"),v("strong",[s._v("AOF")]),s._v("日志文件，把最后一条"),v("strong",[s._v("flushall")]),s._v("命令删了就完事了。")]),s._v(" "),v("h5",{attrs:{id:"aof-缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aof-缺点"}},[s._v("#")]),s._v(" AOF 缺点：")]),s._v(" "),v("p",[s._v("一样的数据，"),v("strong",[s._v("AOF")]),s._v("文件比"),v("strong",[s._v("RDB")]),s._v("还要大。")]),s._v(" "),v("p",[v("strong",[s._v("AOF")]),s._v("开启后，"),v("strong",[s._v("Redis")]),s._v("支持写的"),v("strong",[s._v("QPS")]),s._v("会比"),v("strong",[s._v("RDB")]),s._v("支持写的要低，他不是每秒都要去异步刷新一次日志嘛"),v("strong",[s._v("fsync")]),s._v("，当然即使这样性能还是很高，我记得"),v("strong",[s._v("ElasticSearch")]),s._v("也是这样的，异步刷新缓存区的数据去持久化，为啥这么做呢，不直接来一条怼一条呢，那我会告诉你这样性能可能低到没办法用的，这里和 mysql 的 buffer pool 相似。")]),s._v(" "),v("p",[s._v("单独用"),v("strong",[s._v("RDB")]),s._v("你会丢失很多数据，你单独用"),v("strong",[s._v("AOF")]),s._v("，你数据恢复没"),v("strong",[s._v("RDB")]),s._v("来的快，真出什么时候第一时间用"),v("strong",[s._v("RDB")]),s._v("恢复，然后"),v("strong",[s._v("AOF")]),s._v("做数据补全，真香！冷备热备一起上，才是互联网时代一个高健壮性系统的王道。")]),s._v(" "),v("h4",{attrs:{id:"_2、redis的同步机制了解么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、redis的同步机制了解么"}},[s._v("#")]),s._v(" 2、Redis的同步机制了解么？")]),s._v(" "),v("p",[s._v("Redis可以使用主从同步，从从同步。")]),s._v(" "),v("p",[s._v("启动一台slave 的时候，他会发送一个"),v("strong",[s._v("psync")]),s._v("命令给master ，如果是这个 slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成"),v("strong",[s._v("RDB")]),s._v("快照，还会把新的写请求都缓存在内存中，"),v("strong",[s._v("RDB")]),s._v("文件生成后，master会将这个"),v("strong",[s._v("RDB")]),s._v("发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。")]),s._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/7/16e43d17dfaf05bb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"img"}}),s._v(" "),v("h5",{attrs:{id:"数据传输的时候断网了或者服务器挂了怎么办啊"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据传输的时候断网了或者服务器挂了怎么办啊"}},[s._v("#")]),s._v(" 数据传输的时候断网了或者服务器挂了怎么办啊？")]),s._v(" "),v("p",[s._v("传输过程中有什么网络问题啥的，会自动重连的，并且连接之后会把缺少的数据补上的。")]),s._v(" "),v("p",[v("strong",[s._v("大家需要记得的就是，RDB快照的数据生成的时候，缓存区也必须同时开始接受新请求，不然你旧的数据过去了，你在同步期间的增量数据咋办？是吧？")])]),s._v(" "),v("h4",{attrs:{id:"哨兵模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[s._v("#")]),s._v(" 哨兵模式")]),s._v(" "),v("p",[s._v("哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并"),v("strong",[s._v("不能保证数据不丢失")]),s._v("，但是可以保证集群的"),v("strong",[s._v("高可用")]),s._v("。")]),s._v(" "),v("p",[s._v("两台不行的，挂了一台，故障转移是不执行的。")]),s._v(" "),v("p",[s._v("哨兵组件的主要功能：")]),s._v(" "),v("ul",[v("li",[s._v("集群监控：负责监控 Redis master 和 slave 进程是否正常工作。")]),s._v(" "),v("li",[s._v("消息通知：如果某个 "),v("strong",[s._v("Redis")]),s._v(" 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。")]),s._v(" "),v("li",[s._v("故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。")]),s._v(" "),v("li",[s._v("配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。")])]),s._v(" "),v("h2",{attrs:{id:"常见问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[s._v("#")]),s._v(" 常见问题")]),s._v(" "),v("h4",{attrs:{id:"缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[s._v("#")]),s._v(" 缓存雪崩？")]),s._v(" "),v("h5",{attrs:{id:"两种情况"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两种情况"}},[s._v("#")]),s._v(" 两种情况：")]),s._v(" "),v("p",[s._v("1、Redis 服务器宕机")]),s._v(" "),v("p",[s._v("2、缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。")]),s._v(" "),v("p",[v("strong",[s._v("针对第一种情况：")])]),s._v(" "),v("p",[s._v("​\t采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。")]),s._v(" "),v("p",[v("strong",[s._v("针对热点缓存失效的情况：")])]),s._v(" "),v("ol",[v("li",[s._v("往"),v("strong",[s._v("Redis")]),s._v("存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效。")]),s._v(" "),v("li",[s._v("缓存永不失效。")])]),s._v(" "),v("h4",{attrs:{id:"缓存穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[s._v("#")]),s._v(" 缓存穿透？")]),s._v(" "),v("p",[s._v("读请求访问时，缓存和数据库都没有某个值，这样就会导致每次对这个值的查询请求都会穿透到数据库，这就是缓存穿透。")]),s._v(" "),v("h5",{attrs:{id:"产生原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[s._v("#")]),s._v(" 产生原因：")]),s._v(" "),v("p",[s._v("举个例子，用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。")]),s._v(" "),v("h5",{attrs:{id:"解决办法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[s._v("#")]),s._v(" 解决办法：")]),s._v(" "),v("p",[s._v("1、接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。")]),s._v(" "),v("p",[s._v("2、其次可缓存无效 key，如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间。这样下次再请求的时候，就不会查询数据库。")]),s._v(" "),v("p",[s._v("3、还可以使用布隆过滤器，把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会判断缓存重是否存在对应的数据。")]),s._v(" "),v("h5",{attrs:{id:"追问-布隆过滤器原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#追问-布隆过滤器原理"}},[s._v("#")]),s._v(" 追问：布隆过滤器原理？")]),s._v(" "),v("blockquote",[v("p",[s._v("它由初始值为0的比特数组和 N 个哈希函数组成。一个对一个 key  进行 N 个 hash 算法获取 N 个值，在比特数组中将这 N 个值散列后设定为1，然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该 key 存在。")])]),s._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/20210225105747809.png",alt:"img"}}),s._v(" "),v("p",[s._v("https://blog.csdn.net/lotus35/article/details/114005198")]),s._v(" "),v("h5",{attrs:{id:"追问2-布隆过滤器存在的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#追问2-布隆过滤器存在的问题"}},[s._v("#")]),s._v(" 追问2：布隆过滤器存在的问题?")]),s._v(" "),v("p",[s._v("布隆过滤器中存在的数据，实际数据中不一定存在。因为随着增加的值越来越多，某几位的 bit 位可能已经变为 1 了，这样某个值即使没有存过，但是它的 hash 值对应的位置值恰巧被设置 1 了，这是就会出现实际值不存在的情况。")]),s._v(" "),v("h4",{attrs:{id:"缓存击穿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[s._v("#")]),s._v(" 缓存击穿？")]),s._v(" "),v("h5",{attrs:{id:"产生原因-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#产生原因-2"}},[s._v("#")]),s._v(" 产生原因：")]),s._v(" "),v("p",[s._v("指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。")]),s._v(" "),v("p",[s._v("缓存击穿看着有点像，其实它两区别是，缓存雪奔是指数据库压力过大甚至down机，缓存击穿只是大量并发请求到了DB数据库层面。可以认为击穿是缓存雪奔的一个子集吧。有些文章认为它俩区别，是区别在于击穿针对某一热点key缓存，雪崩则是很多key。")]),s._v(" "),v("h5",{attrs:{id:"解决办法-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决办法-2"}},[s._v("#")]),s._v(" 解决办法：")]),s._v(" "),v("p",[s._v("1、设置热点数据永远不过期。"),v("strong",[s._v("“永不过期”")]),s._v("，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。")]),s._v(" "),v("p",[s._v("2、加上互斥锁就能搞定了。")]),s._v(" "),v("p",[s._v("缓存失效时，不是立即去加载 db 数据，而是先获取锁，成功的时候才会查数据库并且设置缓存，否则的话就重试尝试获取数据。")]),s._v(" "),v("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/5/16e3727d72b459eb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"img"}}),s._v(" "),v("h4",{attrs:{id:"热-key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#热-key"}},[s._v("#")]),s._v(" 热 key")]),s._v(" "),v("p",[s._v("在Redis中，我们把访问频率高的key，称为热点key。")]),s._v(" "),v("h5",{attrs:{id:"产生原因-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#产生原因-3"}},[s._v("#")]),s._v(" 产生原因：")]),s._v(" "),v("p",[s._v("1、用户消费的数据远大于生产的数据，如秒杀、热点新闻等读多写少的场景。\n2、请求分片集中，超过单Redi服务器的性能，比如固定名称key，"),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[s._v("Hash"),v("OutboundLink")],1),s._v("落入同一台服务器，瞬间访问量极大，超过机器瓶颈，产生热点Key问题。")]),s._v(" "),v("h5",{attrs:{id:"解决办法-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决办法-3"}},[s._v("#")]),s._v(" 解决办法：")]),s._v(" "),v("p",[s._v("1、Redis 集群扩容：增加分片副本，均衡读流量；\n2、将热 key 分散到不同的服务器中；\n3、使用二级缓存，即 JVM 本地缓存,减少Redis的读请求。")]),s._v(" "),v("h5",{attrs:{id:"追问-本地-jvm-缓存怎实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#追问-本地-jvm-缓存怎实现"}},[s._v("#")]),s._v(" 追问：本地 JVM 缓存怎实现？")]),s._v(" "),v("p",[s._v("实现方式有很多，譬如"),v("strong",[s._v("用static hashMap基于内存缓存")]),s._v("。")]),s._v(" "),v("p",[s._v("缺点：容易"),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[s._v("内存溢出"),v("OutboundLink")],1),s._v("、没有持久化（服务重启后丢失）、多个服务器（多个jvm）之间的数据不能共享")]),s._v(" "),v("h4",{attrs:{id:"过期策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过期策略"}},[s._v("#")]),s._v(" 过期策略")]),s._v(" "),v("p",[s._v("redis 过期策略：定期删除 + 惰性删除。")]),s._v(" "),v("p",[s._v("定期好理解，默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。")]),s._v(" "),v("h5",{attrs:{id:"_4-1-redis-如何判断数据过期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-redis-如何判断数据过期"}},[s._v("#")]),s._v(" 4.1 redis 如何判断数据过期？")]),s._v(" "),v("p",[s._v("​\t\tRedis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个key(键)，过期字典的值是一个 long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间。")]),s._v(" "),v("h5",{attrs:{id:"_4-2-为啥不扫描全部设置了过期时间的key呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-为啥不扫描全部设置了过期时间的key呢"}},[s._v("#")]),s._v(" 4.2 为啥不扫描全部设置了过期时间的key呢？")]),s._v(" "),v("p",[s._v("假如Redis里面所有的key都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100ms一次，Redis累都累死了。")]),s._v(" "),v("h5",{attrs:{id:"_4-3-如果一直没随机到很多key-里面不就存在大量的无效key了"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-如果一直没随机到很多key-里面不就存在大量的无效key了"}},[s._v("#")]),s._v(" 4.3 如果一直没随机到很多key，里面不就存在大量的无效key了？")]),s._v(" "),v("p",[s._v("好问题，"),v("strong",[s._v("惰性删除")]),s._v("，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。")]),s._v(" "),v("h5",{attrs:{id:"_4-4-如果-定期没删-我也没查询-那可咋整"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-如果-定期没删-我也没查询-那可咋整"}},[s._v("#")]),s._v(" 4.4 如果，定期没删，我也没查询，那可咋整？")]),s._v(" "),v("p",[v("strong",[s._v("内存淘汰机制")]),s._v("！")]),s._v(" "),v("h4",{attrs:{id:"淘汰机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#淘汰机制"}},[s._v("#")]),s._v(" 淘汰机制")]),s._v(" "),v("p",[s._v("官网上给到的内存淘汰机制是以下几个：")]),s._v(" "),v("p",[s._v("报错：")]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("noeviction")]),s._v(":默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。")])]),s._v(" "),v("p",[s._v("LRU:")]),s._v(" "),v("ul",[v("li",[s._v("volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；")]),s._v(" "),v("li",[s._v("allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。")])]),s._v(" "),v("p",[s._v("随机：")]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("allkeys-random")]),s._v(": 当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。")]),s._v(" "),v("li",[v("strong",[s._v("volatile-random")]),s._v(": 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。")]),s._v(" "),v("li",[v("strong",[s._v("volatile-ttl")]),s._v(": 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。")])]),s._v(" "),v("p",[s._v("LRU 算法：")]),s._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/7/16e43d17e5d370b1~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"img"}}),s._v(" "),v("h4",{attrs:{id:"_6、多个系统同时操作-并发-redis-带来的数据问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、多个系统同时操作-并发-redis-带来的数据问题"}},[s._v("#")]),s._v(" 6、多个系统同时操作(并发) Redis 带来的数据问题？")]),s._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/11/16e566884868a9cb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"img"}}),s._v(" "),v("p",[s._v("系统A、B、C三个系统，分别去操作"),v("strong",[s._v("Redis")]),s._v("的同一个Key，本来顺序是1，2，3是正常的，但是因为系统A网络突然抖动了一下，B，C在他前面操作了"),v("strong",[s._v("Redis")]),s._v("，这样数据不就错了么。")]),s._v(" "),v("p",[s._v("就好比下单，支付，退款三个顺序你变了，你先退款，再下单，再支付，那流程就会失败，那数据不就乱了？你订单还没生成你却支付，退款了？明显走不通了，这在线上是很恐怖的事情")]),s._v(" "),v("p",[s._v("某个时刻，多个系统实例都去更新某个 key。可以准备分布式锁，通过 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 Key，别人都不允许读和写。")]),s._v(" "),v("p",[s._v("你要写入缓存的数据，都是从 "),v("strong",[s._v("MySQL")]),s._v(" 里查出来的，都得写入 "),v("strong",[s._v("MySQL")]),s._v(" 中，写入 "),v("strong",[s._v("MySQL")]),s._v(" 中的时候必须保存一个时间戳，从 "),v("strong",[s._v("MySQL")]),s._v(" 查出来的时候，时间戳也查出来。")]),s._v(" "),v("p",[s._v("每次要"),v("strong",[s._v("写之前，先判断")]),s._v("一下当前这个 Value 的时间戳是否比缓存里的 Value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。")]),s._v(" "),v("h4",{attrs:{id:"_7、怎样保证缓存和数据库数据的一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7、怎样保证缓存和数据库数据的一致性"}},[s._v("#")]),s._v(" 7、怎样保证缓存和数据库数据的一致性")]),s._v(" "),v("p",[s._v("旁路缓存模式：这种模式遇到写请求是这样的，更新 DB，然后直接删除 cache 。")]),s._v(" "),v("h5",{attrs:{id:"_7-1-为什么是删除缓存而不是更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-为什么是删除缓存而不是更新"}},[s._v("#")]),s._v(" 7.1 为什么是删除缓存而不是更新？")]),s._v(" "),v("p",[s._v("因为对于比较复杂的缓存数据计算的场景，如果频繁的修改缓存，问题在于这个缓存是不是会被频繁的访问到。譬如 一个表的某个字段，在一分钟内被修改了 20次，那么缓存更新了 20 次，但这个缓存在 1 分钟之内只被读取了一次，有大量的冷数据。")]),s._v(" "),v("h5",{attrs:{id:"_7-2-如果更新数据库成功-而删除缓存这一步失败的情况的话"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-如果更新数据库成功-而删除缓存这一步失败的情况的话"}},[s._v("#")]),s._v(" 7.2 如果更新数据库成功，而删除缓存这一步失败的情况的话")]),s._v(" "),v("blockquote",[v("p",[v("strong",[s._v("增加cache更新重试机制（常用）")]),s._v("： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。")])]),s._v(" "),v("h4",{attrs:{id:"缓存常用的三种读写策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存常用的三种读写策略"}},[s._v("#")]),s._v(" 缓存常用的三种读写策略？")]),s._v(" "),v("p",[s._v("1、旁路缓存模式：服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。")]),s._v(" "),v("p",[s._v("写：先更新 DB，然后直接删除 cache。")]),s._v(" "),v("p",[s._v("读：从 cache 中读取数据，读到就直接返回，读取不到就从 DB 中读取数据返回，再把数据放到 cache 中。")]),s._v(" "),v("h5",{attrs:{id:"缺点1-首次请求数据一定不在-cache中。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点1-首次请求数据一定不在-cache中。"}},[s._v("#")]),s._v(" 缺点1：首次请求数据一定不在 cache中。")]),s._v(" "),v("p",[s._v("解决办法：可以将热点数据可以提前放入cache 中。")]),s._v(" "),v("p",[v("strong",[s._v("缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。")])]),s._v(" "),v("p",[s._v("解决办法：")]),s._v(" "),v("ul",[v("li",[s._v("数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。")]),s._v(" "),v("li",[s._v("可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小")])]),s._v(" "),v("p",[s._v("读写穿透：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。")]),s._v(" "),v("p",[v("strong",[s._v("写（Write Through）：")])]),s._v(" "),v("ul",[v("li",[s._v("先查 cache，cache 中不存在，直接更新 DB。")]),s._v(" "),v("li",[s._v("cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（"),v("strong",[s._v("同步更新 cache 和 DB")]),s._v("）。")])]),s._v(" "),v("p",[v("strong",[s._v("读(Read Through)：")])]),s._v(" "),v("ul",[v("li",[s._v("从 cache 中读取数据，读取到就直接返回 。")]),s._v(" "),v("li",[s._v("读取不到的话，先从 DB 加载，写入到 cache 后返回响应。")])]),s._v(" "),v("p",[s._v("异步缓存写入：和读写穿透很像，但是是异步写入DB。")]),s._v(" "),v("h4",{attrs:{id:"redis的虚拟内存机制是啥呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis的虚拟内存机制是啥呢"}},[s._v("#")]),s._v(" "),v("strong",[s._v("Redis的虚拟内存机制是啥呢？")])]),s._v(" "),v("p",[s._v("虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题")]),s._v(" "),v("h4",{attrs:{id:"跳跃表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跳跃表"}},[s._v("#")]),s._v(" 跳跃表")]),s._v(" "),v("p",[v("img",{attrs:{src:a(485),alt:"img",loading:"lazy"}})]),s._v(" "),v("ul",[v("li",[s._v("跳跃表是Redis特有的数据结构，就是在链表的基础上，增加多级索引提升查找效率。")])]),s._v(" "),v("p",[s._v("有大量的数据时，我们可以增加多级索引，在查询时，效率可以得到明显的提升。具体的实现不是很清楚了。")]),s._v(" "),v("h4",{attrs:{id:"多大叫大key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多大叫大key"}},[s._v("#")]),s._v(" 多大叫大key")]),s._v(" "),v("p",[v("strong",[s._v("大 key 定义:")])]),s._v(" "),v("ol",[v("li",[v("p",[s._v("一个简单的key存储的value值特别大")])]),s._v(" "),v("li",[v("p",[s._v("hash, set, zset, list 中存储过多的元素")])]),s._v(" "),v("li",[v("p",[s._v("某个集群存储了许多许多的key")])]),s._v(" "),v("li",[v("p",[s._v("大 Bitmap 或布隆过滤器 (Bloom)")])])]),s._v(" "),v("h5",{attrs:{id:"解决方法-拆分-清理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方法-拆分-清理"}},[s._v("#")]),s._v(" 解决方法: 拆分+清理")]),s._v(" "),v("p",[v("strong",[s._v("1")]),s._v("：一个简单的key存储的value值特别大")]),s._v(" "),v("ul",[v("li",[s._v("分拆成几个key-value，使用multiGet获取值，缓解单次压力。并且将压力平摊到多个redis实例中")])]),s._v(" "),v("p",[v("strong",[s._v("2")]),s._v("："),v("strong",[s._v("hash")]),s._v("， "),v("strong",[s._v("set")]),s._v("，"),v("strong",[s._v("zset")]),s._v("，"),v("strong",[s._v("list")]),s._v(" 中存储过多的元素")]),s._v(" "),v("p",[s._v("利用计算key的hash值分摊到多个容器中。")]),s._v(" "),v("p",[s._v("如：固定一个桶数量100，每次存取的时候本地计算field的hash值，模除 100，决定落到哪个key上面。存的时候按照key_XX存储，取的时候从key_0一直到key_99，都取出来再放到一起")]),s._v(" "),v("h4",{attrs:{id:"如果有大量的key需要设置同一时间过期-一般需要注意什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如果有大量的key需要设置同一时间过期-一般需要注意什么"}},[s._v("#")]),s._v(" 如果有大量的key需要设置同一时间过期，一般需要注意什么？")]),s._v(" "),v("p",[s._v("如果大量的key过期时间设置的过于集中，到过期的那个时间点，"),v("strong",[s._v("Redis")]),s._v("可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，我们一般需要在时间上加一个随机值，使得过期时间分散一些。")]),s._v(" "),v("p",[v("strong",[s._v("电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩")]),s._v("。")]),s._v(" "),v("h4",{attrs:{id:"redis-为什么快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-为什么快"}},[s._v("#")]),s._v(" Redis 为什么快?")]),s._v(" "),v("p",[s._v("1、基于内存存储实现")]),s._v(" "),v("p",[s._v("我们都知道内存读写是比在磁盘快很多的，Redis基于内存存储实现的数据库，相对于数据存在磁盘的MySQL数据库，省去磁盘I/O的消耗。")]),s._v(" "),v("p",[s._v("2、 高效的数据结构")]),s._v(" "),v("p",[s._v("3、线程模型")]),s._v(" "),v("p",[s._v("4、虚拟内存机制")])])}),[],!1,null,null,null);t.default=_.exports}}]);