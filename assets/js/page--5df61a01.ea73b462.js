(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{606:function(a,t,s){a.exports=s.p+"assets/img/22d70c7550294a1e9e92eceb3ed044d8.7d9bb55a.png"},607:function(a,t,s){a.exports=s.p+"assets/img/25d8b8fd80614ea39fa5e72d1307ff49.983e17fe.png"},736:function(a,t,s){"use strict";s.r(t);var r=s(1),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/4710762ac84c4eac855fea406565ec4b.png",alt:"Java对象组成结构"}}),a._v(" "),r("p",[a._v("在Java"),r("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[a._v("内存"),r("OutboundLink")],1),a._v("中，Java对象由三个部分组成：对象头、实例数据、对齐填充。下面依次来讲下这三个部分。")]),a._v(" "),r("h3",{attrs:{id:"一、对象头"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、对象头"}},[a._v("#")]),a._v(" 一、对象头")]),a._v(" "),r("p",[a._v("对象头的组成部分如下图所示：")]),a._v(" "),r("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/70c9febc98e64814819fcfb96197c750.png",alt:"在这里插入图片描述"}}),a._v(" "),r("h4",{attrs:{id:"_1、markworld-运行时元数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、markworld-运行时元数据"}},[a._v("#")]),a._v(" 1、MarkWorld（运行时元数据）")]),a._v(" "),r("p",[a._v("Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。\nMark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：")]),a._v(" "),r("p",[r("img",{attrs:{src:s(606),alt:"在这里插入图片描述",loading:"lazy"}})]),a._v(" "),r("p",[a._v("（1）对象的 HasdCode\n它是一个地址，用于栈对堆空间中对象的引用指向，不然栈是无法找到堆中对象的")]),a._v(" "),r("p",[a._v("（2）GC分代年龄\n记录幸存者区对象被GC之后的年龄 age，一般 age 为15（阈值为15的原因是因为age只有4位最大就可以将阈值设置15）之后下一次GC就会直接进入老年代，要是还没有等到年龄为15，幸存者区就满了怎么办，那就下一次GC就将大对象或者年龄大者直接进入老年代。")]),a._v(" "),r("p",[a._v("（3）Epoch")]),a._v(" "),r("p",[a._v("线程获得偏向锁的时间戳。")]),a._v(" "),r("p",[a._v("（3）锁状态标志\n记录一些加锁的信息(我们都是使用加锁的话，在底层是锁的对象，而不是锁的代码，锁对象的话，那会改变什么信息来表示这个对象被改变了呢？也就是怎么才算加锁了呢？")]),a._v(" "),r("blockquote",[r("p",[r("strong",[a._v("答案")]),a._v("：就是改变这个对象的对象头的锁信息来标识已经加锁，下一个线程来获取是获取不到的，底层是通过比对当前的线程的那个值与它所期望的值是否相同，这时候一直自旋直到与期望值相同，相同就获取到锁，反之则进入到阻塞队列等待，这个机制叫做CAS，比较并交换–这是偏向锁的原理)")])]),a._v(" "),r("p",[r("img",{attrs:{src:s(607),alt:"在这里插入图片描述",loading:"lazy"}})]),a._v(" "),r("h4",{attrs:{id:"_2、class-point-类型指针"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、class-point-类型指针"}},[a._v("#")]),a._v(" 2、Class Point（类型指针）")]),a._v(" "),r("p",[a._v("该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。")]),a._v(" "),r("p",[a._v("Java 对象的类数据保存在方法区。")]),a._v(" "),r("h4",{attrs:{id:"_3、数组长度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、数组长度"}},[a._v("#")]),a._v(" 3、数组长度")]),a._v(" "),r("p",[a._v("只有数组对象保存了这部分数据。\n该数据在32位和64位JVM中长度都是32bit。")]),a._v(" "),r("h3",{attrs:{id:"二、实例数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、实例数据"}},[a._v("#")]),a._v(" 二、实例数据")]),a._v(" "),r("p",[a._v("真实记录一个对象包含的数据，比如说一个person对象，里面可能包含年龄、性别、身高等等")]),a._v(" "),r("p",[a._v("其中数据为字符串的，要引用到字符串常量池。")]),a._v(" "),r("h3",{attrs:{id:"三、对齐填充"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、对齐填充"}},[a._v("#")]),a._v(" 三、对齐填充")]),a._v(" "),r("p",[a._v("填充部分仅起到占位符的作用, 原因是HotSpot要求对象起始地址必须是8字节的整数，假如不是，就采用对齐填充的方式将其补齐8字节整数倍，那么为什么是8呢？原因是64位机器能被8整除的效率是最高的。")])])}),[],!1,null,null,null);t.default=e.exports}}]);