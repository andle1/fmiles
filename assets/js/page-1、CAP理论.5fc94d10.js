(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{670:function(a,t,_){"use strict";_.r(t);var s=_(1),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h4",{attrs:{id:"_1、cap理论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、cap理论"}},[a._v("#")]),a._v(" 1、CAP理论")]),a._v(" "),_("p",[a._v("CAP 定理（CAP theorem）指对于一个分布式系统来说，当设计读写操作时，只能能同时满足以下三点中的两个：")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("一致性（Consistence）")]),a._v(" : 一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值 (这个无论哪个节点就包含了故障和非故障节点)")]),a._v(" "),_("li",[_("strong",[a._v("可用性（Availability）")]),a._v(": 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。")]),a._v(" "),_("li",[_("strong",[a._v("分区容错性（Partition tolerance）")]),a._v(" : 分布式系统出现网络分区的时候，仍然能够对外提供服务。")])]),a._v(" "),_("h6",{attrs:{id:"网络分区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络分区"}},[a._v("#")]),a._v(" 网络分区？")]),a._v(" "),_("blockquote",[_("p",[a._v("​\t\t分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。")])]),a._v(" "),_("p",[a._v("​        "),_("strong",[a._v("当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。")])]),a._v(" "),_("h4",{attrs:{id:"_2、base-理论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、base-理论"}},[a._v("#")]),a._v(" 2、BASE 理论")]),a._v(" "),_("p",[a._v("CA 都要是无法实现的，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而追求最终一致性，所以引入BASE理论，在分布式事务中，BASE最重要是为CAP提出了最终一致性的解决方案，BASE强调牺牲高一致性，从而获取肯用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。")]),a._v(" "),_("p",[a._v("1、基本可用：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。")]),a._v(" "),_("p",[a._v("2、软状态：软状态指允许系统中的数据存在中间状态（"),_("strong",[a._v("CAP 理论中的数据不一致")]),a._v("），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。")]),a._v(" "),_("p",[a._v("3、最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态")]),a._v(" "),_("p",[_("strong",[a._v("ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。")])]),a._v(" "),_("p",[a._v("分布式一致性的 3 种级别：")]),a._v(" "),_("ol",[_("li",[_("strong",[a._v("强一致性")]),a._v(" ：系统写入了什么，读出来的就是什么。")]),a._v(" "),_("li",[_("strong",[a._v("弱一致性")]),a._v(" ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。")]),a._v(" "),_("li",[_("strong",[a._v("最终一致性")]),a._v(" ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。")])]),a._v(" "),_("h5",{attrs:{id:"_4、限流-降级-熔断-排队"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、限流-降级-熔断-排队"}},[a._v("#")]),a._v(" 4、限流，降级，熔断，排队")]),a._v(" "),_("p",[a._v("限流：对某个接口限制访问的频率，超过限制的请求放弃处理或者放到队列等待处理。")]),a._v(" "),_("p",[a._v("限流算法：")]),a._v(" "),_("blockquote",[_("p",[a._v("固定窗口计数器算法：记录规定时间内处理的请求数量，超出部分拒绝，然后重新计数。无法保证限流速率，无法保证突然激增的流量。")]),a._v(" "),_("p",[a._v("滑动窗口计数器算法：譬如限流每分钟60个请求，把每分钟分成60个窗口，则每个窗口一秒只能处理 60/60 个请求。")]),a._v(" "),_("p",[a._v("漏桶算法：请求类似于水注入水桶，这个水从桶中滴下的速率恒定的，多余的丢弃。")]),a._v(" "),_("p",[a._v("令牌算法：和漏桶算法差不多，只不过是保证令牌处理的速率。")])]),a._v(" "),_("p",[a._v("降级：优先保证核心服务。")]),a._v(" "),_("p",[a._v("熔断：请求失败达到一个阀值的时候，就会触发熔断。降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。")]),a._v(" "),_("p",[a._v("排队：相当于现实生活中的排队。")]),a._v(" "),_("h4",{attrs:{id:"_5、分布式唯一全局-id"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、分布式唯一全局-id"}},[a._v("#")]),a._v(" 5、分布式唯一全局 id")]),a._v(" "),_("h2",{attrs:{id:"分布式事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[a._v("#")]),a._v(" 分布式事务")]),a._v(" "),_("h4",{attrs:{id:"_1、两阶段提交-2pc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、两阶段提交-2pc"}},[a._v("#")]),a._v(" 1、两阶段提交（2pc）")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588a87ee0c96~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"image",loading:"lazy"}})]),a._v(" "),_("ul",[_("li",[a._v("每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。")]),a._v(" "),_("li",[a._v("每个数据库提交数据，或者回滚数据。")])]),a._v(" "),_("p",[a._v("最大的缺点就是同步阻塞问题，在资源准备就绪之后，资源管理器中的资源就一直处于阻塞，直到提交完成之后，才进行资源释放。")]),a._v(" "),_("h4",{attrs:{id:"_2、补充事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、补充事务"}},[a._v("#")]),a._v(" 2、补充事务")]),a._v(" "),_("p",[a._v("TCC是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel三个方法，这三个方式可以对应到SQL事务中Lock，Commit，Rollback。")]),a._v(" "),_("p",[a._v("一个下订单，生成订单扣库存的例子：")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588aa9cf1fed~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"image",loading:"lazy"}})]),a._v(" "),_("p",[a._v("接下来看看，我们的下单扣减库存的流程怎么加入TCC")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588ab8cd2a20~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"image",loading:"lazy"}})]),a._v(" "),_("p",[a._v("在try的时候，会让库存服务预留n个库存给这个订单使用，让订单服务产生一个“未确认”订单，同时产生这两个预留的资源， 在confirm的时候，会使用在try预留的资源，在TCC事务机制中认为，如果在try阶段能正常预留的资源，那么在confirm一定能完整的提交")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588ab8c51652~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"image",loading:"lazy"}})]),a._v(" "),_("p",[a._v("在try的时候，有任务一方为执行失败，则会执行cancel的接口操作，将在try阶段预留的资源进行释放。")]),a._v(" "),_("h4",{attrs:{id:"_3、本地事务表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、本地事务表"}},[a._v("#")]),a._v(" 3、本地事务表")]),a._v(" "),_("p",[a._v("核心思想是将分布式事务拆分成本地事务进行处理。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588acde414a6~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"image",loading:"lazy"}})]),a._v(" "),_("p",[a._v("对于本地消息队列来说，核心就是将大事务转变为小事务，还是用上面下订单扣库存的例子说说明")]),a._v(" "),_("ol",[_("li",[a._v("当我们去创建订单的时候，我们新增一个本地消息表，把创建订单和扣减库存写入到本地消息表，放在同一个事务（依靠数据库本地事务保证一致性）")]),a._v(" "),_("li",[a._v("配置一个定时任务去轮训这个本地事务表，扫描这个本地事务表，把没有发送出去的消息，发送给库存服务，当库存服务收到消息后，会进行减库存，并写入服务器的事务表，更新事务表的状态。")]),a._v(" "),_("li",[a._v("库存服务器通过定时任务或直接通知订单服务，订单服务在本地消息表更新状态。")])]),a._v(" "),_("p",[a._v("这里须注意的是，对于一些扫描发送未成功的任务，会进行重新发送，所以必须保证接口的幂等性。")]),a._v(" "),_("p",[a._v("本地消息队列是BASE理论，是最终一致性模型，适用对一致性要求不高的情况。")]),a._v(" "),_("h4",{attrs:{id:"_4、mq-事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、mq-事务"}},[a._v("#")]),a._v(" 4、MQ 事务")]),a._v(" "),_("p",[a._v("RocketMq在4.3版本已经正式宣布支持分布式事务。RocketMQ中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了MQ内部。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588ae2844970~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"image",loading:"lazy"}})]),a._v(" "),_("p",[a._v("MQ事务是对本地消息表的一层封装，将本地消息表移动到了MQ内部，所以也是基于BASE理论，是最终一致性模式，对强一致性要求不那么高的事务适用，同时MQ事务将整个流程异步化了，也非常适合在高并发情况下使用。")]),a._v(" "),_("p",[a._v("参考：")]),a._v(" "),_("p",[a._v("https://juejin.cn/post/6844903936718012430")]),a._v(" "),_("h2",{attrs:{id:"分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[a._v("#")]),a._v(" 分布式锁")]),a._v(" "),_("p",[a._v("https://www.cnblogs.com/crazymakercircle/p/14504520.html")])])}),[],!1,null,null,null);t.default=v.exports}}]);