(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{696:function(a,t,s){"use strict";s.r(t);var n=s(1),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"abstractqueuedsynchronizer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#abstractqueuedsynchronizer"}},[a._v("#")]),a._v(" AbstractQueuedSynchronizer")]),a._v(" "),s("p",[a._v("重入锁(ReentrantLock) 和信号量(Semaphore)是两个极其重要的并发控制工具。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70760cab928a4d7a9af46c5513421c45~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"img",loading:"lazy"}})]),a._v(" "),s("p",[a._v("可以看到， 重入锁和信号量都在自己内部，实现了一个 AbstractQueuedSynchronizer 的子类，子类的名字都是 Sync。而这个 Sync 类，也正是重入锁和信号量的核心实现。子类 Sync 中的代码也比较少，其核心算法都由 AbstractQueuedSynchronizer 提供。因此，可以说，只要大家了解了AbstractQueuedSynchronizer，就清楚得知道重入锁和信号量的实现原理了。")]),a._v(" "),s("h2",{attrs:{id:"aqs-对资源的共享方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aqs-对资源的共享方式"}},[a._v("#")]),a._v(" AQS 对资源的共享方式")]),a._v(" "),s("ul",[s("li",[s("h5",{attrs:{id:"exclusive-独占"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#exclusive-独占"}},[a._v("#")]),a._v(" Exclusive（独占）")])])]),a._v(" "),s("p",[a._v("只有一个线程能执行，如 ReentantLock，具体看 ReentrantLock。")]),a._v(" "),s("ul",[s("li",[s("h5",{attrs:{id:"share-共享"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#share-共享"}},[a._v("#")]),a._v(" Share （共享）")])])]),a._v(" "),s("p",[a._v("多个线程可同时执行，如 "),s("code",[a._v("Semaphore/CountDownLatch")]),a._v("。"),s("code",[a._v("Semaphore")]),a._v("、"),s("code",[a._v("CountDownLatch")]),a._v("、 "),s("code",[a._v("CyclicBarrier")]),a._v("、"),s("code",[a._v("ReadWriteLock")]),a._v("。")]),a._v(" "),s("h2",{attrs:{id:"前置知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前置知识"}},[a._v("#")]),a._v(" 前置知识")]),a._v(" "),s("h4",{attrs:{id:"基于许可的多线程控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于许可的多线程控制"}},[a._v("#")]),a._v(" 基于许可的多线程控制")]),a._v(" "),s("p",[a._v("为了控制多个线程访问共享资源 ，我们需要为每个访问共享区间的线程派发一个许可。拿到一个许可的线程才能进入共享区间活动。当线程完成工作后，离开共享区间时，必须要归还许可，以确保后续的线程可以正常取得许可。如果许可用完了，那么线程进入共享区间时，就必须等待，这就是控制多线程并行的基本思想。")]),a._v(" "),s("h4",{attrs:{id:"排他锁和共享锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排他锁和共享锁"}},[a._v("#")]),a._v(" 排他锁和共享锁")]),a._v(" "),s("p",[a._v("第二个重要的概念就是排他锁(exclusive)和共享锁(shared)。顾名思义，在排他模式上，只有一个线程可以访问共享变量，而共享模式则允许多个线程同时访问。简单地说，重入锁是排他的；信号量是共享的。")]),a._v(" "),s("p",[a._v("用摩天轮的话来说，排他锁就是虽然我这里有20个位置，但是小朋友也只能一个一个上哦，多出来的位置怎么办呢，可以空着，也可以让摩天轮上唯一的小孩换着做，他想坐哪儿就坐哪儿，1分钟换个位置，都没有关系。而共享锁，就是玩耍摩天轮正常的打开方式了。")]),a._v(" "),s("h4",{attrs:{id:"locksupport"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#locksupport"}},[a._v("#")]),a._v(" LockSupport")]),a._v(" "),s("p",[a._v("LockSupport 可以理解为一个工具类。它的作用很简单，就是挂起和继续执行线程。它的常用的 API 如下：")]),a._v(" "),s("ul",[s("li",[a._v("public static void park() : 如果没有可用许可，则挂起当前线程。"),s("em",[a._v("注意：unpark 和 线程中断都可唤醒 park")]),a._v("。")]),a._v(" "),s("li",[a._v("public static void unpark(Thread thread)：给 thread 一个可用的许可，让它得以继续执行")])]),a._v(" "),s("p",[a._v("因为单词 park 的意思就是停车，因此这里 park() 函数就表示让线程暂停。反之，unpark() 则表示让线程继续执行。")]),a._v(" "),s("p",[a._v("需要注意的是，LockSupport本身也是基于许可的实现，如何理解这句话呢，请看下面的代码：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LockSupport")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("unpark")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LockSupport")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("park")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("大家可以猜一下，park() 之后，当前线程是停止，还是可以继续执行呢？")]),a._v(" "),s("p",[a._v("答案是：可以继续执行。那是因为在 park() 之前，先执行了 unpark()，进而释放了一个许可，也就是说当前线程有一个可用的许可。而 park() 在有可用许可的情况下，是不会阻塞线程的。")]),a._v(" "),s("p",[a._v("综上所述，park() 和 unpark() 的执行效果和它调用的先后顺序没有关系。这一点相当重要，因为在一个多线程的环境中，我们往往很难保证函数调用的先后顺序(都在不同的线程中并发执行)，因此，这种基于许可的做法能够最大限度保证程序不出错。")]),a._v(" "),s("p",[a._v("与 park() 和 unpark() 相比， 一个典型的反面教材就是 Thread.resume() 和 Thread.suspend()。")]),a._v(" "),s("p",[a._v("看下面的代码：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("resume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 挂起的线程执行")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("suspend")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 挂起线程")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("首先让线程继续执行，接着在挂起线程。这个写法和上面的park()的示例非常接近，但是运行结果却是截然不同的。在这里，当前线程就是卡死。")]),a._v(" "),s("p",[a._v("因此，使用park()和unpark()才是我们的首选。而在AbstractQueuedSynchronizer中，也正是使用了LockSupport的park()和unpark()操作来控制线程的运行状态的。")]),a._v(" "),s("h4",{attrs:{id:"原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),s("p",[a._v("LockSupport 就是通过控制变量 _counter 来对线程阻塞唤醒进行控制的。原理有点类似于信号量机制。")]),a._v(" "),s("blockquote",[s("p",[a._v("当调用park()方法时，会将_counter置为0，同时判断前值，等于1说明前面被unpark过,则直接退出，否则将使该线程阻塞。")]),a._v(" "),s("p",[a._v("当调用unpark()方法时，会将_counter置为1，同时判断前值，等于0会进行线程唤醒，否则直接退出。")])]),a._v(" "),s("p",[a._v("当先调用两次unpark()之后，那么"),s("code",[a._v("_counter")]),a._v(" 值还是1，然后第一次调用"),s("code",[a._v("park()")]),a._v("，将"),s("code",[a._v("_counter")]),a._v("置为0，同时前值等于1,所以直接退出了，但是在第二次"),s("code",[a._v("park()")]),a._v("的时候，"),s("code",[a._v("_count")]),a._v("值是0，所以此时直接被阻塞了。")])])}),[],!1,null,null,null);t.default=r.exports}}]);