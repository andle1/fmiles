(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{665:function(v,_,t){"use strict";t.r(_);var a=t(1),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"bio-nio-aio-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bio-nio-aio-区别"}},[v._v("#")]),v._v(" BIO，NIO，AIO 区别")]),v._v(" "),t("p",[v._v("UNIX 系统下，IO模型有 "),t("strong",[v._v("同步阻塞 I/O")]),v._v("、"),t("strong",[v._v("同步非阻塞 I/O")]),v._v("、"),t("strong",[v._v("I/O 多路复用")]),v._v("、**异步 I/O **这几种。")]),v._v(" "),t("p",[v._v("首先说BIO，在linux中的Java进程中，默认情况下所有的 socket 都是 blocking IO。在阻塞式 I/O 模型中，应用程序在从 IO 系统调用开始，一直到到系统调用返回，这段时间是阻塞的。返回成功后，应用进程开始处理用户空间的缓存数据。BIO 优先就是简单，用户线程不占用 CPU，但是缺点也很明显，在高并发场景下是不可用的。")]),v._v(" "),t("p",[v._v("接着说NIO，NIO 模型中应用程序在一旦开始 IO 系统调用，会出现以下两种情况：")]),v._v(" "),t("p",[v._v("（1）在内核缓冲区没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。")]),v._v(" "),t("p",[v._v("（2）在内核缓冲区有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。")]),v._v(" "),t("p",[v._v("它的特点就是应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止。")]),v._v(" "),t("p",[v._v("NIO 优点就是用户线程不会阻塞，实时性较好，缺点需要不断的重复发起IO系统调用，这种不断的轮询，将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低。和 BIO 一样在高并发下不咋地。")]),v._v(" "),t("p",[v._v("IO 多路复用：通过一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核能够通知程序进行相应的 IO 系统调用。已这种通知的方式，优势是能处理更多的链接。通过一次 select/epoll 系统调用，就查询到到可以读写的一个甚至是成百上千的网络连接。")]),v._v(" "),t("p",[v._v("零拷贝")]),v._v(" "),t("h4",{attrs:{id:"_2、反射底层原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、反射底层原理"}},[v._v("#")]),v._v(" 2、反射底层原理")]),v._v(" "),t("p",[v._v("反射的定义就是对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。")]),v._v(" "),t("p",[v._v("从使用开始说，平时我们使用反射都是")]),v._v(" "),t("p",[v._v("Method method = XXX.class.getDeclaredMethod(xx,xx);")]),v._v(" "),t("p",[v._v("method.invoke(target,params)。")]),v._v(" "),t("p",[v._v("首先介绍这个根据方法名获取方法的方法，底层主要的是使用了reflectionData 这个数据结构，保存了从 JVM 里获取的一些类的属性和方法等，通过这个方法返回了封装在 Method 类中的关于方法的信息。在获取到 Method 后，并不是直接 返回，而是 copy了一份。")]),v._v(" "),t("p",[v._v("Method 类中最主要的信息是两个字段：root 和 MethodAccessor  和一个方法：invoke。root 主要指向缓存中的 Method 对象，也就是当前这个 Method 对象其实是根据 root 这个 Method 构建出来的，原因是在上面步骤的获取到 Method 之后，并不会直接返回，而是调用 copy() 方法复制一个 Metohd 对象，每个复制的 Method 对象的 root 都指向这个 Method。")]),v._v(" "),t("p",[v._v("另外一个 MethodAccessor，本身只是一个接口，内部只有一个 invoke 方法，而 Method 类中的 invoke 方法正是调用 MethodAccessor 中的这个 invoke 方法；其主要的实现类有三个，")]),v._v(" "),t("ul",[t("li",[v._v("DelegatingMethodAccessorImpl")]),v._v(" "),t("li",[v._v("NativeMethodAccessorImpl")]),v._v(" "),t("li",[v._v("GeneratedMethodAccessorXXX")])]),v._v(" "),t("p",[v._v("NativeMethodAccessorImpl 主要是 Native 实现的，而"),t("code",[v._v("GeneratedMethodAccessorXXX")]),v._v("是为每个需要反射调用的"),t("code",[v._v("Method")]),v._v("动态生成的类，DelegatingMethodAccessorImpl 就是给这两个类做代理的，在调用 15 次 invoke 方法之前都是调用 NativeMethodAccessorImpl。原因也是因为 native 的效率高。")]),v._v(" "),t("h6",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[v._v("#")]),v._v(" 优缺点：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("优点：")]),v._v(" 运行期类型的判断，动态加载类，提高代码灵活度。")]),v._v(" "),t("li",[t("strong",[v._v("缺点：")]),v._v(" 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。")])]),v._v(" "),t("h4",{attrs:{id:"_3、动态代理底层原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、动态代理底层原理"}},[v._v("#")]),v._v(" 3、动态代理底层原理")]),v._v(" "),t("p",[v._v("从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。动态代理分为 Jdk 动态代理和 Cglib 动态代理。")]),v._v(" "),t("p",[v._v("从使用角度来说，要实现动态代理的话，我们需要定义个代理类需要实现 InvocationHandler，然后重写其中的 Invoke 方法来自定义处理的逻辑；")]),v._v(" "),t("p",[v._v("然后需要调用 Proxy.newProxyInstance 方法，这个方法一共有 3 个参数：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("loader")]),v._v(" :类加载器，用于加载代理对象。")]),v._v(" "),t("li",[t("strong",[v._v("interfaces")]),v._v(" : 代理类实现的一些接口；")]),v._v(" "),t("li",[t("strong",[v._v("h")]),v._v(" : 实现了 "),t("code",[v._v("InvocationHandler")]),v._v(" 接口的对象；")])]),v._v(" "),t("p",[v._v("其中最重要的就是 h。 JVM 会在运行调用 newProxyInstance 动态生成一个代理类，这个类的构造函数参数就是传入的 h，并且 $Proxy0 即动态生成的代理类是继承自 Proxy。")]),v._v(" "),t("p",[v._v("在动态代理类的构造函数中，调用了 super(h)；这时候把实现了 InvocationHandler 接口的对象又传给父类 Proxy，并且赋值给 Proxy 的字段  h;")]),v._v(" "),t("p",[v._v("接着调用被代理类方法的时候，就会调用 super.h.invoke()，即 Proxy 类的 h，即调用了代理类的 invoke 方法。")]),v._v(" "),t("p",[v._v("本质来说，动态代理的底层就是反射。")]),v._v(" "),t("h5",{attrs:{id:"_2、java-中的几种基本数据类型是什么-对应的包装类型是什么-各自占用多少字节呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、java-中的几种基本数据类型是什么-对应的包装类型是什么-各自占用多少字节呢"}},[v._v("#")]),v._v(" 2、Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？")]),v._v(" "),t("p",[v._v("​    注意boolen，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，（因此）每个boolean元素占8位。")]),v._v(" "),t("p",[v._v("可以得知：boolean类型的数据如果单独使用，占4个字节的空间，而如果存储到boolean数组中，每个元素又只占1个字节。")]),v._v(" "),t("h5",{attrs:{id:"_3、string-、-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、string-、-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"}},[v._v("#")]),v._v(" 3、"),t("code",[v._v("String")]),v._v(" "),t("code",[v._v("、 StringBuffer")]),v._v(" 和 "),t("code",[v._v("StringBuilder")]),v._v(" 的区别是什么? "),t("code",[v._v("String")]),v._v(" 为什么是不可变的?")]),v._v(" "),t("p",[v._v("​            "),t("code",[v._v("String")]),v._v(" 类中使用 final 关键字修饰字符数组来保存字符串，"),t("code",[v._v("private final char value[]")]),v._v("，所以"),t("code",[v._v("String")]),v._v(" 对象是不可变的。在 Java 9 之后，String 、"),t("code",[v._v("StringBuilder")]),v._v(" 与 "),t("code",[v._v("StringBuffer")]),v._v(" 的实现改用 byte 数组存储字符串 "),t("code",[v._v("private final byte[] value")])]),v._v(" "),t("h5",{attrs:{id:"_4、深拷贝和浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、深拷贝和浅拷贝"}},[v._v("#")]),v._v(" 4、深拷贝和浅拷贝")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("浅拷贝")]),v._v("：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。")]),v._v(" "),t("li",[t("strong",[v._v("深拷贝")]),v._v("：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。")])]),v._v(" "),t("h5",{attrs:{id:"_5、java-反射-反射有什么缺点-你是怎么理解反射的-为什么框架需要反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、java-反射-反射有什么缺点-你是怎么理解反射的-为什么框架需要反射"}},[v._v("#")]),v._v(" 5、Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？")]),v._v(" "),t("p",[v._v("​\t\tJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。")]),v._v(" "),t("ul",[t("li")]),v._v(" "),t("h6",{attrs:{id:"_2、为什么框架需要反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、为什么框架需要反射"}},[v._v("#")]),v._v(" 2、为什么框架需要反射")]),v._v(" "),t("p",[v._v("框架用反射会易于扩展，譬如修改配置文件。又譬如 Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系。")]),v._v(" "),t("h6",{attrs:{id:"_3、获取class对象的四种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、获取class对象的四种方式"}},[v._v("#")]),v._v(" 3、获取Class对象的四种方式？")]),v._v(" "),t("blockquote",[t("p",[v._v("1、.Class")]),v._v(" "),t("p",[v._v("2、forName 方法")]),v._v(" "),t("p",[v._v("3、.getClass() 方法")]),v._v(" "),t("p",[v._v("4、ClassLoader.LoadClass()")])]),v._v(" "),t("h5",{attrs:{id:"_6、java-泛型了解么-什么是类型擦除-介绍一下常用的通配符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、java-泛型了解么-什么是类型擦除-介绍一下常用的通配符"}},[v._v("#")]),v._v(" 6、Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？")]),v._v(" "),t("p",[v._v("简单来说就是在创建对象或调用方法的时候明确具体的类型。")]),v._v(" "),t("p",[v._v("好处就是代码更加简洁（不需要强制转换），程序更加健壮（编译期不出错，运行期就不会出现ClassCastException）。")]),v._v(" "),t("h6",{attrs:{id:"_1、什么是类型擦除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是类型擦除"}},[v._v("#")]),v._v(" 1、什么是类型擦除")]),v._v(" "),t("p",[v._v("​\t\tJava 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。如在代码中定义"),t("code",[v._v("List<Object>")]),v._v("和"),t("code",[v._v("List<String>")]),v._v("等类型，在编译后都会变成"),t("code",[v._v("List")]),v._v("，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。")]),v._v(" "),t("h6",{attrs:{id:"_2、通配符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、通配符"}},[v._v("#")]),v._v(" 2、通配符")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("？ 表示不确定的 java 类型")]),v._v(" "),t("li",[v._v("T (type) 表示具体的一个 java 类型")]),v._v(" "),t("li",[v._v("K V (key value) 分别代表 java 键值中的 Key Value")]),v._v(" "),t("li",[v._v("E (element) 代表 Element")])])]),v._v(" "),t("h5",{attrs:{id:"_7、内部类和匿名内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、内部类和匿名内部类"}},[v._v("#")]),v._v(" 7、内部类和匿名内部类？")]),v._v(" "),t("p",[v._v("内部类即一个方法的内部类。")]),v._v(" "),t("p",[v._v("匿名内部类：匿名内部类不能有构造方法。 匿名内部类不能定义任何静态成员、方法和类。 只能创建匿名内部类的一个实例。")])])}),[],!1,null,null,null);_.default=e.exports}}]);