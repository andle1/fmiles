(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{667:function(a,t,r){"use strict";r.r(t);var e=r(1),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"cas"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[a._v("#")]),a._v(" CAS")]),a._v(" "),r("h2",{attrs:{id:"cas-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cas-2"}},[a._v("#")]),a._v(" CAS")]),a._v(" "),r("h4",{attrs:{id:"什么是-cas"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是-cas"}},[a._v("#")]),a._v(" 什么是 CAS ？")]),a._v(" "),r("h4",{attrs:{id:"为什么要用-cas"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用-cas"}},[a._v("#")]),a._v(" 为什么要用 CAS？")]),a._v(" "),r("h4",{attrs:{id:"cas-存在什么问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cas-存在什么问题"}},[a._v("#")]),a._v(" CAS 存在什么问题？")]),a._v(" "),r("h4",{attrs:{id:"cas-的运用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cas-的运用"}},[a._v("#")]),a._v(" CAS 的运用？")]),a._v(" "),r("p",[a._v("主要就是 JUC 包下的实现类。")]),a._v(" "),r("h4",{attrs:{id:"atomaticintiger-类怎么保证线程安全的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#atomaticintiger-类怎么保证线程安全的"}},[a._v("#")]),a._v(" AtomaticIntiger 类怎么保证线程安全的？")]),a._v(" "),r("h2",{attrs:{id:"aba"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aba"}},[a._v("#")]),a._v(" ABA")]),a._v(" "),r("h4",{attrs:{id:"aba-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aba-是什么"}},[a._v("#")]),a._v(" ABA 是什么？")]),a._v(" "),r("h4",{attrs:{id:"怎么解决-aba-问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#怎么解决-aba-问题"}},[a._v("#")]),a._v(" 怎么解决 ABA 问题？")]),a._v(" "),r("p",[a._v("https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247483977&idx=1&sn=1a3aa3aec27073aa3b422bc41d7fbe2d&chksm=fdf0ea16ca8763005aff64834eeb7bef08bf4ee2d8febb7e8d4d8e5d1542336e13fac71e2881&cur_album_id=1657204970858872832&scene=21#wechat_redirect")]),a._v(" "),r("h2",{attrs:{id:"longaddr"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#longaddr"}},[a._v("#")]),a._v(" LongAddr")]),a._v(" "),r("h4",{attrs:{id:"longaddr-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#longaddr-是什么"}},[a._v("#")]),a._v(" LongAddr 是什么？")]),a._v(" "),r("h4",{attrs:{id:"longaddr-的原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#longaddr-的原理"}},[a._v("#")]),a._v(" LongAddr 的原理？")]),a._v(" "),r("h1",{attrs:{id:"unsafe"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unsafe"}},[a._v("#")]),a._v(" unsafe")]),a._v(" "),r("h4",{attrs:{id:"unsafe是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unsafe是什么"}},[a._v("#")]),a._v(" Unsafe是什么？")]),a._v(" "),r("p",[a._v("Java 无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个类 Unsafe，底层是使用C/C++写的，它提供了硬件级别的原子操作。Unsafe为我们提供了访问底层的机制，这种机制仅供java核心类库使用，而不应该被普通用户使用。")]),a._v(" "),r("h4",{attrs:{id:"unsafe-作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unsafe-作用"}},[a._v("#")]),a._v(" Unsafe 作用？")]),a._v(" "),r("ul",[r("li",[a._v("操纵对象属性")]),a._v(" "),r("li",[a._v("操纵数组元素")]),a._v(" "),r("li",[a._v("线程挂起与恢复、CAS")])]),a._v(" "),r("h4",{attrs:{id:"unsafe为什么是不安全的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unsafe为什么是不安全的"}},[a._v("#")]),a._v(" Unsafe为什么是不安全的？")]),a._v(" "),r("h4",{attrs:{id:"unsafe的实例怎么获取"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unsafe的实例怎么获取"}},[a._v("#")]),a._v(" Unsafe的实例怎么获取？")]),a._v(" "),r("h4",{attrs:{id:"unsafe的阻塞-唤醒操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unsafe的阻塞-唤醒操作"}},[a._v("#")]),a._v(" Unsafe的阻塞/唤醒操作？")]),a._v(" "),r("p",[a._v("LockSupport类中的park与unpark方法对unsafe中的park与unpark方法做了封装，LockSupport类中有各种版本park方法，但最终都调用了Unsafe.park()方法。")]),a._v(" "),r("p",[a._v("https://blog.csdn.net/qq_21903759/article/details/105914506")]),a._v(" "),r("h1",{attrs:{id:"aqs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[a._v("#")]),a._v(" AQS")]),a._v(" "),r("h4",{attrs:{id:"何为-aqs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#何为-aqs"}},[a._v("#")]),a._v(" 何为 AQS？")]),a._v(" "),r("p",[r("strong",[a._v("AQS 是一个用于构建锁、同步器等线程协作工具类的框架")]),a._v("，简单说就是 AQS 定义了模板，具体实现由各个子类完成。")]),a._v(" "),r("p",[a._v("https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&mid=2247484035&idx=1&sn=ccaec352e192f1fd40020d9a984e9461&chksm=fdf0eadcca8763ca5c44bd19118fd00e843c163deb40cda444b3fc08430c57760db15eca1ea6&scene=178&cur_album_id=1657204970858872832#rd")]),a._v(" "),r("h4",{attrs:{id:"aqs原理-执行过程源码-入队出队的细节-源码细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aqs原理-执行过程源码-入队出队的细节-源码细节"}},[a._v("#")]),a._v(" AQS原理（执行过程源码，入队出队的细节，源码细节)")]),a._v(" "),r("p",[a._v("先讲 AQS 的四个字段，state，head，tail，独占的线程；")]),a._v(" "),r("p",[a._v("接着讲 Node 结构，waitstatus，thread，prev，next，nextWaiter；")]),a._v(" "),r("p",[a._v("ReentantLock 的 Lock 源码：1、尝试获取锁；2、获取锁失败入队；3、线程是否需要挂起；4、selfInterrupet()")]),a._v(" "),r("p",[a._v("unLock 源码：1、尝试解锁；2、唤醒后续节点。注意这里是唤醒，而真正处理 是在 Lock 的第三步。")]),a._v(" "),r("h4",{attrs:{id:"countdownlatch-怎么用-应用场景是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch-怎么用-应用场景是什么"}},[a._v("#")]),a._v(" CountDownLatch 怎么用？应用场景是什么？")]),a._v(" "),r("h5",{attrs:{id:"countdownlatch-两种应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch-两种应用场景"}},[a._v("#")]),a._v(" CountDownLatch 两种应用场景")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("线程执行完了等待其他线程执行完")]),a._v("。假设我们有 N ( N > 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。")]),a._v(" "),r("li",[a._v("**多个线程开始执行任务的最大并行性。**类似于赛跑，让线程都同时等待直到所有线程准备好，然后同时唤醒所有线程。")])]),a._v(" "),r("h5",{attrs:{id:"cyclicbarrier-的应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier-的应用场景"}},[a._v("#")]),a._v(" CyclicBarrier 的应用场景")]),a._v(" "),r("p",[r("code",[a._v("CyclicBarrier")]),a._v(" 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。")]),a._v(" "),r("h4",{attrs:{id:"countdownlatch-和-cyclicbarrier-的不同之处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch-和-cyclicbarrier-的不同之处"}},[a._v("#")]),a._v(" CountDownLatch 和 CyclicBarrier 的不同之处？")]),a._v(" "),r("p",[r("code",[a._v("CountDownLatch")]),a._v(" 是计数器，只能使用一次，而 "),r("code",[a._v("CyclicBarrier")]),a._v(" 的计数器提供 "),r("code",[a._v("reset")]),a._v(" 功能，可以多次使用。对于 "),r("code",[a._v("CountDownLatch")]),a._v(" 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 "),r("code",[a._v("CyclicBarrier")]),a._v("，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。")]),a._v(" "),r("p",[r("code",[a._v("CountDownLatch")]),a._v(" 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 "),r("code",[a._v("CyclicBarrier")]),a._v(" 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。")]),a._v(" "),r("h5",{attrs:{id:"源码层面的不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码层面的不同"}},[a._v("#")]),a._v(" 源码层面的不同：")]),a._v(" "),r("h1",{attrs:{id:"synchronized"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[a._v("#")]),a._v(" Synchronized")]),a._v(" "),r("h2",{attrs:{id:"为什么有synchronized"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么有synchronized"}},[a._v("#")]),a._v(" 为什么有Synchronized")]),a._v(" "),r("h4",{attrs:{id:"_1、为什么需要-synchronized-什么场景下使用-synchronized"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、为什么需要-synchronized-什么场景下使用-synchronized"}},[a._v("#")]),a._v(" 1、为什么需要 synchronized？什么场景下使用 synchronized？")]),a._v(" "),r("h2",{attrs:{id:"synchronized-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-是什么"}},[a._v("#")]),a._v(" Synchronized 是什么")]),a._v(" "),r("h4",{attrs:{id:"_1、-synchronized-这三种加锁方式-作用对象-静态方法、非静态方法、代码块-作用范围的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、-synchronized-这三种加锁方式-作用对象-静态方法、非静态方法、代码块-作用范围的区别"}},[a._v("#")]),a._v(" 1、 synchronized 这三种加锁方式（作用对象：静态方法、非静态方法、代码块）作用范围的区别?")]),a._v(" "),r("h4",{attrs:{id:"_2、synchronized修饰的方法在抛出异常时-会释放锁吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、synchronized修饰的方法在抛出异常时-会释放锁吗"}},[a._v("#")]),a._v(" 2、Synchronized修饰的方法在抛出异常时,会释放锁吗?")]),a._v(" "),r("h4",{attrs:{id:"_3、synchronized-是公平锁还是非公平锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、synchronized-是公平锁还是非公平锁"}},[a._v("#")]),a._v(" 3、synchronized 是公平锁还是非公平锁？")]),a._v(" "),r("h2",{attrs:{id:"synchronized-怎么实现的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-怎么实现的"}},[a._v("#")]),a._v(" Synchronized 怎么实现的")]),a._v(" "),r("h4",{attrs:{id:"_1、synchronized-底层源码如何实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、synchronized-底层源码如何实现"}},[a._v("#")]),a._v(" 1、synchronized 底层源码如何实现？")]),a._v(" "),r("h4",{attrs:{id:"_2、synchronized-本质上是通过什么保证线程安全的-分三个方面回答-加锁和释放锁的原理-保证可见性原理。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、synchronized-本质上是通过什么保证线程安全的-分三个方面回答-加锁和释放锁的原理-保证可见性原理。"}},[a._v("#")]),a._v(" 2、synchronized 本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，保证可见性原理。")]),a._v(" "),r("h5",{attrs:{id:"追问1-为什么-monitorexit-指令出现了两次"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问1-为什么-monitorexit-指令出现了两次"}},[a._v("#")]),a._v(" 追问1：为什么 monitorexit 指令出现了两次？")]),a._v(" "),r("h5",{attrs:{id:"追问2-可重入原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问2-可重入原理"}},[a._v("#")]),a._v(" 追问2：可重入原理？")]),a._v(" "),r("p",[a._v("status,线程ID")]),a._v(" "),r("h5",{attrs:{id:"追问3-在并发时-程序的执行可能会出现乱序-直观感觉前面的代码-会在后面执行-为什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问3-在并发时-程序的执行可能会出现乱序-直观感觉前面的代码-会在后面执行-为什么"}},[a._v("#")]),a._v(" 追问3：在并发时，程序的执行可能会出现乱序，直观感觉前面的代码，会在后面执行，为什么？")]),a._v(" "),r("h4",{attrs:{id:"_3、那你分别跟我讲讲-jdk-6-以前-synchronized-为什么这么重"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、那你分别跟我讲讲-jdk-6-以前-synchronized-为什么这么重"}},[a._v("#")]),a._v(" 3、那你分别跟我讲讲 JDK 6 以前 synchronized 为什么这么重？")]),a._v(" "),r("h4",{attrs:{id:"_4、jdk-6-之后-synchronized-做了优化-跟我讲讲-什么是jvm里的偏斜锁、轻量级锁、重量级锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、jdk-6-之后-synchronized-做了优化-跟我讲讲-什么是jvm里的偏斜锁、轻量级锁、重量级锁"}},[a._v("#")]),a._v(" 4、JDK 6 之后 synchronized 做了优化，跟我讲讲？ 什么是JVM里的偏斜锁、轻量级锁、重量级锁?")]),a._v(" "),r("h5",{attrs:{id:"追问1-你知道-自旋锁-是做什么的吗-它的使用场景是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问1-你知道-自旋锁-是做什么的吗-它的使用场景是什么"}},[a._v("#")]),a._v(" 追问1：你知道“自旋锁”是做什么的吗？它的使用场景是什么？")]),a._v(" "),r("h4",{attrs:{id:"_5、什么是锁的升级、降级"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、什么是锁的升级、降级"}},[a._v("#")]),a._v(" 5、什么是锁的升级、降级？")]),a._v(" "),r("h5",{attrs:{id:"追问1-轻量级锁的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问1-轻量级锁的实现"}},[a._v("#")]),a._v(" 追问1：轻量级锁的实现")]),a._v(" "),r("h2",{attrs:{id:"synchronized-使用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-使用"}},[a._v("#")]),a._v(" Synchronized 使用")]),a._v(" "),r("h4",{attrs:{id:"_1、如何提高synchronized并发性能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、如何提高synchronized并发性能"}},[a._v("#")]),a._v(" 1、如何提高Synchronized并发性能？")]),a._v(" "),r("h4",{attrs:{id:"_2、使用synchronized关键字需要注意什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、使用synchronized关键字需要注意什么"}},[a._v("#")]),a._v(" 2、使用Synchronized关键字需要注意什么？")]),a._v(" "),r("h2",{attrs:{id:"synchronized-延申"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-延申"}},[a._v("#")]),a._v(" Synchronized 延申")]),a._v(" "),r("h4",{attrs:{id:"_1、-synchronized由什么样的缺陷"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、-synchronized由什么样的缺陷"}},[a._v("#")]),a._v(" 1、 Synchronized由什么样的缺陷?")]),a._v(" "),r("h4",{attrs:{id:"_2、java-lock怎么弥补这些缺陷的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、java-lock怎么弥补这些缺陷的"}},[a._v("#")]),a._v(" 2、Java Lock怎么弥补这些缺陷的？")]),a._v(" "),r("h4",{attrs:{id:"追问1-synchronized和lock的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问1-synchronized和lock的区别"}},[a._v("#")]),a._v(" 追问1：Synchronized和lock的区别")]),a._v(" "),r("h4",{attrs:{id:"_3、synchronized和reentrantlock有什么区别呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、synchronized和reentrantlock有什么区别呢"}},[a._v("#")]),a._v(" 3、synchronized和ReentrantLock有什么区别呢?")]),a._v(" "),r("p",[a._v("https://blog.csdn.net/heavendan/article/details/120776181")]),a._v(" "),r("h1",{attrs:{id:"volatile"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[a._v("#")]),a._v(" Volatile")]),a._v(" "),r("h2",{attrs:{id:"volatile-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#volatile-2"}},[a._v("#")]),a._v(" volatile")]),a._v(" "),r("h4",{attrs:{id:"为什么有-volaitle-或者-volaitle-作用是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么有-volaitle-或者-volaitle-作用是什么"}},[a._v("#")]),a._v(" 为什么有 volaitle？或者 volaitle 作用是什么？")]),a._v(" "),r("p",[a._v("多线程环境下，一个共享变量可能存在于多个位置，如主内存、多个本地内存，可能带来数据不一致的问题。不一致有两方面原因，可见性和有序性：")]),a._v(" "),r("p",[a._v("可见性：一个线程对主内存数据进行了修改，而另外一个线程不知道，导致共享变量值不一样。")]),a._v(" "),r("p",[a._v("有序性：多线程交替执行，由于编译器优化重排的存在，变量无法保证一致性。")]),a._v(" "),r("p",[a._v("volatile 就是为了解决这两个问题：")]),a._v(" "),r("p",[a._v("可见性是使用 lock 前缀实现，lock 前缀可实现嗅探机制，每个处理器都会有一个嗅探机制，去看自己的工作内存中的数值与主内存中那个的是否一致，不一致，会将自己的工作内存中的数值设置成无效，同时会从主内存中读取数值更新到自己的工作内存中。")]),a._v(" "),r("p",[a._v("有序性是通过内存屏障，禁止指令重排，内存屏障还可以强制刷出各种 CPU 的缓存数据保证可见性。")]),a._v(" "),r("h5",{attrs:{id:"追问-volatile能保证原子性吗-为什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问-volatile能保证原子性吗-为什么"}},[a._v("#")]),a._v(" 追问：volatile能保证原子性吗？为什么？")]),a._v(" "),r("p",[a._v("不能完全保证，只能保证单次的读/写操作具有原子性。比如，i++，这是是一个复合操作。")]),a._v(" "),r("h5",{attrs:{id:"追问2-volatile-是否用的越多越好-或者总线风暴是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#追问2-volatile-是否用的越多越好-或者总线风暴是什么"}},[a._v("#")]),a._v(" 追问2：volatile 是否用的越多越好？或者总线风暴是什么？")]),a._v(" "),r("p",[a._v("不是，可能导致总线风暴。 由于 Volatile 的 MESI 缓存一致性协议，需、要不断从主内存嗅探和 CAS 循环，无效交互会导致总线带宽达到峰值，所以不要大量使用 Volatile。")]),a._v(" "),r("h3",{attrs:{id:"一、有序性相关问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、有序性相关问题"}},[a._v("#")]),a._v(" 一、有序性相关问题")]),a._v(" "),r("h4",{attrs:{id:"什么是指令重排"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是指令重排"}},[a._v("#")]),a._v(" 什么是指令重排？")]),a._v(" "),r("p",[a._v("为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。")]),a._v(" "),r("p",[a._v("重排序一般可分为三种：")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;")])]),a._v(" "),r("li",[r("p",[a._v("指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;")])]),a._v(" "),r("li",[r("p",[a._v("内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。")])])]),a._v(" "),r("h4",{attrs:{id:"as-if-serial-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#as-if-serial-是什么"}},[a._v("#")]),a._v(" as-if-serial 是什么？")]),a._v(" "),r("p",[a._v("不管怎么重排序，单线程下的执行结果不能被改变。")]),a._v(" "),r("h4",{attrs:{id:"volitile-的读写内存屏障-或者是有序性是什么实现的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#volitile-的读写内存屏障-或者是有序性是什么实现的"}},[a._v("#")]),a._v(" volitile 的读写内存屏障？或者是有序性是什么实现的")]),a._v(" "),r("h3",{attrs:{id:"二、可见性相关问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、可见性相关问题"}},[a._v("#")]),a._v(" 二、可见性相关问题")]),a._v(" "),r("h4",{attrs:{id:"happens-before-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#happens-before-是什么"}},[a._v("#")]),a._v(" happens-before 是什么？")]),a._v(" "),r("p",[a._v("主要是为了表示操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。")]),a._v(" "),r("h4",{attrs:{id:"lock-前缀的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lock-前缀的作用"}},[a._v("#")]),a._v(" Lock 前缀的作用？")]),a._v(" "),r("h2",{attrs:{id:"jmm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jmm"}},[a._v("#")]),a._v(" JMM")]),a._v(" "),r("h4",{attrs:{id:"jmm-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jmm-是什么"}},[a._v("#")]),a._v(" JMM 是什么？")]),a._v(" "),r("p",[a._v("Java内存模型，是java虚拟机规范中所定义的一种内存模型，目的是为了屏蔽掉了底层不同计算机的区别。")]),a._v(" "),r("h4",{attrs:{id:"jmm-的主要内容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jmm-的主要内容"}},[a._v("#")]),a._v(" JMM 的主要内容？")]),a._v(" "),r("p",[a._v("所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。")]),a._v(" "),r("p",[a._v("每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。")]),a._v(" "),r("p",[r("code",[a._v("线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量")]),a._v("。")]),a._v(" "),r("p",[a._v("不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。")]),a._v(" "),r("h2",{attrs:{id:"内存屏障"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[a._v("#")]),a._v(" 内存屏障")]),a._v(" "),r("h4",{attrs:{id:"内存屏障是什么-或者作用什么-或者怎么保证不会被重排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障是什么-或者作用什么-或者怎么保证不会被重排序"}},[a._v("#")]),a._v(" 内存屏障是什么？或者作用什么？或者怎么保证不会被重排序？")]),a._v(" "),r("p",[a._v("java编译器会在生成指令系列时在适当的位置会插入"),r("code",[a._v("内存屏障")]),a._v("指令来禁止特定类型的处理器重排序。")]),a._v(" "),r("h2",{attrs:{id:"总线机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总线机制"}},[a._v("#")]),a._v(" 总线机制")]),a._v(" "),r("p",[a._v("https://blog.csdn.net/heavendan/article/details/121032734")]),a._v(" "),r("h1",{attrs:{id:"threadlocal"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[a._v("#")]),a._v(" ThreadLocal")]),a._v(" "),r("h4",{attrs:{id:"threadlocal-是什么-原理是什么-存在什么问题-为什么设计成-key-是虚引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-是什么-原理是什么-存在什么问题-为什么设计成-key-是虚引用"}},[a._v("#")]),a._v(" ThreadLocal 是什么？原理是什么？存在什么问题？为什么设计成 key 是虚引用？")]),a._v(" "),r("p",[a._v("背景是变量无法共享，ThreadLocal 创建的变量可以共享。")]),a._v(" "),r("p",[a._v("原理介绍下 Thread 类中 ThreadLocals，主要是 ThreaLcoal 类中的 ThreadLocalMap；")]),a._v(" "),r("p",[a._v("ThreadLocalMap 的底层是   Entry 数组；")]),a._v(" "),r("p",[a._v("Entry 数组 key 是ThreadLocal 本身，value 是存放的值。")]),a._v(" "),r("p",[a._v("存在的问题是内存泄漏，就是 key 为 null，value一致没办法回收。")]),a._v(" "),r("p",[a._v("为什么 key 是虚引用个人觉得的是为了线程复用，设计成 让 ThreadLocal 自动被回收(讲一下内存引用的图的理解)。")]),a._v(" "),r("h4",{attrs:{id:"父子线程怎么共享数据-interitablethreadlocals"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#父子线程怎么共享数据-interitablethreadlocals"}},[a._v("#")]),a._v(" 父子线程怎么共享数据 interitableThreadLocals")]),a._v(" "),r("p",[a._v("就是创建 Thread 类的时候，把父线程 interitableThreadLocals 传给 子线程。")]),a._v(" "),r("h4",{attrs:{id:"线程池的创建形式-使用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程池的创建形式-使用场景"}},[a._v("#")]),a._v(" 线程池的创建形式,使用场景")]),a._v(" "),r("p",[a._v("其实池化思想大多都是为了减少每次获取资源的消耗，提高对资源的利用率。主要的使用场景是用于执行不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可以让多个不相干的任务同时执行。")]),a._v(" "),r("p",[a._v("创建形式一般都是通过 ThreadPoolExecutor。")]),a._v(" "),r("p",[a._v("几个参数：")]),a._v(" "),r("ul",[r("li",[r("strong",[r("code",[a._v("corePoolSize")]),a._v(" :")]),a._v(" 核心线程数线程数定义了最小可以同时运行的线程数量。")]),a._v(" "),r("li",[r("strong",[r("code",[a._v("maximumPoolSize")]),a._v(" :")]),a._v(" 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。")]),a._v(" "),r("li",[r("strong",[r("code",[a._v("workQueue")]),a._v(":")]),a._v(" 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。")])]),a._v(" "),r("p",[r("code",[a._v("ThreadPoolExecutor")]),a._v("其他常见参数 :")]),a._v(" "),r("ol",[r("li",[r("strong",[r("code",[a._v("keepAliveTime")])]),a._v(":当线程池中的线程数量大于 "),r("code",[a._v("corePoolSize")]),a._v(" 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 "),r("code",[a._v("keepAliveTime")]),a._v("才会被回收销毁；")]),a._v(" "),r("li",[r("strong",[r("code",[a._v("unit")])]),a._v(" : "),r("code",[a._v("keepAliveTime")]),a._v(" 参数的时间单位。")]),a._v(" "),r("li",[r("strong",[r("code",[a._v("threadFactory")])]),a._v(" :executor 创建新线程的时候会用到。")]),a._v(" "),r("li",[r("strong",[r("code",[a._v("handler")])]),a._v(" :当达到线程池的最大线程数的拒绝策略。当线程池饱和，继续提交任务，需要一种策略来处理该任务。线程池提供了4种策略：")])]),a._v(" "),r("ul",[r("li",[r("p",[a._v("不干了：")]),a._v(" "),r("ul",[r("li",[a._v("直接抛出异常，这是默认策略；")]),a._v(" "),r("li",[a._v("直接丢弃任务；")])])]),a._v(" "),r("li",[r("p",[a._v("干：")]),a._v(" "),r("ul",[r("li",[a._v("用调用者所在的线程来执行任务；")]),a._v(" "),r("li",[a._v("丢弃阻塞队列中靠最前的任务，并执行当前任务；")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);