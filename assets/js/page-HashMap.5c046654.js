(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{664:function(a,t,s){"use strict";s.r(t);var h=s(1),r=Object(h.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"hashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),s("h2",{attrs:{id:"hash-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash-算法"}},[a._v("#")]),a._v(" Hash 算法")]),a._v(" "),s("h4",{attrs:{id:"hash算法-为什么是-key-hashcode-key-hashcode-16"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash算法-为什么是-key-hashcode-key-hashcode-16"}},[a._v("#")]),a._v(" hash算法 为什么是 key.hashCode() ^(key.hashCode() >>> 16)")]),a._v(" "),s("p",[a._v("https://wenku.baidu.com/view/79197504ac45b307e87101f69e3143323968f5c7.html")]),a._v(" "),s("h2",{attrs:{id:"数组-链表-树问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组-链表-树问题"}},[a._v("#")]),a._v(" 数组+链表/树问题")]),a._v(" "),s("h4",{attrs:{id:"hashmap-为什么引入链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-为什么引入链表"}},[a._v("#")]),a._v(" hashmap 为什么引入链表？")]),a._v(" "),s("h4",{attrs:{id:"为什么-jdk-1-8-引入红黑树呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-jdk-1-8-引入红黑树呢"}},[a._v("#")]),a._v(" 为什么 Jdk 1.8 引入红黑树呢？")]),a._v(" "),s("h4",{attrs:{id:"为什么一开始不就使用红黑树-而是大于-8-才变为红黑树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么一开始不就使用红黑树-而是大于-8-才变为红黑树"}},[a._v("#")]),a._v(" 为什么一开始不就使用红黑树，而是大于 8 才变为红黑树？")]),a._v(" "),s("h4",{attrs:{id:"底层数组取值的时候-为什么不用取模-而是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#底层数组取值的时候-为什么不用取模-而是"}},[a._v("#")]),a._v(" 底层数组取值的时候，为什么不用取模，而是 & ？")]),a._v(" "),s("h4",{attrs:{id:"为什么数组的长度是-2-的次方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么数组的长度是-2-的次方"}},[a._v("#")]),a._v(" 为什么数组的长度是 2 的次方？")]),a._v(" "),s("h2",{attrs:{id:"源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[a._v("#")]),a._v(" 源码")]),a._v(" "),s("h4",{attrs:{id:"put-的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#put-的过程"}},[a._v("#")]),a._v(" put() 的过程？")]),a._v(" "),s("h4",{attrs:{id:"get-过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get-过程"}},[a._v("#")]),a._v(" get() 过程？")]),a._v(" "),s("h4",{attrs:{id:"hashmap-resize-扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-resize-扩容机制"}},[a._v("#")]),a._v(" HashMap resize 扩容机制")]),a._v(" "),s("p",[a._v("首先 HashMap 扩容发生在这几种情况下：")]),a._v(" "),s("p",[a._v("第一个添加值以后大于阈值；第二个是表为空；第三个就是 treeifyBin 的时候或者数组长度小于最小树化阈值（默认  64）的时候才会执行。")]),a._v(" "),s("p",[a._v("这里重点讲一下第一种情况，先要知道几个字段：")]),a._v(" "),s("p",[a._v("容量(capacaity）：这个容量表示的是数组的大小；")]),a._v(" "),s("p",[a._v("size：表示的是整个 hash 表中记录的所有数据的个数；")]),a._v(" "),s("p",[a._v("负载因子（"),s("strong",[a._v("load factor")]),a._v("）：默认是 0.75；")]),a._v(" "),s("p",[a._v("还有个阈值，值是 负载因子乘以容量")]),a._v(" "),s("p",[a._v("当添加一个数据后，会判断此时 size 是否大于阈值，大于阈值的话就会扩容。")]),a._v(" "),s("p",[a._v("然后扩容大小的话默认是翻倍的，因为默认是容量左移一位，也就是容量翻倍。之后就会在创建一个新的数组，把老数组的值复制过去。这里需要")]),a._v(" "),s("p",[a._v("需要几点：第一个就是如果节点是数节点的话，会拆分。如果本身就是个链表的话，按照（ (e.hash & oldCap) == 0 ）节点的 hash 值与上老的容量值是否等于 0 拆分成两个新的链表，这两个链表就是扩容后在新链表的位置了。")]),a._v(" "),s("h4",{attrs:{id:"resize-扩容的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resize-扩容的原理"}},[a._v("#")]),a._v(" resize() 扩容的原理")]),a._v(" "),s("p",[a._v("主要就是扩容后位置的变化。最要的就是 oldCap&hash == 0 这个算法。")]),a._v(" "),s("h2",{attrs:{id:"hashmap-多线程不安全的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-多线程不安全的原因"}},[a._v("#")]),a._v(" HashMap 多线程不安全的原因")]),a._v(" "),s("h4",{attrs:{id:"多线程-put-丢失数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程-put-丢失数据"}},[a._v("#")]),a._v(" 多线程 put 丢失数据")]),a._v(" "),s("h4",{attrs:{id:"多线程-get-数据可能为-null"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程-get-数据可能为-null"}},[a._v("#")]),a._v(" 多线程 get 数据可能为 null")]),a._v(" "),s("h4",{attrs:{id:"jdk-1-7-中头插入-导致-get-死循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk-1-7-中头插入-导致-get-死循环"}},[a._v("#")]),a._v(" JDk 1.7 中头插入，导致 get 死循环")]),a._v(" "),s("p",[a._v("线程安全的话，建议 ConcurrnetHashMap。")]),a._v(" "),s("h4",{attrs:{id:"hashmap-1-7-和-1-8-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-1-7-和-1-8-的区别"}},[a._v("#")]),a._v(" HashMap 1.7 和 1.8 的区别")]),a._v(" "),s("p",[a._v("从底层数据结构来看，1.7 底层使用的是数组 + 链表。而 1.8 底层使用的是数组+链表+数。默认是链表长度大于 8 的时候，会判断数组长度是否大于 "),s("code",[a._v("MIN_TREEIFY_CAPACITY")]),a._v("，默认是 64 ，当小于这个值的时候，是会扩容而不是树化。")]),a._v(" "),s("p",[a._v("从 hash 方法来看， 1.7 的 hash 算法是异或了四次，1.8 则是通过hashcode 的高16位异或低16位实现，这样做的优点是影响 hash 的分布性，降低冲突率。")]),a._v(" "),s("h1",{attrs:{id:"concurrenthashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),s("h2",{attrs:{id:"_1-7-和-1-8-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-和-1-8-区别"}},[a._v("#")]),a._v(" 1.7 和 1.8 区别")]),a._v(" "),s("h4",{attrs:{id:"concurrenthashmap-的实现原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-的实现原理是什么"}},[a._v("#")]),a._v(" ConcurrentHashMap 的实现原理是什么？")]),a._v(" "),s("h4",{attrs:{id:"put-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#put-方法"}},[a._v("#")]),a._v(" put() 方法？")]),a._v(" "),s("h4",{attrs:{id:"get-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get-方法"}},[a._v("#")]),a._v(" get() 方法？")]),a._v(" "),s("h2",{attrs:{id:"其他"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[a._v("#")]),a._v(" 其他")]),a._v(" "),s("h4",{attrs:{id:"concurrenthashmap-不支持-key-或者-value-为-null-的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-不支持-key-或者-value-为-null-的原因"}},[a._v("#")]),a._v(" ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？")]),a._v(" "),s("h4",{attrs:{id:"concurrenthashmap-的并发度是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-的并发度是什么"}},[a._v("#")]),a._v(" ConcurrentHashMap 的并发度是什么？")]),a._v(" "),s("h4",{attrs:{id:"concurrenthashmap-迭代器是强一致性还是弱一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-迭代器是强一致性还是弱一致性"}},[a._v("#")]),a._v(" ConcurrentHashMap 迭代器是强一致性还是弱一致性？")]),a._v(" "),s("h4",{attrs:{id:"jdk1-7-与-jdk1-8-中concurrenthashmap-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-7-与-jdk1-8-中concurrenthashmap-的区别"}},[a._v("#")]),a._v(" JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？")]),a._v(" "),s("h4",{attrs:{id:"concurrenthashmap-和-hashtable-的效率哪个更高-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-和-hashtable-的效率哪个更高-为什么"}},[a._v("#")]),a._v(" ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？")]),a._v(" "),s("p",[a._v("https://blog.csdn.net/yunzhaji3762/article/details/113623168?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2")])])}),[],!1,null,null,null);t.default=r.exports}}]);