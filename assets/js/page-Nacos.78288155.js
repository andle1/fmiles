(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{663:function(a,t,s){"use strict";s.r(t);var r=s(1),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"nacos"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nacos"}},[a._v("#")]),a._v(" Nacos")]),a._v(" "),s("h4",{attrs:{id:"nacos-作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nacos-作用"}},[a._v("#")]),a._v(" Nacos 作用？")]),a._v(" "),s("p",[a._v("注册中心，服务的注册发现。")]),a._v(" "),s("h4",{attrs:{id:"在nacos中服务提供者是如何向nacos注册中心-registry-续约的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在nacos中服务提供者是如何向nacos注册中心-registry-续约的"}},[a._v("#")]),a._v(" 在Nacos中服务提供者是如何向Nacos注册中心(Registry)续约的？")]),a._v(" "),s("p",[a._v("5秒心跳包，定时向 nocas 发送请求，告诉它自己还活着，这就叫做续约。")]),a._v(" "),s("h4",{attrs:{id:"nacos-如何判断服务实例状态的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nacos-如何判断服务实例状态的"}},[a._v("#")]),a._v(" Nacos 如何判断服务实例状态的？")]),a._v(" "),s("p",[a._v("在 15 s 没收到心跳会将实例设置为不健康状态，超过 30 s 就会删除。")]),a._v(" "),s("h2",{attrs:{id:"feign"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#feign"}},[a._v("#")]),a._v(" Feign")]),a._v(" "),s("h4",{attrs:{id:"loadbalanced的作用是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loadbalanced的作用是什么"}},[a._v("#")]),a._v(" @LoadBalanced的作用是什么？")]),a._v(" "),s("p",[a._v("(描述RestTemplate对象，用于告诉spring框架，在使用RestTemplate进行服务调用时，这个调用过程会被一个拦截器进行拦截，然后在拦截器内部启动负载均衡策略)")]),a._v(" "),s("h2",{attrs:{id:"hystrix"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hystrix"}},[a._v("#")]),a._v(" Hystrix")]),a._v(" "),s("p",[a._v("作用就是防止服务雪崩。")]),a._v(" "),s("p",[a._v("解决办法：")]),a._v(" "),s("p",[a._v("资源隔离和服务降级。")]),a._v(" "),s("p",[s("strong",[a._v("资源隔离：")])]),a._v(" "),s("p",[a._v("​    在 Hystrix 中，主要通过线程池来实现资源隔离。通常在使用的时候我们会根据调用的远程服务划分出多个线程池。例如调用产品服务的 Command 放入 A 线程池，调用账户服务的 Command 放入 B 线程池。这样做的主要优点是运行环境被隔离开了。这样就算调用服务的代码存在 bug 或者由于其他原因导致自己所在线程池被耗尽时，不会对系统的其他服务造成影响。")]),a._v(" "),s("p",[s("strong",[a._v("服务降级：")])]),a._v(" "),s("p",[a._v("​    对于查询操作，我们可以实现一个 fallback 方法，当请求后端服务出现异常的时候，可以使用 fallback 方法返回的值。fallback 方法的返回值一般是设置的默认值或者来自缓存。")]),a._v(" "),s("p",[a._v("​     如果线程池已满，或者请求超时，则会进行降级处理。降级服务优先保证核心服务，而非核心服务不可用或者弱可用。服务降级虽然会导致请求失败，但是不会导致阻塞，最多是影响这个依赖服务对应的线程池中的资源，对其他服务没有影响。")]),a._v(" "),s("h4",{attrs:{id:"熔断机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#熔断机制"}},[a._v("#")]),a._v(" 熔断机制：")]),a._v(" "),s("p",[a._v("当请求后端服务失败数量超过一定阈值，熔断器会切换到开路状态 (Open)。这时所有请求会直接失败而不会发送到后端服务。")]),a._v(" "),s("h2",{attrs:{id:"ribbon"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ribbon"}},[a._v("#")]),a._v(" Ribbon")]),a._v(" "),s("p",[a._v("默认是轮询。")]),a._v(" "),s("h2",{attrs:{id:"gateway"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gateway"}},[a._v("#")]),a._v(" Gateway")]),a._v(" "),s("p",[a._v("路由转发、权限校验、限流控制等作用。")])])}),[],!1,null,null,null);t.default=e.exports}}]);