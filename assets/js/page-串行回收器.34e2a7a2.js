(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{583:function(a,s,t){a.exports=t.p+"assets/img/image-20220305124739242.9771be2b.png"},584:function(a,s,t){a.exports=t.p+"assets/img/image-20220305131214990.72de166b.png"},585:function(a,s,t){a.exports=t.p+"assets/img/{0A780C2E-6189-18D9-B694-E23FD4C166DC}-1583157449453.0a780c2e.jpg"},586:function(a,s,t){a.exports=t.p+"assets/img/{68B10D66-D07A-9360-1B75-93DEE1647578}.68b10d66.jpg"},587:function(a,s,t){a.exports=t.p+"assets/img/{0BE881BF-66A4-EC00-7290-386E3859F86B}.0be881bf.jpg"},588:function(a,s,t){a.exports=t.p+"assets/img/{A66F64C3-232B-3195-E74E-6A17791F7CC2}.a66f64c3.jpg"},589:function(a,s,t){a.exports=t.p+"assets/img/{407133D3-4F56-A115-EBA6-C64CBE3B7186}.407133d3.jpg"},590:function(a,s,t){a.exports=t.p+"assets/img/{E11DFB54-2D55-C0FC-E8A5-DDF573CC6841}.e11dfb54.jpg"},591:function(a,s,t){a.exports=t.p+"assets/img/{A07C7E2C-D981-CAB7-7D8E-7590C169D772}.a07c7e2c.jpg"},729:function(a,s,t){"use strict";t.r(s);var e=t(1),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"串行回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#串行回收器"}},[a._v("#")]),a._v(" 串行回收器")]),a._v(" "),e("p",[a._v("串行回收器两个特点：")]),a._v(" "),e("p",[a._v("1、使用单线程进行垃圾回收的收集器，每次回收只有一个工作线程")]),a._v(" "),e("p",[a._v("2、是独占式的垃圾回收")]),a._v(" "),e("p",[a._v("​\t\t因为串行回收器是独占的，所以在垃圾回收的时候，会暂停所有的工作线程，即 STW。这种用户体验很糟糕，但是因为是单线程 GC，没有多线程切换的额外开销，简单实用。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(583),alt:"image-20220305124739242",loading:"lazy"}})]),a._v(" "),e("h3",{attrs:{id:"serial-回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serial-回收器"}},[a._v("#")]),a._v(" Serial 回收器")]),a._v(" "),e("ul",[e("li",[a._v("新生代回收器，虚拟机运行在 Client 模式时的默认新生代收集器。")]),a._v(" "),e("li",[a._v("复制收集算法")])]),a._v(" "),e("p",[a._v("启用新生代串行回收器：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseSerialGC")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("h3",{attrs:{id:"serial-old-回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serial-old-回收器"}},[a._v("#")]),a._v(" Serial Old 回收器")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("老年代回收器")])]),a._v(" "),e("li",[e("p",[a._v("标记整理算法")])])]),a._v(" "),e("p",[a._v("启用老年代串行回收器：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseSerialGC")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 新生代老年代都使用串行收集器")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseParNewGC")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 新生代使用 ParNew 回收器，老年代使用串行回收器")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseParallelGC")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 新生代使用 ParallelGC 回收器，老年代使用串行回收器")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h2",{attrs:{id:"并行回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并行回收器"}},[a._v("#")]),a._v(" 并行回收器")]),a._v(" "),e("p",[a._v("​\t\t在串行回收期基础上改进，使用多个线程同时进行垃圾回收。对于并行能力强的计算器机，可以有效缩短STW时间。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(584),alt:"image-20220305131214990",loading:"lazy"}})]),a._v(" "),e("h3",{attrs:{id:"parnew-回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parnew-回收器"}},[a._v("#")]),a._v(" ParNew 回收器")]),a._v(" "),e("ul",[e("li",[a._v("新生代回收器。Serial 的多线程版本，除了使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与 Serial 回收器一模一样。")]),a._v(" "),e("li",[a._v("对应的这种回收器是虚拟机运行在 Server 模式的默认新生代收集器，在单 CPU 的环境中，ParNew 收集器并不会比 Serial 收集器有更好的效果。只有在多CPU 的环境下，效率才会比 Serial 收集器要高。")])]),a._v(" "),e("p",[a._v("开启 ParNew 回收器：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseParNewGC")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 新生代使用 ParNew 回收器，老年代使用串行回收器")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseConcMarkSweepGC")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//新生代 ParNew 回收器，老年代 CMS")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h3",{attrs:{id:"parallel-scavenge-回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parallel-scavenge-回收器"}},[a._v("#")]),a._v(" Parallel Scavenge 回收器")]),a._v(" "),e("ul",[e("li",[a._v("新生代回收器。Parallel Scavenge 收集器也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与 ParNew 收集器有所不同，它是以吞吐量最大化（即GC 时间占总运行时间最小）为目的的收集器实现，它运行较长时间的 STW 换取总吞吐量最大化。")]),a._v(" "),e("li",[a._v("JDK 1.8 默认在新生代的垃圾收集器")])]),a._v(" "),e("p",[a._v("开启 Parallel Scavenge 回收器：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseParallelGC")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 新生代使用 ParallelGC 回收器，老年代使用串行回收器")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseParallelOldGC")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h3",{attrs:{id:"parallel-old-回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parallel-old-回收器"}},[a._v("#")]),a._v(" Parallel Old 回收器")]),a._v(" "),e("p",[a._v("​\t\t老年版本吞吐量优先级收集器，使用多线程和标记-整理算法，JVM1.6 提供，在此之前，新生代使用了 PS 收集器的话，老年代除 Serial Old 外别无选择，因为 PS 无法与 CMS 收集器配合工作。")]),a._v(" "),e("ul",[e("li",[a._v("Parallel Scavenge 在老年代的实现")]),a._v(" "),e("li",[a._v("在JVM 1.6 才出现Parallel Old")]),a._v(" "),e("li",[a._v("标记整理算法")]),a._v(" "),e("li",[a._v("JDK 1.8 默认在老年代的垃圾收集器")])]),a._v(" "),e("p",[a._v("开启 Parallel Old 回收器：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseParallelOldGC")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("h2",{attrs:{id:"cms-回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cms-回收器"}},[a._v("#")]),a._v(" CMS 回收器")]),a._v(" "),e("p",[a._v("CMS （Concurrent Mark Sweep）回收器，以获取最短回收停顿时间为目标。")]),a._v(" "),e("p",[a._v("CMS 是基于 “标记-清除” 算法实现的，整个过程分为4个过程：")]),a._v(" "),e("blockquote",[e("ol",[e("li",[a._v("初始标记（CMS initial mark）")]),a._v(" "),e("li",[a._v("并发标记（CMS concurrent mark）")]),a._v(" "),e("li",[a._v("重新标记（CMS remark）")]),a._v(" "),e("li",[a._v("并发清除（CMS concurrent sweep）")])])]),a._v(" "),e("p",[a._v("补充说明：")]),a._v(" "),e("ul",[e("li",[a._v("初始标记、重新标记这两个步骤仍需要 STW。")]),a._v(" "),e("li",[a._v("初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快。")]),a._v(" "),e("li",[a._v("并发标记阶段是进行 GC Roots Tracing 的过程（即从 GC Root 开始找到被 GC Root 引用或者关联的对象，再从被引用对象开始找他自己能引用 或关联的对象）。")]),a._v(" "),e("li",[a._v("重新标记阶段是为了修正并发标记阶段因用户程序继续运行而导致的标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记阶段稍长，但远比并发标记的时间短。")])]),a._v(" "),e("p",[e("img",{attrs:{src:t(585),alt:"{0A780C2E-6189-18D9-B694-E23FD4C166DC}-1583157449453",loading:"lazy"}})]),a._v(" "),e("p",[a._v("如图，在初始标记和重新标记阶段是没有用户线程执行的。")]),a._v(" "),e("h4",{attrs:{id:"cms-工作流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cms-工作流程"}},[a._v("#")]),a._v(" CMS 工作流程")]),a._v(" "),e("p",[a._v("第一个阶段：初始标记")]),a._v(" "),e("p",[e("img",{attrs:{src:t(586),alt:"{68B10D66-D07A-9360-1B75-93DEE1647578}",loading:"lazy"}})]),a._v(" "),e("p",[a._v("第二个阶段：并发标记")]),a._v(" "),e("p",[e("img",{attrs:{src:t(587),alt:"{0BE881BF-66A4-EC00-7290-386E3859F86B}",loading:"lazy"}})]),a._v(" "),e("p",[a._v("第三个阶段：并发的预先清理")]),a._v(" "),e("p",[e("img",{attrs:{src:t(588),alt:"{A66F64C3-232B-3195-E74E-6A17791F7CC2}",loading:"lazy"}})]),a._v(" "),e("p",[a._v("第四个阶段：并发的可失败的预先清理")]),a._v(" "),e("p",[e("img",{attrs:{src:t(589),alt:"{407133D3-4F56-A115-EBA6-C64CBE3B7186}",loading:"lazy"}})]),a._v(" "),e("p",[a._v("第五个阶段：重新标记\t"),e("img",{attrs:{src:t(590),alt:"{E11DFB54-2D55-C0FC-E8A5-DDF573CC6841}",loading:"lazy"}})]),a._v(" "),e("p",[a._v("第六个阶段：并发清除")]),a._v(" "),e("p",[e("img",{attrs:{src:t(591),alt:"{A07C7E2C-D981-CAB7-7D8E-7590C169D772}",loading:"lazy"}})]),a._v(" "),e("p",[a._v("第七个对象：并发重置")]),a._v(" "),e("p",[a._v("这个阶段也是并发执行的，它会重设 CMS 内部的数据结构，为下次的 GC 做准备。")]),a._v(" "),e("h2",{attrs:{id:"g1-回收器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#g1-回收器"}},[a._v("#")]),a._v(" G1 回收器")]),a._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("p",[a._v("![1583156975006](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\typora-user-images\\1583156975006.png?lastModify=1649055215)")])])}),[],!1,null,null,null);s.default=r.exports}}]);