(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{475:function(t,_,v){t.exports=v.p+"assets/img/20210710220330858.95381ee0.png"},655:function(t,_,v){"use strict";v.r(_);var a=v(1),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("img",{attrs:{src:v(475),alt:"img",loading:"lazy"}})]),t._v(" "),a("h4",{attrs:{id:"分布式事务和分布式锁的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务和分布式锁的区别"}},[t._v("#")]),t._v(" 分布式事务和分布式锁的区别")]),t._v(" "),a("p",[t._v("分布式锁解决的是分布式资源抢占的问题；分布式事务和本地事务是解决流程化提交问题。")]),t._v(" "),a("h2",{attrs:{id:"分布式事务出现背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务出现背景"}},[t._v("#")]),t._v(" 分布式事务出现背景")]),t._v(" "),a("p",[t._v("当本地事务要扩展到分布式时，它的复杂性进一步增加了。")]),t._v(" "),a("p",[a("strong",[t._v("存储端的多样性：")])]),t._v(" "),a("p",[t._v("首先就是存储端的多样性。本地事务的情况下，所有数据都会落到同一个DB中，但是，在分布式的情况下，就会出现数据可能要落到多个DB，或者还会落到Redis，落到MQ等中。")]),t._v(" "),a("p",[a("strong",[t._v("事务链路的延展性")]),t._v("：")]),t._v(" "),a("p",[t._v("本地事务的情况下，通常所有事务相关的业务操作，会被我们封装到一个Service方法中。而在分布式的情况下，请求链路被延展，拉长，一个操作会被拆分成多个服务，它们呈现线状或网状，依靠网络通信构建成一个整体。在这种情况下，事务无疑变得更复杂。")]),t._v(" "),a("p",[t._v("基于上述两个复杂性，期望有一个统一的分布式事务方案，能够像本地事务一样，以几乎无侵入的方式，满足各种存储介质，各种复杂链路，是不现实的。至少，在当前，还没有一个十分成熟的解决方案。所以，一般情况下，在分布式下，事务会被拆分解决，并根据不同的情况，采用不同的解决方案。")]),t._v(" "),a("h2",{attrs:{id:"什么是分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是分布式事务"}},[t._v("#")]),t._v(" 什么是分布式事务")]),t._v(" "),a("p",[t._v("对于分布式系统而言，需要保证分布式系统中的数据一致性，保证数据在子系统中始终保持一致，避免业务出现问题。分布式系统中对数要么一起成功，要么一起失败，必须是一个整体性的事务。")]),t._v(" "),a("p",[t._v("分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。")]),t._v(" "),a("p",[t._v("简单的说，在分布式系统上一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务节点上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。")]),t._v(" "),a("p",[t._v("举个例子：在电商网站中，用户对商品进行下单，需要在订单表中创建一条订单数据，同时需要在库存表中修改当前商品的剩余库存数量，两步操作一个添加，一个修改，我们一定要保证这两步操作一定同时操作成功或失败，否则业务就会出现问题。")]),t._v(" "),a("p",[t._v("任何事务机制在实现时，都应该考虑事务的ACID特性，包括：本地事务、分布式事务。对于分布式事务而言，即使不能都很好的满足，也要考虑支持到什么程度。")]),t._v(" "),a("h4",{attrs:{id:"典型的分布式事务场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#典型的分布式事务场景"}},[t._v("#")]),t._v(" 典型的分布式事务场景")]),t._v(" "),a("h5",{attrs:{id:"_1、跨库事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、跨库事务"}},[t._v("#")]),t._v(" 1、跨库事务")]),t._v(" "),a("p",[t._v("跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。")]),t._v(" "),a("h5",{attrs:{id:"_2、分库分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、分库分表"}},[t._v("#")]),t._v(" 2、分库分表")]),t._v(" "),a("p",[t._v("通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。")]),t._v(" "),a("h5",{attrs:{id:"_3、微服务化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、微服务化"}},[t._v("#")]),t._v(" 3、微服务化")]),t._v(" "),a("h2",{attrs:{id:"cap-理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cap-理论"}},[t._v("#")]),t._v(" CAP 理论")]),t._v(" "),a("p",[t._v("CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能能同时满足以下三点中的两个：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一致性（Consistence）")]),t._v(" : 一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值 (这个无论哪个节点就包含了故障和非故障节点)")]),t._v(" "),a("li",[a("strong",[t._v("可用性（Availability）")]),t._v(": 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。")]),t._v(" "),a("li",[a("strong",[t._v("分区容错性（Partition tolerance）")]),t._v(" : 分布式系统出现网络分区的时候，仍然能够对外提供服务。")])]),t._v(" "),a("h6",{attrs:{id:"网络分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络分区"}},[t._v("#")]),t._v(" 网络分区？")]),t._v(" "),a("blockquote",[a("p",[t._v("​\t\t分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。")])]),t._v(" "),a("p",[t._v("​        "),a("strong",[t._v("当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。")])]),t._v(" "),a("h5",{attrs:{id:"分布式一致性的-3-种级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式一致性的-3-种级别"}},[t._v("#")]),t._v(" 分布式一致性的 3 种级别：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("强一致性")]),t._v(" ：系统写入了什么，读出来的就是什么。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("弱一致性")]),t._v(" ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("最终一致性")]),t._v(" ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。")])])]),t._v(" "),a("h2",{attrs:{id:"base-理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base-理论"}},[t._v("#")]),t._v(" BASE 理论")]),t._v(" "),a("p",[t._v("CA 都要是无法实现的，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而追求最终一致性，所以引入 BASE 理论，在分布式事务中，BASE 最重要是为 CAP 提出了最终一致性的解决方案，BASE 强调牺牲强一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。")]),t._v(" "),a("p",[t._v("1、基本可用：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。")]),t._v(" "),a("p",[t._v("(1）响应时间上的损失")]),t._v(" "),a("blockquote",[a("p",[t._v("当出现故障时，响应时间增加")])]),t._v(" "),a("p",[t._v("（2）功能上的损失")]),t._v(" "),a("blockquote",[a("p",[t._v("流量高峰期时，屏蔽一些功能的使用以保证系统稳定性（服务降级）")])]),t._v(" "),a("p",[t._v("2、软状态：软状态指允许系统中的数据存在中间状态（"),a("strong",[t._v("CAP 理论中的数据不一致")]),t._v("），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。")]),t._v(" "),a("p",[t._v("3、最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态")]),t._v(" "),a("p",[a("strong",[t._v("ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。")])]),t._v(" "),a("h2",{attrs:{id:"分布式事务分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务分类"}},[t._v("#")]),t._v(" 分布式事务分类")]),t._v(" "),a("h3",{attrs:{id:"柔性事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#柔性事务"}},[t._v("#")]),t._v(" 柔性事务")]),t._v(" "),a("p",[t._v("柔性事务指的是，不要求强一致性，而是要求最终一致性，允许有中间状态，也就是 Base 理论，换句话说，就是 AP 状态。")]),t._v(" "),a("blockquote",[a("p",[t._v("与刚性事务相比，柔性事务的特点为：有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。")])]),t._v(" "),a("p",[t._v("柔性事务分为：")]),t._v(" "),a("ul",[a("li",[t._v("补偿型")]),t._v(" "),a("li",[t._v("异步确保型")]),t._v(" "),a("li",[t._v("最大努力通知型。")])]),t._v(" "),a("p",[t._v("柔型事务：TCC/FMT、Saga（状态机模式、Aop模式）、本地事务消息、消息事务（半消息）")]),t._v(" "),a("h3",{attrs:{id:"刚性事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#刚性事务"}},[t._v("#")]),t._v(" 刚性事务")]),t._v(" "),a("p",[t._v("刚性事务指的是，要使分布式事务，达到像本地式事务一样，具备数据强一致性，从 CAP 来看，就是说，要达到 CP 状态。")]),t._v(" "),a("blockquote",[a("p",[t._v("刚性事务：通常无业务改造，强一致性，原生支持回滚/隔离性，低并发，适合短事务。")])]),t._v(" "),a("p",[t._v("刚性事务：XA 协议（2PC、JTA、JTS）、3PC，但由于同步阻塞，处理效率低，不适合大型网站分布式场景。")]),t._v(" "),a("h3",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("h4",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考：")]),t._v(" "),a("p",[t._v("https://www.cnblogs.com/crazymakercircle/p/13917517.html")])])}),[],!1,null,null,null);_.default=s.exports}}]);