(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{737:function(t,a,v){"use strict";v.r(a);var s=v(1),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"创建对象的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建对象的过程"}},[t._v("#")]),t._v(" 创建对象的过程")]),t._v(" "),v("p",[t._v("关于Java对象创建的过程：")]),t._v(" "),v("p",[t._v("![Java创建对象的过程](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\memory\\Java创建对象的过程.png?lastModify=1648978507)")]),t._v(" "),v("h4",{attrs:{id:"step1-类加载检查"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#step1-类加载检查"}},[t._v("#")]),t._v(" Step1:类加载检查")]),t._v(" "),v("p",[t._v("虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程")]),t._v(" "),v("h4",{attrs:{id:"step2-分配内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#step2-分配内存"}},[t._v("#")]),t._v(" Step2:分配内存")]),t._v(" "),v("p",[t._v("在"),v("strong",[t._v("类加载检查")]),t._v("通过后，接下来虚拟机将为新生对象"),v("strong",[t._v("分配内存")]),t._v("。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。"),v("strong",[t._v("分配方式")]),t._v("有 "),v("strong",[t._v("“指针碰撞”")]),t._v(" 和 "),v("strong",[t._v("“空闲列表”")]),t._v(" 两种，"),v("strong",[t._v("选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定")]),t._v("。")]),t._v(" "),v("p",[v("strong",[t._v("内存分配的两种方式：（补充内容，需要掌握）")])]),t._v(" "),v("p",[t._v('选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的')]),t._v(" "),v("p",[t._v("![内存分配的两种方式](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\memory\\内存分配的两种方式.png?lastModify=1648978697)")]),t._v(" "),v("p",[v("strong",[t._v("内存分配并发问题（补充内容，需要掌握）")])]),t._v(" "),v("p",[t._v("在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("CAS+失败重试：")]),t._v(" CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。"),v("strong",[t._v("虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("TLAB：")]),t._v(" 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配")])])]),t._v(" "),v("h4",{attrs:{id:"step3-初始化零值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#step3-初始化零值"}},[t._v("#")]),t._v(" Step3:初始化零值")]),t._v(" "),v("p",[t._v("内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。")]),t._v(" "),v("h4",{attrs:{id:"step4-设置对象头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#step4-设置对象头"}},[t._v("#")]),t._v(" Step4:设置对象头")]),t._v(" "),v("p",[t._v("初始化零值完成之后，"),v("strong",[t._v("虚拟机要对对象进行必要的设置")]),t._v("，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 "),v("strong",[t._v("这些信息存放在对象头中。")]),t._v(" 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。")]),t._v(" "),v("h4",{attrs:{id:"step5-执行-init-方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#step5-执行-init-方法"}},[t._v("#")]),t._v(" Step5:执行 init 方法")]),t._v(" "),v("p",[t._v("在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，"),v("code",[t._v("<init>")]),t._v(" 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 "),v("code",[t._v("<init>")]),t._v(" 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。")]),t._v(" "),v("h3",{attrs:{id:"tlab"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tlab"}},[t._v("#")]),t._v(" TLAB")]),t._v(" "),v("p",[t._v("虽然堆内存是线程共享的，但是TLAB区是线程私有的。")]),t._v(" "),v("p",[t._v("​\t\tJVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。\n​\t\t也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。")]),t._v(" "),v("p",[t._v("![img](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\typora-user-images\\1137223-20180724163533976-1404788272-1583145637758.png?lastModify=1648978887)")])])}),[],!1,null,null,null);a.default=e.exports}}]);