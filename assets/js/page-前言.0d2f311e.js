(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{599:function(e,t,a){e.exports=a.p+"assets/img/image-20220305010408379.9bdce472.png"},600:function(e,t,a){e.exports=a.p+"assets/img/image-20220305000750000.a22db12b.png"},601:function(e,t,a){e.exports=a.p+"assets/img/image-20220305002356745.96fbfe70.png"},732:function(e,t,a){"use strict";a.r(t);var r=a(1),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("p",[e._v("垃圾回收的出现是为了防止忘记回收对象造成内存溢出，更多是让开发者专注于业务。")]),e._v(" "),r("h2",{attrs:{id:"垃圾回收算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[e._v("#")]),e._v(" 垃圾回收算法")]),e._v(" "),r("h3",{attrs:{id:"_1、引用计数-reference-counting"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、引用计数-reference-counting"}},[e._v("#")]),e._v(" 1、引用计数（Reference Counting）")]),e._v(" "),r("p",[r("strong",[e._v("原理")]),e._v("：对象 A 被引用则 A 的引用计数器 + 1，当引用失效计数器 -1。当 A 的引用计数器为 0，则对象不可被引用。")]),e._v(" "),r("p",[r("strong",[e._v("缺点")]),e._v("：不可达对象会循环引用。")]),e._v(" "),r("p",[e._v("循环引用：")]),e._v(" "),r("p",[e._v("​\t\tA 持有 B 对象，B 持有 A。在之前，可能会有其他引用分别指向这两个类，但是渐渐消失，最后剩下 A，B 相互引用。而这时候不会有其他类的引用，这两个类是没作用了。但是引用计数算法会判断计数器是否为0,此时 A ,B 都是1，故而无法被回收。")]),e._v(" "),r("p",[r("img",{attrs:{src:a(599),alt:"image-20220305010408379",loading:"lazy"}})]),e._v(" "),r("h3",{attrs:{id:"_2、标记清除-mark-sweep"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、标记清除-mark-sweep"}},[e._v("#")]),e._v(" 2、标记清除（Mark-Sweep）")]),e._v(" "),r("p",[r("strong",[e._v("原理")]),e._v("：标记阶段和清除阶段。从根节点标记所有可达对象，然后清除不可达对象。")]),e._v(" "),r("p",[r("strong",[e._v("缺点")]),e._v("：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("效率问题，标记和清理两个过程效率都不高。因为需要扫描所有对象。堆越大，GC 越慢。")])]),e._v(" "),r("li",[r("p",[e._v("空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾收集动作。并且 GC 次数越多，碎片越严重。")])])]),e._v(" "),r("p",[e._v("标记清除示意图：")]),e._v(" "),r("p",[r("img",{attrs:{src:a(600),alt:"image-20220305000750000",loading:"lazy"}})]),e._v(" "),r("h3",{attrs:{id:"_3、复制算法-copying"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、复制算法-copying"}},[e._v("#")]),e._v(" 3、复制算法（Copying）")]),e._v(" "),r("p",[r("strong",[e._v("原理")]),e._v("：将一块内存分为两块，每次使用一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到未使用的内存中。")]),e._v(" "),r("p",[r("strong",[e._v("优点")]),e._v("：内存回收都是对整个半区的回收，内存分配也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。")]),e._v(" "),r("p",[r("strong",[e._v("缺点")]),e._v("：内存浪费一半。如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。")]),e._v(" "),r("p",[e._v("复制算法适用于用于新生代，在存活对象少、垃圾对象多的前提下效率高。虚拟机将内存分为一块较大的 eden 空间和 2 块较少的 survivor （from，to） 空间，每次使用 eden 和其中一块 survivor，当回收时将 eden 和 survivor 还存活的对象一次性拷贝到另外一块 survivor 空间上，然后清理掉 eden 和用过的 survivor。")]),e._v(" "),r("h3",{attrs:{id:"_4、标记压缩-mark-compact"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、标记压缩-mark-compact"}},[e._v("#")]),e._v(" 4、标记压缩（Mark-Compact）")]),e._v(" "),r("p",[r("strong",[e._v("原理")]),e._v("：标记阶段同标记清除，从根节点开始标记可达对象，将不可达对象压缩到内存的一端，再清除边界外的所有空间。")]),e._v(" "),r("p",[r("strong",[e._v("优点")]),e._v("：没有内存碎片。")]),e._v(" "),r("p",[r("strong",[e._v("缺点")]),e._v("：耗费更多时间压缩。")]),e._v(" "),r("h3",{attrs:{id:"_5、分代算法-generational-collecting"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、分代算法-generational-collecting"}},[e._v("#")]),e._v(" 5、分代算法（Generational Collecting）")]),e._v(" "),r("p",[r("strong",[e._v("原理")]),e._v("：将内存区域根据特点分成几块，根据每块内存区域的特点，选择不同的回收算法。")]),e._v(" "),r("p",[e._v("对新生代和老年代来说，通常新生代的回收频率很高，耗时短，但老年代回收频率低，耗时长。为了支持高频率新生代回收，虚拟机使用卡表。卡表是比特位的集合，每一个比特用来表示老年代中的某一区域是否持有新生代对象。这样在新生代GC时候，就可通过扫描卡表而不需要扫描老年代。")]),e._v(" "),r("h5",{attrs:{id:"卡表图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#卡表图"}},[e._v("#")]),e._v(" 卡表图：")]),e._v(" "),r("p",[r("img",{attrs:{src:a(601),alt:"image-20220305002356745",loading:"lazy"}})]),e._v(" "),r("h4",{attrs:{id:"补充说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#补充说明"}},[e._v("#")]),e._v(" 补充说明：")]),e._v(" "),r("p",[e._v("新生代：")]),e._v(" "),r("blockquote",[r("ol",[r("li",[e._v("新生成的对象都放在新生代")]),e._v(" "),r("li",[e._v("Eden 和 2个 Survivor 的缺省比例是 8：1：1，也就是10% 的空间会被浪费")]),e._v(" "),r("li",[e._v("年轻代触发的 gc 是 minor gc 不会导致应用进程停顿")])])]),e._v(" "),r("p",[e._v("老年代：")]),e._v(" "),r("blockquote",[r("ol",[r("li",[e._v("年轻代gc 15 次后还存活的对象会进入老年代")]),e._v(" "),r("li",[e._v("大对象直接进入老年代 (大对象就是需要大量连续内存空间的对象，比如：字符串、数组)")]),e._v(" "),r("li",[e._v("老年代触发的 gc 是 full gc 会导致应用进程停顿 对性能的影响比较大")]),e._v(" "),r("li",[e._v("新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2")])])]),e._v(" "),r("h3",{attrs:{id:"_6、分区算法-region"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6、分区算法-region"}},[e._v("#")]),e._v(" 6、分区算法（Region）")]),e._v(" "),r("p",[r("strong",[e._v("原理")]),e._v("：将整个堆空间划分成连续的不同小区域，每个小区域独立使用、回收。可以减少一次 GC 所产生的停顿。")]),e._v(" "),r("h2",{attrs:{id:"判断可触及性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断可触及性"}},[e._v("#")]),e._v(" 判断可触及性")]),e._v(" "),r("p",[e._v("垃圾回收的基本思想是考察每一个对象的可触及性，即从根节点开始是否可以访问到这个对象，如果可以，这说明当前对象正在被使用，如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，一般来说，此对象需要被回收。但事实上，一个无法触及的对象有可能在某一条件下 “复活自己”，如果这样那么对它的回收就是不合理的，为此，需要给除一个对象可触及对象的定义，并规定在什么状态下，才可以安全的回收对象。")]),e._v(" "),r("p",[e._v("无法触及的对象也可以在某一条件复活，需要定义对象的可触及性状态。")]),e._v(" "),r("ul",[r("li",[e._v("可触及的：从根节点开始，可以到达这个对象。")]),e._v(" "),r("li",[e._v("可复活的：对象引用都被释放，但是对象可能在 finalize()函数中复活。")]),e._v(" "),r("li",[e._v("不可触及的：对象 finalize()函数被调用，且未复活。")])]),e._v(" "),r("h4",{attrs:{id:"引用和可触及性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用和可触及性"}},[e._v("#")]),e._v(" 引用和可触及性")]),e._v(" "),r("h5",{attrs:{id:"强引用-对象是可触及的-不会被回收。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强引用-对象是可触及的-不会被回收。"}},[e._v("#")]),e._v(" 强引用：对象是可触及的，不会被回收。")]),e._v(" "),r("p",[e._v("特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。")]),e._v(" "),r("h5",{attrs:{id:"软引用-软可触及-内存不够就回收-softreference。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#软引用-软可触及-内存不够就回收-softreference。"}},[e._v("#")]),e._v(" 软引用：软可触及，内存不够就回收，SoftReference。")]),e._v(" "),r("p",[e._v("特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。")]),e._v(" "),r("h5",{attrs:{id:"弱引用-弱可触及-只要发现弱引用就会回收-weakreference。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#弱引用-弱可触及-只要发现弱引用就会回收-weakreference。"}},[e._v("#")]),e._v(" 弱引用：弱可触及，只要发现弱引用就会回收，WeakReference。")]),e._v(" "),r("p",[e._v("弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。")]),e._v(" "),r("h5",{attrs:{id:"虚引用-虚可触及-和没有引用几乎一样-作用是跟踪垃圾回收过程-phantomreference。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚引用-虚可触及-和没有引用几乎一样-作用是跟踪垃圾回收过程-phantomreference。"}},[e._v("#")]),e._v(" 虚引用：虚可触及，和没有引用几乎一样，作用是跟踪垃圾回收过程，PhantomReference。")]),e._v(" "),r("p",[e._v("特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。")]),e._v(" "),r("p",[e._v("​    ReferenceQueue queue = new ReferenceQueue ();")]),e._v(" "),r("p",[e._v("​    PhantomReference pr = new PhantomReference (object, queue);")]),e._v(" "),r("p",[e._v("​    程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。")]),e._v(" "),r("p",[e._v("​    应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。")]),e._v(" "),r("h2",{attrs:{id:"对象生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象生命周期"}},[e._v("#")]),e._v(" "),r("strong",[e._v("对象生命周期")])]),e._v(" "),r("p",[e._v("创建阶段(Created)")]),e._v(" "),r("p",[e._v("应用阶段(In Use)")]),e._v(" "),r("p",[e._v("不可见阶段(Invisible)")]),e._v(" "),r("p",[e._v("不可达阶段(Unreachable)")]),e._v(" "),r("p",[e._v("收集阶段(Collected)")]),e._v(" "),r("p",[e._v("终结阶段(Finalized)")]),e._v(" "),r("p",[e._v("对象空间重分配阶段(De-allocated)")])])}),[],!1,null,null,null);t.default=v.exports}}]);