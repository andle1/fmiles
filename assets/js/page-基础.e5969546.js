(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{521:function(a,s,t){a.exports=t.p+"assets/img/image-20220405214102872.57dab15a.png"},522:function(a,s,t){a.exports=t.p+"assets/img/v2-8655d85c8a9df1bc2262485248b07d4d_720w.b530433e.png"},523:function(a,s,t){a.exports=t.p+"assets/img/image-20220405220044994.4fc7c12c.png"},692:function(a,s,t){"use strict";t.r(s);var e=t(1),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),e("h3",{attrs:{id:"内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存模型"}},[a._v("#")]),a._v(" 内存模型")]),a._v(" "),e("p",[a._v("在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（就是可见性和有序性）。")]),a._v(" "),e("p",[a._v("在 java 中，所有实例域、静态域和数组元素存储在堆内存张中，堆内存在线程之间共享（这里使用“共享变量”这个词代表实例域、静态域和数组元素）。局部变量，方法定义参数和异常处理参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型影响。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(521),alt:"image-20220405214102872",loading:"lazy"}})]),a._v(" "),e("p",[a._v("注意：本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。")]),a._v(" "),e("h3",{attrs:{id:"重排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排序"}},[a._v("#")]),a._v(" 重排序")]),a._v(" "),e("p",[a._v("一般重排序可以分为如下三种类型：")]),a._v(" "),e("ul",[e("li",[a._v("编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。")]),a._v(" "),e("li",[a._v("指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。")]),a._v(" "),e("li",[a._v("内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。")])]),a._v(" "),e("blockquote",[e("p",[a._v("数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。")])]),a._v(" "),e("p",[a._v("从 Java 源代码到最终执行的指令序列，会分别经历下面三种重排序：")]),a._v(" "),e("p",[e("img",{attrs:{src:t(522),alt:"img",loading:"lazy"}})]),a._v(" "),e("h3",{attrs:{id:"内存屏障"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[a._v("#")]),a._v(" 内存屏障")]),a._v(" "),e("p",[a._v("为了保证内存的可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排。JMM 把内存屏障指令分为下列四类：")]),a._v(" "),e("p",[a._v("![preview](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\concurrent\\images\\v2-a992d2e50fc353edb9027683bf62ee2b_r.jpg?lastModify=1649166928)")]),a._v(" "),e("h3",{attrs:{id:"happens-before"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#happens-before"}},[a._v("#")]),a._v(" happens-before")]),a._v(" "),e("p",[a._v("从 JDK 5 开始，java使用新的 JSR-133 内存模型，JSR-133 中使用 happens-before 的概念阐述操作之间的内存可见性。")]),a._v(" "),e("p",[a._v("happens-before 规则如下：")]),a._v(" "),e("ul",[e("li",[a._v("程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。")]),a._v(" "),e("li",[a._v("监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。")]),a._v(" "),e("li",[a._v("volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。")]),a._v(" "),e("li",[a._v("传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。")]),a._v(" "),e("li",[a._v("start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。")]),a._v(" "),e("li",[a._v("join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。")])]),a._v(" "),e("p",[a._v("这里特别说明一下，happens-before 规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则。")]),a._v(" "),e("h2",{attrs:{id:"重排序-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排序-2"}},[a._v("#")]),a._v(" 重排序")]),a._v(" "),e("h3",{attrs:{id:"数据依赖性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据依赖性"}},[a._v("#")]),a._v(" 数据依赖性")]),a._v(" "),e("p",[a._v("如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就有数据依赖性。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(523),alt:"image-20220405220044994",loading:"lazy"}})]),a._v(" "),e("p",[a._v("上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。")]),a._v(" "),e("p",[a._v("前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。")]),a._v(" "),e("p",[a._v("注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。")]),a._v(" "),e("h3",{attrs:{id:"as-if-serial-语义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#as-if-serial-语义"}},[a._v("#")]),a._v(" as-if-serial 语义")]),a._v(" "),e("p",[a._v("as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。")]),a._v(" "),e("p",[a._v("为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。")]),a._v(" "),e("h2",{attrs:{id:"顺序一致性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#顺序一致性"}},[a._v("#")]),a._v(" 顺序一致性")]),a._v(" "),e("h3",{attrs:{id:"顺序一致性内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#顺序一致性内存模型"}},[a._v("#")]),a._v(" 顺序一致性内存模型")]),a._v(" "),e("p",[a._v("顺序一致性内存模型为程序员提供的视图如下：")]),a._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/4987a0c005023fbbab06293aa2c36da5.png",alt:"img"}}),a._v(" "),e("p",[a._v("在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读 / 写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 / 写操作串行化。")]),a._v(" "),e("p",[a._v("为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。")]),a._v(" "),e("p",[a._v("假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1->A2->A3。B 线程也有三个操作，它们在程序中的顺序是：B1->B2->B3。")]),a._v(" "),e("p",[a._v("假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://static001.infoq.cn/resource/image/a2/df/a2be3cbfb19fa8854510e708a65e31df.png",alt:"img",loading:"lazy"}})]),a._v(" "),e("p",[a._v("现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://static001.infoq.cn/resource/image/4f/13/4f5afaac60fff83522424ed5486f0d13.png",alt:"img",loading:"lazy"}})]),a._v(" "),e("h3",{attrs:{id:"同步程序的顺序一致性效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步程序的顺序一致性效果"}},[a._v("#")]),a._v(" 同步程序的顺序一致性效果")]),a._v(" "),e("p",[a._v("下面我们对前面的示例程序 ReorderExample 用监视器来同步，看看正确同步的程序如何具有顺序一致性。")]),a._v(" "),e("p",[a._v("请看下面的示例代码：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://static001.infoq.cn/resource/image/08/10/08b2577f293533447511fe3724ecbd10.png",alt:"img",loading:"lazy"}})]),a._v(" "),e("p",[a._v("在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。")]),a._v(" "),e("h2",{attrs:{id:"volatile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[a._v("#")]),a._v(" VOLATILE")]),a._v(" "),e("p",[a._v("当我们声明共享变量为 volatile 后，对这个变量的读 / 写将会很特别。理解 volatile 特性的一个好方法是：把对 volatile 变量的单个读 / 写，看成是使用同一个监视器锁对这些单个读 / 写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("VolatileFeaturesExample")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" vl "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0L")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用 volatile 声明 64 位的 long 型变量")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" l"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        vl "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" l"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 单个 volatile 变量的写")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" getAndIncrement "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        vl"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 复合（多个）volatile 变量的读 / 写")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" vl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 单个 volatile 变量的读")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br")])]),e("p",[a._v("假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("VolatileFeaturesExample")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" vl "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0L")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("               "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 64 位的 long 型普通变量")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" l"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("     "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 对单个的普通 变量的写用同一个监视器同步")]),a._v("\n        vl "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" l"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" getAndIncrement "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 普通方法调用")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" temp "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("           "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 调用已同步的读方法")]),a._v("\n        temp "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1L")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 普通写操作")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("temp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                   "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 调用已同步的写方法")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" \n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 对单个的普通变量的读用同一个监视器同步")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" vl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br"),e("span",{staticClass:"line-number"},[a._v("17")]),e("br")])]),e("p",[a._v("如上面示例程序所示，对一个 volatile 变量的单个读 / 写操作，与对一个普通变量的读 / 写操作使用同一个监视器锁来同步，它们之间的执行效果相同。")]),a._v(" "),e("p",[a._v("监视器锁的 happens-before 规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。")]),a._v(" "),e("p",[a._v("监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。")]),a._v(" "),e("p",[a._v("简而言之，volatile 变量自身具有下列特性：")]),a._v(" "),e("ul",[e("li",[a._v("可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。")]),a._v(" "),e("li",[a._v("原子性：对任意单个 volatile 变量的读 / 写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。")])]),a._v(" "),e("h3",{attrs:{id:"volatile-写-读建立的-happens-before-关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile-写-读建立的-happens-before-关系"}},[a._v("#")]),a._v(" volatile 写 - 读建立的 happens before 关系")]),a._v(" "),e("p",[a._v("从 JSR-133 开始，volatile 变量的写 - 读可以实现线程之间的通信。")]),a._v(" "),e("p",[a._v("从内存语义的角度来说，volatile 与监视器锁有相同的效果：volatile 写和监视器的释放有相同的内存语义；volatile 读与监视器的获取有相同的内存语义。锁？？")]),a._v(" "),e("p",[a._v("请看下面使用 volatile 变量的示例代码：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("VolatileExample")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" flag "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("writer")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        a "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                   "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//1")]),a._v("\n        flag "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("               "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//2")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("reader")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("flag"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("                "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//3")]),a._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("  a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("           "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//4")]),a._v("\n            ……\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br"),e("span",{staticClass:"line-number"},[a._v("16")]),e("br")])]),e("p",[a._v("假设线程 A 执行 writer() 方法之后，线程 B 执行 reader() 方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：")]),a._v(" "),e("ol",[e("li",[a._v("根据程序次序规则，1 happens before 2; 3 happens before 4。")]),a._v(" "),e("li",[a._v("根据 volatile 规则，2 happens before 3。")]),a._v(" "),e("li",[a._v("根据 happens before 的传递性规则，1 happens before 4。")])]),a._v(" "),e("p",[a._v("上述 happens before 关系的图形化表现形式如下：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://static001.infoq.cn/resource/image/31/5a/3104638509c2c1b898c5e249cb30065a.png",alt:"img",loading:"lazy"}})]),a._v(" "),e("p",[a._v("在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。")]),a._v(" "),e("p",[a._v("这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写 volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。")]),a._v(" "),e("h3",{attrs:{id:"volatile-写-读的内存语义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile-写-读的内存语义"}},[a._v("#")]),a._v(" volatile 写 - 读的内存语义")]),a._v(" "),e("p",[a._v("volatile 写的内存语义如下：")]),a._v(" "),e("ul",[e("li",[a._v("当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。")])]),a._v(" "),e("p",[a._v("以上面示例程序 VolatileExample 为例，假设线程 A 首先执行 writer() 方法，随后线程 B 执行 reader() 方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://static001.infoq.cn/resource/image/43/ea/43e1cc4e89fdfd06eaa1c74d54f538ea.png",alt:"img",loading:"lazy"}})]),a._v(" "),e("p",[a._v("如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。")]),a._v(" "),e("p",[a._v("volatile 读的内存语义如下：")]),a._v(" "),e("ul",[e("li",[a._v("当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。")])]),a._v(" "),e("p",[a._v("下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://static001.infoq.cn/resource/image/08/32/0804d2efc97e45360eab1f76f9962c32.png",alt:"img",loading:"lazy"}})]),a._v(" "),e("p",[a._v("如上图所示，在读 flag 变量后，本地内存 B 已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。")]),a._v(" "),e("p",[a._v("如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。")]),a._v(" "),e("p",[a._v("下面对 volatile 写和 volatile 读的内存语义做个总结：")]),a._v(" "),e("ul",[e("li",[a._v("线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。")]),a._v(" "),e("li",[a._v("线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。")]),a._v(" "),e("li",[a._v("线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。")])]),a._v(" "),e("h3",{attrs:{id:"volatile-内存语义的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile-内存语义的实现"}},[a._v("#")]),a._v(" volatile 内存语义的实现")]),a._v(" "),e("p",[a._v("下面，让我们来看看 JMM 如何实现 volatile 写 / 读的内存语义。")]),a._v(" "),e("p",[a._v("前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现 volatile 内存语义，JMM 会分别限制这两种类型的重排序类型。下面是 JMM 针对编译器制定的 volatile 重排序规则表：")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XAJq0GoNog70w9POicKfKJYRWOUyiaGicmHb2djKeIfUNOHOnWic7v3iaxrnKV8QlDCC9cQN9Jqt6q1f6g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片",loading:"lazy"}})]),a._v(" "),e("ul",[e("li",[a._v("第二个操作是volatile写时，第一个操作不管是什么，都不能重排序")]),a._v(" "),e("li",[a._v("第一个操作是volatile读时，第二个操作不管是什么，都不能重排序")]),a._v(" "),e("li",[a._v("第一个操作是volatile是写，第二个操作是volatile是读，不能重排序")])]),a._v(" "),e("p",[a._v("JMM内存屏障插入策略：（Load：加载（读）、Store：保存（写），屏障名称就可以看出读写的先后顺序）")]),a._v(" "),e("ul",[e("li",[a._v("在每个volatile写操作前插入StroreStore屏障")]),a._v(" "),e("li",[a._v("在每个volatile写操作前插入StroreLoad屏障")]),a._v(" "),e("li",[a._v("在每个volatile读操作前插入LoadLoad屏障")]),a._v(" "),e("li",[a._v("在每个volatile读操作前插入LoadStore屏障")])]),a._v(" "),e("h2",{attrs:{id:"锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[a._v("#")]),a._v(" 锁")]),a._v(" "),e("h2",{attrs:{id:"final"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#final"}},[a._v("#")]),a._v(" FINAL")])])}),[],!1,null,null,null);s.default=n.exports}}]);