(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{479:function(_,t,v){_.exports=v.p+"assets/img/image-20220330234043330.ed9657ff.png"},480:function(_,t,v){_.exports=v.p+"assets/img/image-20220401213440063.9fd104f2.png"},481:function(_,t,v){_.exports=v.p+"assets/img/20210121192523998.17842c30.png"},668:function(_,t,v){"use strict";v.r(t);var a=v(1),r=Object(a.a)({},(function(){var _=this,t=_.$createElement,a=_._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"基础相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础相关"}},[_._v("#")]),_._v(" 基础相关")]),_._v(" "),a("h4",{attrs:{id:"_1、非关系型数据库和关系型数据库的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、非关系型数据库和关系型数据库的区别"}},[_._v("#")]),_._v(" 1、非关系型数据库和关系型数据库的区别？")]),_._v(" "),a("p",[_._v("数据存储的方式区别，关系型数据库最典型的"),a("strong",[_._v("数据结构是表")]),_._v("，由"),a("strong",[_._v("二维表")]),_._v("及其"),a("strong",[_._v("之间的联系")]),_._v("所组成的一个数据组织。非关系型数据库特点是面向对象或者集合，可以是文档或者键值对等。")]),_._v(" "),a("h4",{attrs:{id:"_2、详细说一下一条-mysql-语句执行的步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、详细说一下一条-mysql-语句执行的步骤"}},[_._v("#")]),_._v(" 2、详细说一下一条 MySQL 语句执行的步骤")]),_._v(" "),a("p",[_._v("Server 层按顺序执行 SQL 的步骤为：")]),_._v(" "),a("ul",[a("li",[_._v("客户端请求 -> 连接器（验证用户身份，给予 权限）")]),_._v(" "),a("li",[_._v("查询缓存（存在缓存则直接返回，不存在则执行后续操作）")]),_._v(" "),a("li",[_._v("分析器（对 SQL 进行词法分析和语法分析操作）")]),_._v(" "),a("li",[_._v("优化器（主要对执行的 SQL 优化选择最优的执行方案方法）")]),_._v(" "),a("li",[_._v("执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-> 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）")])]),_._v(" "),a("h4",{attrs:{id:"_3、数据库三范式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、数据库三范式"}},[_._v("#")]),_._v(" 3、数据库三范式？")]),_._v(" "),a("p",[_._v("https://blog.csdn.net/qq_40899182/article/details/81706253")]),_._v(" "),a("p",[_._v("第一范式：确保每列保持原子性")]),_._v(" "),a("p",[_._v("第二范式：确保表中的每列都和主键有关 （主键列与非主键列遵循"),a("strong",[_._v("完全依赖关系")]),_._v("）")]),_._v(" "),a("p",[_._v("第三范式：确保每列都和主键列直接相关，而不是间接相关。（非主键列之间没有"),a("strong",[_._v("传递依赖关系")]),_._v("）")]),_._v(" "),a("p",[_._v("依赖：指的是表中某个字段的值B可以由另外一个字段A决定。")]),_._v(" "),a("p",[_._v("譬如：选择一个人姓名之后，可以确定性别，但是选择性别之后，不能确定姓名。")]),_._v(" "),a("p",[_._v("传递依赖：非主键直接 A -> B -> C")]),_._v(" "),a("p",[_._v("第二范式：每一行的数据只能与其中一列相关，即一行数据只作一件事。是要数据列中出现重复数据，就需要拆表。")]),_._v(" "),a("h4",{attrs:{id:"_4、mysql-数据库两种存储引擎的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、mysql-数据库两种存储引擎的区别"}},[_._v("#")]),_._v(" 4、MySQL 数据库两种存储引擎的区别?")]),_._v(" "),a("ol",[a("li",[a("strong",[_._v("是否支持行级锁")]),_._v(" : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。")]),_._v(" "),a("li",[a("strong",[_._v("是否支持事务和崩溃后的安全恢复： MyISAM")]),_._v(" 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是"),a("strong",[_._v("InnoDB")]),_._v(" 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。")]),_._v(" "),a("li",[a("strong",[_._v("是否支持外键：")]),_._v(" MyISAM不支持，而InnoDB支持。")]),_._v(" "),a("li",[a("strong",[_._v("是否支持MVCC")]),_._v(" ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 "),a("code",[_._v("READ COMMITTED")]),_._v(" 和 "),a("code",[_._v("REPEATABLE READ")]),_._v(" 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现")])]),_._v(" "),a("h2",{attrs:{id:"索引相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引相关"}},[_._v("#")]),_._v(" 索引相关")]),_._v(" "),a("h4",{attrs:{id:"_1、索引的三种常见底层数据结构以及优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、索引的三种常见底层数据结构以及优缺点"}},[_._v("#")]),_._v(" 1、索引的三种常见底层数据结构以及优缺点")]),_._v(" "),a("p",[_._v("三种常见的索引底层数据结构：分别是哈希表、有序数组和搜索树。")]),_._v(" "),a("ul",[a("li",[_._v("哈希表这种适用于等值查询的场景，比如 memcached 以及其它一些 NoSQL 引擎，不适合范围查询。")]),_._v(" "),a("li",[_._v("有序数组索引只适用于静态存储引擎，等值和范围查询性能好，但更新数据成本高。")]),_._v(" "),a("li",[_._v("N 叉树由于读写上的性能优点以及适配磁盘访问模式以及广泛应用在数据库引擎中。")])]),_._v(" "),a("p",[_._v("​        扩展（以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。）")]),_._v(" "),a("h4",{attrs:{id:"_2、索引的常见类型以及它是如何发挥作用的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、索引的常见类型以及它是如何发挥作用的"}},[_._v("#")]),_._v(" 2、索引的常见类型以及它是如何发挥作用的？")]),_._v(" "),a("p",[_._v("根据叶子节点的内容，索引类型分为主键索引和非主键索引。")]),_._v(" "),a("ul",[a("li",[_._v("主键索引的叶子节点存的整行数据，在InnoDB里也被称为聚簇索引。")]),_._v(" "),a("li",[_._v("非主键索引叶子节点存的主键的值，在InnoDB里也被称为二级索引。")])]),_._v(" "),a("h4",{attrs:{id:"_3、myisam-和-innodb-实现-b-树索引方式的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、myisam-和-innodb-实现-b-树索引方式的区别是什么"}},[_._v("#")]),_._v(" 3、MyISAM 和 InnoDB 实现 B 树索引方式的区别是什么？")]),_._v(" "),a("ul",[a("li",[_._v("InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身，其数据文件本身就是索引文件。")]),_._v(" "),a("li",[_._v("MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址，叶节点的 data 域存放的是数据记录的地址，索引文件和数据文件是分离的。")])]),_._v(" "),a("h4",{attrs:{id:"_4、innodb-为什么选择b-树索引-b-树做索引比红黑树好在哪里"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、innodb-为什么选择b-树索引-b-树做索引比红黑树好在哪里"}},[_._v("#")]),_._v(" 4、InnoDB 为什么选择B+ 树索引？B+树做索引比红黑树好在哪里？")]),_._v(" "),a("p",[_._v("两个考虑因素：")]),_._v(" "),a("ul",[a("li",[_._v("InnoDB 需要执行的场景和功能需要在特定查询上拥有较强的性能。")]),_._v(" "),a("li",[_._v("CPU 将磁盘上的数据加载到内存中需要花费大量时间。")])]),_._v(" "),a("p",[_._v("为什么选择 B+ 树：")]),_._v(" "),a("ul",[a("li",[_._v("哈希索引虽然能提供O（1）复杂度查询，但对范围查询和排序却无法很好的支持，最终会导致全表扫描。")]),_._v(" "),a("li",[_._v("B 树能够在非叶子节点存储数据，但会导致在查询连续数据可能带来更多的随机 IO。")]),_._v(" "),a("li",[_._v("而 B+ 树的所有叶节点可以通过指针来相互连接，减少顺序遍历带来的随机 IO。")])]),_._v(" "),a("p",[_._v("普通索引还是唯一索引？")]),_._v(" "),a("p",[_._v("由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发建议你优先考虑非唯一索引。")]),_._v(" "),a("p",[_._v("数据在磁盘等辅助存储设备中的情况（如MySQL等数据库），红黑树并不擅长，因为红黑树长得太高了。当数据在磁盘中时，磁盘IO会成为最大的性能瓶颈，设计的目标应该是尽量减少IO次数；而树的高度越高，增删改查所需要的IO次数也越多，会严重影响性能。")]),_._v(" "),a("h4",{attrs:{id:"_5、什么是覆盖索引和索引下推"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、什么是覆盖索引和索引下推"}},[_._v("#")]),_._v(" 5、什么是覆盖索引和索引下推？")]),_._v(" "),a("p",[_._v("覆盖索引：")]),_._v(" "),a("ul",[a("li",[_._v("在某个查询里面，索引 k 已经“覆盖了”我们的查询需求，称为覆盖索引。")]),_._v(" "),a("li",[_._v("覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。")])]),_._v(" "),a("p",[_._v("索引下推：")]),_._v(" "),a("ul",[a("li",[_._v("MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。")])]),_._v(" "),a("h4",{attrs:{id:"_6、哪些操作会导致索引失效"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、哪些操作会导致索引失效"}},[_._v("#")]),_._v(" 6、哪些操作会导致索引失效？")]),_._v(" "),a("p",[_._v("查询导致的：")]),_._v(" "),a("ul",[a("li",[_._v("对索引使用左或者左右模糊匹配，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。原因在于查询的结果可能是多个，不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。")]),_._v(" "),a("li",[_._v("WHERE 子句中的 OR语句，只要有条件列不是索引列，就会进行全表扫描。")])]),_._v(" "),a("p",[_._v("索引字段操作导致的：")]),_._v(" "),a("ul",[a("li",[_._v("对索引进行函数/对索引进行表达式计算，因为索引保持的是索引字段的原始值，而不是经过函数计算的值，自然就没办法走索引。")])]),_._v(" "),a("h4",{attrs:{id:"_7、字符串加索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、字符串加索引"}},[_._v("#")]),_._v(" 7、字符串加索引")]),_._v(" "),a("ul",[a("li",[_._v("直接创建完整索引，这样可能会比较占用空间。")]),_._v(" "),a("li",[_._v("创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引。")]),_._v(" "),a("li",[_._v("倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题。")]),_._v(" "),a("li",[_._v("创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。")])]),_._v(" "),a("h4",{attrs:{id:"_8、最左前缀匹配原则了解么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、最左前缀匹配原则了解么"}},[_._v("#")]),_._v(" 8、"),a("strong",[_._v("最左前缀匹配原则了解么？")])]),_._v(" "),a("p",[_._v("如果查询的时候查询条件精确匹配索引的左边连续一列或几列，那么索引就会生效。但是索引只能用于查找 key 是否存在（相等），遇到范围查询（> ,<,between, like 左匹配）等就不能进一步匹配了，后续退化为线性查找。如有索引（a、b、c、d）,查询条件 a= 1 and b = 2 and c >3 and d = 4，则会在每个节点依次命中 a、b、c,无法命中 d。")]),_._v(" "),a("p",[_._v("所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。")]),_._v(" "),a("h4",{attrs:{id:"_9、聚集索引和非聚集索引的区别-非聚集索引一定回表查询吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、聚集索引和非聚集索引的区别-非聚集索引一定回表查询吗"}},[_._v("#")]),_._v(" 9、聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?")]),_._v(" "),a("p",[_._v("非聚集索引的索引和行记录是分开存储的，聚集索引的索引和行记录是存储在一起的。")]),_._v(" "),a("p",[_._v("不一定回表查询，如果查的就是主键本身，那么就直接命中返回了。")]),_._v(" "),a("h4",{attrs:{id:"_10、索引这么多优点-为什么不对表中的每一个列创建一个索引呢-使用索引一定能提高查询性能吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、索引这么多优点-为什么不对表中的每一个列创建一个索引呢-使用索引一定能提高查询性能吗"}},[_._v("#")]),_._v(" 10、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗）?")]),_._v(" "),a("ol",[a("li",[_._v("当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。")]),_._v(" "),a("li",[_._v("索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。")]),_._v(" "),a("li",[_._v("创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。")])]),_._v(" "),a("h4",{attrs:{id:"页分裂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页分裂"}},[_._v("#")]),_._v(" 页分裂")]),_._v(" "),a("p",[_._v("有时候主键不是自增长的，有可能后一个数据页的主键值小于前一个数据页的主键值，为了保证顺序，有个交换数据的过程，这个过程就叫页分裂。")]),_._v(" "),a("p",[_._v("通过页分裂，让前后页数据顺序大小一致。这样就可以生成了主键目录，主键目录存在多个数据页中，这些数据页就称为索引页。再将多个索引页组建成 B+ 数结构，方便二分查找。")]),_._v(" "),a("p",[_._v("https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMDg2OTAxNg==&action=getalbum&album_id=1952926902587834371&scene=173&from_msgid=2652054938&from_itemidx=1&count=3&nolastread=1#wechat_redirect")]),_._v(" "),a("h4",{attrs:{id:"change-buffer-的作用-或者-change-buffer-怎么提高索引性能的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer-的作用-或者-change-buffer-怎么提高索引性能的"}},[_._v("#")]),_._v(" change buffer 的作用？或者 change buffer 怎么提高索引性能的？")]),_._v(" "),a("p",[_._v("当索引字段内容发生更新时（"),a("code",[_._v("update、insert、delete")]),_._v("），要更新对应的"),a("strong",[_._v("索引页")]),_._v("，如果"),a("strong",[_._v("索引页")]),_._v("在"),a("code",[_._v("Buffer Pool")]),_._v("里命中的话，就直接更新"),a("strong",[_._v("缓存页")]),_._v("。否则，"),a("code",[_._v("InnoDB")]),_._v("会将这些更新操作缓存在"),a("code",[_._v("change buffer")]),_._v("中，这样就无需从硬盘读入"),a("strong",[_._v("索引页")]),_._v("。下次查询索引页时，会将索引页读入"),a("code",[_._v("Buffer Pool")]),_._v("，然后将"),a("code",[_._v("change buffer")]),_._v("中的操作应用到对应的缓存页，得到最新结果，这个过程称为"),a("code",[_._v("merge")]),_._v("，通过这种方式就能保证数据逻辑的正确性。")]),_._v(" "),a("h2",{attrs:{id:"日志相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#日志相关"}},[_._v("#")]),_._v(" 日志相关")]),_._v(" "),a("h4",{attrs:{id:"mysql-是如何判断一行扫描数的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-是如何判断一行扫描数的"}},[_._v("#")]),_._v(" MySQL 是如何判断一行扫描数的？")]),_._v(" "),a("p",[_._v("MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条。而只能根据统计信息来估算记录数。这个统计信息就是索引的区分度。")]),_._v(" "),a("h4",{attrs:{id:"redolog-和-binlog-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redolog-和-binlog-的区别"}},[_._v("#")]),_._v(" RedoLog 和 BinLog 的区别？")]),_._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/j5D4MI5U9vWic0cyXPB6QagLWhusHiaeTiahdxDgxa75icSp14OicBjUkhu92MG4uyO8aicB9c4vU2RD2rxZCw0TM2fQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),_._v(" "),a("p",[_._v("保持一致是通过 redolog 两阶段提交实现。")]),_._v(" "),a("h4",{attrs:{id:"为什么需要-redo-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-redo-log"}},[_._v("#")]),_._v(" 为什么需要 redo log")]),_._v(" "),a("ul",[a("li",[_._v("当 buffer pool 中的 dirty page 还没有刷新到磁盘的时候，发生 crash，启动服务后，可通过redo log 找到需要重新刷新到磁盘文件的记录；")]),_._v(" "),a("li",[_._v("buffer pool中的数据直接刷到到磁盘，是一个随机IO，效率较差，而把 buffer pool 中的数据记录到redo log，是一个顺序IO，可以提高事务提交的速度；")])]),_._v(" "),a("h4",{attrs:{id:"_5、为什么-redo-log-具有-crash-safe-的能力-是-binlog-无法替代的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、为什么-redo-log-具有-crash-safe-的能力-是-binlog-无法替代的"}},[_._v("#")]),_._v(" 5、为什么 redo log 具有 crash-safe 的能力，是 binlog 无法替代的？")]),_._v(" "),a("p",[_._v("第一点：redo log 可确保 innoDB 判断哪些数据已经刷盘，哪些数据还没有")]),_._v(" "),a("ul",[a("li",[_._v("redo log 和 binlog 有一个很大的区别就是，一个是循环写，一个是追加写。也就是说 redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。")]),_._v(" "),a("li",[_._v("当数据库 crash 后，想要恢复"),a("strong",[_._v("未刷盘但已经写入 redo log 和 binlog 的数据")]),_._v("到内存时，binlog 是无法恢复的。虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有。")]),_._v(" "),a("li",[_._v("但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中抹掉，因为是循环写！数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。")])]),_._v(" "),a("p",[_._v("第二点：如果 redo log 写入失败，说明此次操作失败，事务也不可能提交")]),_._v(" "),a("ul",[a("li",[_._v("redo log 每次更新操作完成后，就一定会写入日志，如果"),a("strong",[_._v("写入失败")]),_._v("，说明此次操作失败，事务也不可能提交。")]),_._v(" "),a("li",[_._v("redo log 内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放，就可以恢复数据。")])]),_._v(" "),a("p",[_._v("这就是为什么 redo log 具有 crash-safe 的能力，而 binlog 不具备。")]),_._v(" "),a("h4",{attrs:{id:"_6、当数据库-crash-后-如何恢复未刷盘的数据到内存中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、当数据库-crash-后-如何恢复未刷盘的数据到内存中"}},[_._v("#")]),_._v(" 6、当数据库 crash 后，如何恢复未刷盘的数据到内存中？")]),_._v(" "),a("p",[_._v("根据 redo log 和 binlog 的两阶段提交，未持久化的数据分为几种情况：")]),_._v(" "),a("ul",[a("li",[_._v("redo log 虽然做了 fsync 但未 commit，binlog 未 fsync 到磁盘，这部分数据丢失。")]),_._v(" "),a("li",[_._v("redo log fsync 未 commit，binlog 已经 fsync 到磁盘，先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer。")]),_._v(" "),a("li",[_._v("redo log 和 binlog 都已经 fsync，直接从 redo log 里恢复。")])]),_._v(" "),a("h4",{attrs:{id:"_7、redo-log-写入方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、redo-log-写入方式"}},[_._v("#")]),_._v(" 7、redo log 写入方式？")]),_._v(" "),a("p",[_._v("redolog：概念、刷盘时机（三种）、日志文件组")]),_._v(" "),a("h4",{attrs:{id:"_8、redo-log-的执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、redo-log-的执行流程"}},[_._v("#")]),_._v(" 8、redo log 的执行流程?")]),_._v(" "),a("p",[_._v("我们来看下Redo log的执行流程，假设执行的 SQL 如下：")]),_._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[_._v("update T set a =1 where id =666\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br")])]),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/j5D4MI5U9vWic0cyXPB6QagLWhusHiaeTiacZCHZEvo8lFysyWtlicTV2vKgnfyHtHoicu9XrMGwoicAUlR7Way5t9wA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),_._v(" "),a("ol",[a("li",[_._v("MySQL 客户端将请求语句 update T set a =1 where id =666，发往 MySQL Server 层。")]),_._v(" "),a("li",[_._v("MySQL Server 层接收到 SQL 请求后，对其进行分析、优化、执行等处理工作，将生成的 SQL 执行计划发到 InnoDB 存储引擎层执行。")]),_._v(" "),a("li",[_._v("InnoDB 存储引擎层将"),a("strong",[_._v("a修改为1")]),_._v("的这个操作记录到内存中。")]),_._v(" "),a("li",[_._v("记录到内存以后会修改 redo log 的记录，会在添加一行记录，其内容是"),a("strong",[_._v("需要在哪个数据页上做什么修改")]),_._v("。")]),_._v(" "),a("li",[_._v("此后，将事务的状态设置为 prepare ，说明已经准备好提交事务了。")]),_._v(" "),a("li",[_._v("等到 MySQL Server 层处理完事务以后，会将事务的状态设置为 "),a("strong",[_._v("commit")]),_._v("，也就是提交该事务。")]),_._v(" "),a("li",[_._v("在收到事务提交的请求以后，"),a("strong",[_._v("redo log")]),_._v(" 会把刚才写入内存中的操作记录写入到磁盘中，从而完成整个日志的记录过程。")])]),_._v(" "),a("h4",{attrs:{id:"_9、redo-log-日志格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、redo-log-日志格式"}},[_._v("#")]),_._v(" 9、redo log 日志格式")]),_._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/j5D4MI5U9vWic0cyXPB6QagLWhusHiaeTiabNCFRPbHpV0DLsQxouYcAbrriaZjIrRIicNhMKNvM2tp4YTRDQOJ5vDw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),_._v(" "),a("p",[_._v("redo log buffer (内存中)是由首尾相连的四个文件组成的，它们分别是：ib_logfile_1、ib_logfile_2、ib_logfile_3、ib_logfile_4。")]),_._v(" "),a("ul",[a("li",[_._v("write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。")]),_._v(" "),a("li",[_._v("checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。")]),_._v(" "),a("li",[_._v("write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。")]),_._v(" "),a("li",[_._v("如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。")])]),_._v(" "),a("h4",{attrs:{id:"_10、什么是两阶段提交"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、什么是两阶段提交"}},[_._v("#")]),_._v(" 10、什么是两阶段提交？")]),_._v(" "),a("p",[_._v('MySQL 将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog，这就是"两阶段提交"。')]),_._v(" "),a("p",[_._v("具体的看博客自己理解。")]),_._v(" "),a("h4",{attrs:{id:"_11、mysql-怎么知道-binlog-是完整的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11、mysql-怎么知道-binlog-是完整的"}},[_._v("#")]),_._v(" 11、MySQL 怎么知道 binlog 是完整的?")]),_._v(" "),a("p",[_._v("一个事务的 binlog 是有完整格式的：")]),_._v(" "),a("ul",[a("li",[_._v("statement 格式的 binlog，最后会有 COMMIT；")]),_._v(" "),a("li",[_._v("row 格式的 binlog，最后会有一个 XID event。")])]),_._v(" "),a("h4",{attrs:{id:"_12、什么是-wal-技术-有什么优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12、什么是-wal-技术-有什么优点"}},[_._v("#")]),_._v(" 12、什么是 WAL 技术，有什么优点？")]),_._v(" "),a("p",[_._v("WAL，中文全称是 Write-Ahead Logging，它的关键点就是日志先写内存，再写磁盘。MySQL 执行更新操作后，"),a("strong",[_._v("在真正把数据写入到磁盘前，先记录日志")]),_._v("。")]),_._v(" "),a("p",[_._v("好处是不用每一次操作都实时把数据写盘，就算 crash 后也可以通过redo log 恢复，所以能够实现快速响应 SQL 语句。")]),_._v(" "),a("h4",{attrs:{id:"_13、binlog-日志的三种格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13、binlog-日志的三种格式"}},[_._v("#")]),_._v(" 13、binlog 日志的三种格式")]),_._v(" "),a("p",[_._v("binlog 日志有三种格式")]),_._v(" "),a("ul",[a("li",[_._v("Statement：基于SQL语句的复制 (statement-based replication,SBR)")]),_._v(" "),a("li",[_._v("Row：基于行的复制。(row-based replication,RBR)")]),_._v(" "),a("li",[_._v("Mixed：混合模式复制。(mixed-based replication,MBR)")])]),_._v(" "),a("p",[a("strong",[_._v("Statement格式")])]),_._v(" "),a("p",[_._v("每一条会修改数据的 SQL 都会记录在 binlog 中")]),_._v(" "),a("ul",[a("li",[_._v("优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。")]),_._v(" "),a("li",[_._v("缺点：由于记录的只是执行语句，为了这些语句能在备库上正确运行，还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在备库得到和在主库端执行时候相同的结果。")])]),_._v(" "),a("p",[a("strong",[_._v("Row格式")])]),_._v(" "),a("p",[_._v("不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。")]),_._v(" "),a("ul",[a("li",[_._v("优点：binlog 中可以不记录执行的 SQL 语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。不会出现某些特定情况下的存储过程、或 function、或trigger的调用和触发无法被正确复制的问题。")]),_._v(" "),a("li",[_._v("缺点:可能会产生大量的日志内容。")])]),_._v(" "),a("p",[a("strong",[_._v("Mixed格式")])]),_._v(" "),a("p",[_._v("实际上就是 Statement 与 Row 的结合。一般的语句修改使用 statment 格式保存 binlog，如一些函数，statement 无法完成主从复制的操作，则采用 row 格式保存 binlog，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式。")]),_._v(" "),a("h4",{attrs:{id:"_14、原本可以执行得很快的-sql-语句-执行速度却比预期的慢很多-原因是什么-如何解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14、原本可以执行得很快的-sql-语句-执行速度却比预期的慢很多-原因是什么-如何解决"}},[_._v("#")]),_._v(" 14、原本可以执行得很快的 SQL 语句，执行速度却比预期的慢很多，原因是什么？如何解决？")]),_._v(" "),a("p",[_._v("原因：从大到小可分为四种情况")]),_._v(" "),a("ul",[a("li",[_._v("MySQL 数据库本身被堵住了，比如：系统或网络资源不够。")]),_._v(" "),a("li",[_._v("SQL 语句被堵住了，比如：表锁，行锁等，导致存储引擎不执行对应的 SQL 语句。")]),_._v(" "),a("li",[_._v("确实是索引使用不当，没有走索引。")]),_._v(" "),a("li",[_._v("表中数据的特点导致的，走了索引，但回表次数庞大。")])]),_._v(" "),a("p",[_._v("解决：")]),_._v(" "),a("ul",[a("li",[_._v("考虑采用 force index 强行选择一个索引")]),_._v(" "),a("li",[_._v("考虑修改语句，引导 MySQL 使用我们期望的索引。比如把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。")]),_._v(" "),a("li",[_._v("第三种方法是，在有些场景下，可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。")]),_._v(" "),a("li",[_._v("如果确定是索引根本没必要，可以考虑删除索引。")])]),_._v(" "),a("h4",{attrs:{id:"_15、innodb-数据页结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15、innodb-数据页结构"}},[_._v("#")]),_._v(" 15、InnoDB 数据页结构")]),_._v(" "),a("p",[_._v("一个数据页大致划分七个部分")]),_._v(" "),a("ul",[a("li",[_._v("File Header：表示页的一些通用信息，占固定的38字节。")]),_._v(" "),a("li",[_._v("page Header：表示数据页专有信息，占固定的56字节。")]),_._v(" "),a("li",[_._v("inimum+Supermum：两个虚拟的伪记录，分别表示页中的最小记录和最大记录，占固定的26字节。")]),_._v(" "),a("li",[_._v("User Records：真正存储我们插入的数据，大小不固定。")]),_._v(" "),a("li",[_._v("Free Space：页中尚未使用的部分，大小不固定。")]),_._v(" "),a("li",[_._v("Page Directory：页中某些记录的相对位置，也就是各个槽对应的记录在页面中的地址偏移量。")]),_._v(" "),a("li",[_._v("File Trailer：用于检验页是否完整，占固定大小 8 字节。")])]),_._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170baaef96af956e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",alt:"img"}}),_._v(" "),a("h2",{attrs:{id:"数据相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据相关"}},[_._v("#")]),_._v(" 数据相关")]),_._v(" "),a("h4",{attrs:{id:"_1、在-mysql-中有两个-kill-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、在-mysql-中有两个-kill-命令"}},[_._v("#")]),_._v(" 1、在 MySQL 中有两个 kill 命令")]),_._v(" "),a("ul",[a("li",[_._v("一个是 kill query + 线程 id，表示终止这个线程中正在执行的语句")]),_._v(" "),a("li",[_._v("一个是 kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接")])]),_._v(" "),a("p",[_._v("kill 不掉的原因")]),_._v(" "),a("ul",[a("li",[_._v("kill命令被堵了，还没到位")]),_._v(" "),a("li",[_._v("kill命令到位了，但是没被立刻触发")]),_._v(" "),a("li",[_._v("kill命令被触发了，但执行完也需要时间")])]),_._v(" "),a("h4",{attrs:{id:"_2、如何理解-mysql-的边读边发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、如何理解-mysql-的边读边发"}},[_._v("#")]),_._v(" 2、如何理解 MySQL 的边读边发")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("如果客户端接受慢，会导致 MySQL 服务端由于结果发不出去，这个事务的执行时间会很长。")])]),_._v(" "),a("li",[a("p",[_._v("服务端并不需要保存一个完整的结果集，取数据和发数据的流程都是通过一个 net_buffer 来操作的。")])]),_._v(" "),a("li",[a("p",[_._v("内存的数据页都是在 Buffer_Pool 中操作的。")])]),_._v(" "),a("li",[a("p",[_._v("InnoDB 管理 Buffer_Pool 使用的是改进的 LRU 算法，使用链表实现，实现上，按照 7:3 的比例把整个 LRU 链表分成了 young 区域（热区域）和 old 区域（冷区域）。")])])]),_._v(" "),a("h4",{attrs:{id:"_3、mysql-的大表查询为什么不会爆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、mysql-的大表查询为什么不会爆内存"}},[_._v("#")]),_._v(" 3、MySQL 的大表查询为什么不会爆内存？")]),_._v(" "),a("ul",[a("li",[_._v("由于 MySQL 是边读变发，因此对于数据量很大的查询结果来说，不会再 server 端保存完整的结果集，所以，如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是不会把内存打爆。")]),_._v(" "),a("li",[_._v("InnoDB 引擎内部，由于有淘汰策略，InnoDB 管理 Buffer_Pool 使用的是改进的 LRU 算法，使用链表实现，实现上，按照 7:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。对冷数据的全扫描，影响也能做到可控制。")])]),_._v(" "),a("h4",{attrs:{id:"_4、mysql-临时表的用法和特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、mysql-临时表的用法和特性"}},[_._v("#")]),_._v(" 4、MySQL 临时表的用法和特性")]),_._v(" "),a("ul",[a("li",[_._v("只对当前session可见。")]),_._v(" "),a("li",[_._v("可以与普通表重名。")]),_._v(" "),a("li",[_._v("增删改查用的是临时表。")]),_._v(" "),a("li",[_._v("show tables 不显示普通表。")]),_._v(" "),a("li",[_._v("在实际应用中，临时表一般用于处理比较复杂的计算逻辑。")]),_._v(" "),a("li",[_._v("由于临时表是每个线程自己可见的，所以不需要考虑多个线程执行同一个处理时临时表的重名问题，在线程退出的时候，临时表会自动删除。")])]),_._v(" "),a("h4",{attrs:{id:"_5、如果数据库误操作-如何执行数据恢复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、如果数据库误操作-如何执行数据恢复"}},[_._v("#")]),_._v(" 5、如果数据库误操作, 如何执行数据恢复?")]),_._v(" "),a("p",[_._v("数据库在某个时候误操作，就可以找到距离误操作最近的时间节点的bin log，重放到临时数据库里，然后选择误删的数据节点，恢复到线上数据库。")]),_._v(" "),a("h2",{attrs:{id:"事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("#")]),_._v(" 事务")]),_._v(" "),a("h4",{attrs:{id:"_1、事务的四大特性了解么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、事务的四大特性了解么"}},[_._v("#")]),_._v(" 1、"),a("strong",[_._v("事务的四大特性了解么?")])]),_._v(" "),a("p",[_._v("事务是逻辑的上的一组操作，要么全部执行，要么都不执行。")]),_._v(" "),a("p",[_._v("原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；")]),_._v(" "),a("p",[_._v("一致性：执行事务后，数据库从一个正确的状态变化到另一个正确的状态；")]),_._v(" "),a("p",[_._v("隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；")]),_._v(" "),a("p",[_._v("持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。")]),_._v(" "),a("h4",{attrs:{id:"_2、并发事务带来哪些问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、并发事务带来哪些问题"}},[_._v("#")]),_._v(" 2、并发事务带来哪些问题？")]),_._v(" "),a("ul",[a("li",[a("p",[a("strong",[_._v("脏读（Dirty read）:")]),_._v(" 一个未commit 的事务读到了另一个事务未 commit 的数据。")])]),_._v(" "),a("li",[a("p",[a("strong",[_._v("丢失修改（Lost to modify）:")]),_._v(" 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。")])]),_._v(" "),a("li",[a("p",[a("strong",[_._v("不可重复读（Unrepeatableread）:")]),_._v(" 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。（一个事务在未 commit 之前读到了另一个事务 commit 的数据）")])]),_._v(" "),a("li",[a("p",[a("strong",[_._v("幻读（Phantom read）:")]),_._v(" 幻读和不可重复读一样，不可重复读是读异常，幻读是写异常。不可重复读是读异常的意思是，如果你不多 select几次，你是发现不了你曾经select过的数据行已经被其他人 update 过了。幻读是写异常的意思是，如果不自己 insert 一下，你是发现不了其他人已经偷偷 insert 过相同的数据了。（Mysql 通过 next-key lock 解决了 幻读）")])])]),_._v(" "),a("h4",{attrs:{id:"_3、mysql-事务隔离级别-默认是什么级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、mysql-事务隔离级别-默认是什么级别"}},[_._v("#")]),_._v(" 3、"),a("strong",[_._v("MySQL 事务隔离级别？默认是什么级别？")])]),_._v(" "),a("ul",[a("li",[a("strong",[_._v("READ-UNCOMMITTED(读取未提交)：")]),_._v(" 最低的隔离级别，允许读取尚未提交的数据变更，"),a("strong",[_._v("可能会导致脏读、幻读或不可重复读")]),_._v("。")]),_._v(" "),a("li",[a("strong",[_._v("READ-COMMITTED(读取已提交)：")]),_._v(" 允许读取并发事务已经提交的数据，"),a("strong",[_._v("可以阻止脏读，但是幻读或不可重复读仍有可能发生")]),_._v("。")]),_._v(" "),a("li",[a("strong",[_._v("REPEATABLE-READ(可重复读)：")]),_._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"),a("strong",[_._v("可以阻止脏读和不可重复读，但幻读仍有可能发生")]),_._v("。（Mysql InnoDB 不存在幻读问题，next-key lock 机制已经可以解决）")]),_._v(" "),a("li",[a("strong",[_._v("SERIALIZABLE(可串行化)：")]),_._v(" 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"),a("strong",[_._v("该级别可以防止脏读、不可重复读以及幻读")]),_._v("。")])]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("隔离级别")]),_._v(" "),a("th",[_._v("脏读")]),_._v(" "),a("th",[_._v("不可重复读")]),_._v(" "),a("th",[_._v("幻影读")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("READ-UNCOMMITTED")]),_._v(" "),a("td",[_._v("√")]),_._v(" "),a("td",[_._v("√")]),_._v(" "),a("td",[_._v("√")])]),_._v(" "),a("tr",[a("td",[_._v("READ-COMMITTED")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("√")]),_._v(" "),a("td",[_._v("√")])]),_._v(" "),a("tr",[a("td",[_._v("REPEATABLE-READ")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("√")])]),_._v(" "),a("tr",[a("td",[_._v("SERIALIZABLE")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")])])])]),_._v(" "),a("h4",{attrs:{id:"_4、mysql怎么保证acid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、mysql怎么保证acid"}},[_._v("#")]),_._v(" 4、MYSQL怎么保证ACID")]),_._v(" "),a("p",[_._v("https://www.cnblogs.com/CuiHongYu/p/10845354.html")]),_._v(" "),a("p",[_._v("1、"),a("em",[_._v("Mysql怎么保证一致性的？")])]),_._v(" "),a("p",[_._v("​     从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。")]),_._v(" "),a("p",[_._v("​     从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。")]),_._v(" "),a("p",[_._v("2、"),a("em",[_._v("Mysql怎么保证原子性的？")])]),_._v(" "),a("p",[_._v("利用Innodb的"),a("code",[_._v("undo log")]),_._v("。")]),_._v(" "),a("p",[a("code",[_._v("undo log")]),_._v("名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息")]),_._v(" "),a("h4",{attrs:{id:"mysql怎么保证持久性的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql怎么保证持久性的"}},[_._v("#")]),_._v(" Mysql怎么保证持久性的？")]),_._v(" "),a("p",[_._v("通过 redoLog ，宕机后可以通过 redolog 最终将数据刷盘。")]),_._v(" "),a("p",[_._v("4、"),a("em",[_._v("Mysql怎么保证隔离性的？")])]),_._v(" "),a("p",[_._v("事务间的读写靠MySQL的"),a("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E9%94%81%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[_._v("锁机制"),a("OutboundLink")],1),_._v("来保证隔离，事务间的写操作靠MVCC机制（快照读、当前读）来保证隔离性。")]),_._v(" "),a("h4",{attrs:{id:"_5、事务的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、事务的分类"}},[_._v("#")]),_._v(" 5、事务的分类")]),_._v(" "),a("p",[_._v("扁平事务：最基本是事务，由 Begin 开始，commit 或者 rollback 结束。")]),_._v(" "),a("p",[_._v("带有保存点的扁平事务：保存点用来通知系统应该记住事务的当前状态，当发生错误之后，事务能回到保存点当时的状态。")]),_._v(" "),a("p",[_._v("链事务：带有保存点的扁平事务的变种，带有保存点的扁平事务当系统发生奔溃时，所以保存点都会消失。")]),_._v(" "),a("p",[_._v("嵌套事务：由一个顶层事务控制着各个层次的事务。顶级事务之下嵌套的事务被称为子事务。")]),_._v(" "),a("p",[_._v("分布式事务")]),_._v(" "),a("h2",{attrs:{id:"锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[_._v("#")]),_._v(" 锁")]),_._v(" "),a("h4",{attrs:{id:"_1、行锁的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、行锁的类型"}},[_._v("#")]),_._v(" 1、行锁的类型")]),_._v(" "),a("p",[_._v("共享锁（s lock)：允许事务读一行数据")]),_._v(" "),a("p",[_._v("排他锁（x lock)：允许事务删除或更新一行数据")]),_._v(" "),a("p",[_._v("意向共享锁(IS Lock)：事务想要获得一张表中某几行的共享锁")]),_._v(" "),a("p",[_._v("意向排他锁(IX Lock)：事务想要获得一张表中某几行的排他锁")]),_._v(" "),a("p",[_._v("锁兼容，在事务 T1 获取了行 r 共享锁的时候，事务 T2 可以立即获得行 r 的共享锁。但是若有其他事务 T3 想获得行r 的排它锁，必读等待 T1，T2 释放行 r 的共享锁，这叫锁不兼容。")]),_._v(" "),a("p",[a("img",{attrs:{src:v(479),alt:"image-20220330234043330",loading:"lazy"}})]),_._v(" "),a("p",[a("img",{attrs:{src:v(480),alt:"image-20220401213440063",loading:"lazy"}})]),_._v(" "),a("h5",{attrs:{id:"补充-auto-inc-锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补充-auto-inc-锁"}},[_._v("#")]),_._v(" 补充：AUTO-INC 锁")]),_._v(" "),a("p",[_._v("自增主键的保障就是有 AUTO-INC 锁，是语句级别的：为表的某个列添加 AUTO_INCREMENT 属性，之后在插⼊记录时，可以不指定该列的值，系统会⾃动为它赋上单调递增的值。")]),_._v(" "),a("h4",{attrs:{id:"_2、innodb-行锁的-3-钟算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、innodb-行锁的-3-钟算法"}},[_._v("#")]),_._v(" 2、InnoDB 行锁的 3 钟算法")]),_._v(" "),a("ul",[a("li",[_._v("Record lock：记录锁，单个行记录上的锁")]),_._v(" "),a("li",[_._v("Gap lock：间隙锁，锁定一个范围，不包括记录本身")]),_._v(" "),a("li",[_._v("Next-key lock：record + gap 锁定一个范围，包含记录本身。")])]),_._v(" "),a("p",[_._v("当查询的索引含有唯一属性时，InnoDB 会降级 Next-key lock 为 Record。但是若查询的索引是唯一索引中的多个列的某一个列，则依旧使用 Next-key lock。")]),_._v(" "),a("p",[_._v("InnoDB 存储引擎默认的事务隔离级别是 RR，该隔离级别下，其采用的 Next-Key Locking 的方式来加锁。而在 RC 下，仅采用 Record lock 。故而在 RC 隔离级别下，锁定的是行，可以插入其他行，所以会出现不可重复度问题和幻读问题，而在 RR 下，因为是范围锁定，故而其他事务是无法读取或者插入的。")]),_._v(" "),a("h4",{attrs:{id:"_3、一致性非锁定读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、一致性非锁定读"}},[_._v("#")]),_._v(" 3、一致性非锁定读")]),_._v(" "),a("p",[_._v("指的是 InnoDB 通过多版本的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 INSERT 或 UPDATE 操作，这时读取操作不会因此去等待行上 x 锁的释放，会去读行的一个快照数据。")]),_._v(" "),a("p",[_._v("一个行记录可能不止一个快照数据，一般称这种技术为行多版本技术，由此带来的并发控制，称之为 "),a("code",[_._v("多版本并发控制")]),_._v("（MVCC）。")]),_._v(" "),a("p",[_._v("在事务默认的隔离级别 RR 和 RC 下，InnoDB 使用非锁定的一致性读。然而对于快照数据定义不同，在RC下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据，而在 RR 隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。")]),_._v(" "),a("p",[_._v("（注意，这里的快照数据就是 undolog 的记录。Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生Undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。）")]),_._v(" "),a("h5",{attrs:{id:"解释下为什么-rc-是最新快照数据-而rr-是事务开始时的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释下为什么-rc-是最新快照数据-而rr-是事务开始时的数据"}},[_._v("#")]),_._v(" 解释下为什么 RC 是最新快照数据？而RR 是事务开始时的数据？")]),_._v(" "),a("p",[_._v("现在存在两个事务 A，事务B。")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[_._v("时间")]),_._v(" "),a("th",{staticStyle:{"text-align":"center"}},[_._v("事务A")]),_._v(" "),a("th",{staticStyle:{"text-align":"center"}},[_._v("事务B")])])]),_._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v("BEGIN")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}})]),_._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("2")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v("select * from user where id = 1;")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}})]),_._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("3")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}}),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v("BEGIN")])]),_._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("4")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}}),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v('update use set name = "B" where id = 1;')])]),_._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("5")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v("select * from user where id = 1;")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}})]),_._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("6")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}}),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v("COMMIT;")])]),_._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("7")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v("select * from user where id = 1;")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}})]),_._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[_._v("8")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}},[_._v("COMMIT")]),_._v(" "),a("td",{staticStyle:{"text-align":"center"}})])])]),_._v(" "),a("p",[_._v("1、当一个事务开始的时候（"),a("em",[_._v("不包含开始本身这个事务")]),_._v("），会将当前数据库中正在活跃的事务（执行 begin 当没有 commit 的事务）保存到名为 trx_sys 的事务链表中，当事务提交后就会从其中删除。")]),_._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"images/999329-e836b86aa4cd7630.png",alt:"img"}}),_._v(" "),a("p",[_._v("2、同样，在一个事务开始的时候，会根据上面的事务链表构造为一个 ReadView（本质就是一个数据结构）。")]),_._v(" "),a("p",[_._v("3、当事务A 读取了 id = 1 的数据，事务B 更改完这条数据后。会生成一条 undolog 日志")]),_._v(" "),a("p",[a("img",{attrs:{src:v(481),alt:"在这里插入图片描述",loading:"lazy"}})]),_._v(" "),a("p",[_._v("​\t\t在 RR 隔离级别下，事务A 第一次查询生成 ReadView，当事务 A 第二次查询的时候，现查到的是 trx_id = 18 的那条数据，大于等于事务链表中的最大值 18 (数据行的DB_TRX_ID >= m_low_limit_id)，说明数据在中间被更改过，是不可见的，接着就会按照 roll_pointer 指针继续往下找。故而这时候事务 A 能读取到的还是之前的值，即 RR 是事务开始的数据。")]),_._v(" "),a("p",[_._v("​\t\t在 RC 隔离级别下，事务 B commit 之后，事务A执行查询的时候，生成了新的 ReadView，又因为这时候没有任何一个事务在执行，所以事务链表是空的，所以是可见的。故而能查事务B 提交的数据，即 RC 是最新的快照数据。")]),_._v(" "),a("h4",{attrs:{id:"_4、乐观锁与悲观锁的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、乐观锁与悲观锁的区别"}},[_._v("#")]),_._v(" 4、"),a("strong",[_._v("乐观锁与悲观锁的区别?")])]),_._v(" "),a("p",[_._v("乐观锁：事务认为一定不会出现丢失更新。 添加一个额外的字段，譬如版本号之类的。")]),_._v(" "),a("p",[_._v("悲观锁：事务认为一定会出现丢失更新。利用数据的锁机制，排他锁，可以在查询的时候加入 for update。")]),_._v(" "),a("h4",{attrs:{id:"_5、数据库死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、数据库死锁"}},[_._v("#")]),_._v(" 5、数据库死锁")]),_._v(" "),a("p",[_._v("第一种：事务之间对资源访问顺序的交替")]),_._v(" "),a("p",[_._v("由于两个事务分别持有了一个行锁，分别等待对方释放所持有的行锁，因此导致了死锁")]),_._v(" "),a("p",[_._v("解决办法：调整程序的逻辑。")]),_._v(" "),a("p",[_._v("第二种：并发修改同一条记录")]),_._v(" "),a("p",[_._v("用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项目中经常发生。")]),_._v(" "),a("p",[_._v("解决办法：")]),_._v(" "),a("p",[_._v("a.乐观锁。")]),_._v(" "),a("p",[_._v("b.悲观锁。查询加 for update，但是数据库性能开销很大。")]),_._v(" "),a("h2",{attrs:{id:"主从备份相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从备份相关"}},[_._v("#")]),_._v(" 主从备份相关")]),_._v(" "),a("h4",{attrs:{id:"_1、主备同步的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、主备同步的实现原理"}},[_._v("#")]),_._v(" 1、主备同步的实现原理")]),_._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/56b908c82863817d01b220562dbb1f2328c2e5eb",alt:"主备同步流程图"}}),_._v(" "),a("p",[_._v("上图是一个update语句在节点A执行，然后同步到节点B的完整流程图，具体步骤有：")]),_._v(" "),a("ol",[a("li",[_._v("主库接受到客户端发送的一条update语句，执行内部事务逻辑，同时写binlog。")]),_._v(" "),a("li",[_._v("备库通过 change master 命令，设置主库的IP、端口、用户名和密码，以及要从哪个位置开始请求 binlog。这个位置包含文件名和偏移量。")]),_._v(" "),a("li",[_._v("在备库上执行start slave命令，启动两个线程 io_thread 和 sql_thread，其中 io_thread 负责与主机进行连接。")]),_._v(" "),a("li",[_._v("主库校验完用户名和密码，按照接收到的位置去读取binlog，发给备库。")]),_._v(" "),a("li",[_._v("备库接收到binlog后，写到本地文件（relay log，中转文件）。")]),_._v(" "),a("li",[_._v("备库读取中转文件，解析出命令，然后执行。")])]),_._v(" "),a("p",[_._v("主备同步的工作原理其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上是实时的。")]),_._v(" "),a("p",[_._v("备库通过两个线程来实现同步：")]),_._v(" "),a("ul",[a("li",[_._v("一个是 I/O 线程，负责读取主库的二进制日志，并将其保存为中继日志。")]),_._v(" "),a("li",[_._v("一个是 SQL 线程，负责执行中继日志。")])]),_._v(" "),a("h4",{attrs:{id:"_2、什么是主备延迟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、什么是主备延迟"}},[_._v("#")]),_._v(" 2、什么是主备延迟")]),_._v(" "),a("p",[_._v("主库和备库在执行同一个事务的时候出现时间差的问题，主要原因有：")]),_._v(" "),a("ul",[a("li",[_._v("有些部署条件下，备库所在机器的性能要比主库性能差。")]),_._v(" "),a("li",[_._v("备库的压力较大。")]),_._v(" "),a("li",[_._v("大事务，一个主库上语句执行10分钟，那么这个事务可能会导致从库延迟10分钟。")])]),_._v(" "),a("h4",{attrs:{id:"_3、为什么要有多线程复制策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、为什么要有多线程复制策略"}},[_._v("#")]),_._v(" 3、为什么要有多线程复制策略？")]),_._v(" "),a("ul",[a("li",[_._v("因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库可能是一直追不上主库的，带来的现象就是备库上seconds_behind_master值越来越大。")]),_._v(" "),a("li",[_._v("在实际应用中，建议使用可靠性优先策略，减少主备延迟，提升系统可用性，尽量减少大事务操作，把大事务拆分小事务。")])]),_._v(" "),a("h4",{attrs:{id:"_4、mysql-的并行策略有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、mysql-的并行策略有哪些"}},[_._v("#")]),_._v(" 4、MySQL 的并行策略有哪些？")]),_._v(" "),a("ul",[a("li",[_._v("按表分发策略：如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。缺点：如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。")]),_._v(" "),a("li",[_._v("按行分发策略：如果两个事务没有更新相同的行，它们在备库上可以并行。显然，这个模式要求 binlog 格式必须是 row。缺点：相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。")])]),_._v(" "),a("h4",{attrs:{id:"_5、mysql的一主一备和一主多从有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、mysql的一主一备和一主多从有什么区别"}},[_._v("#")]),_._v(" 5、MySQL的一主一备和一主多从有什么区别？")]),_._v(" "),a("p",[_._v("在一主一备的双 M 架构里，两台机器都是互为主备关系，主备切换只需要把客户端流量切到备库；")]),_._v(" "),a("p",[_._v("而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。")]),_._v(" "),a("h5",{attrs:{id:"补充-双-m-架构循环复制问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补充-双-m-架构循环复制问题"}},[_._v("#")]),_._v(" 补充：双 M 架构循环复制问题")]),_._v(" "),a("ul",[a("li",[_._v("设置节点的server-id，必须不同，不然不允许设置为主备结构")]),_._v(" "),a("li",[_._v("备库在接到binlog后重放时，会记录原记录相同的server-id，即谁产生即为谁的。")]),_._v(" "),a("li",[_._v("每个节点在接受binlog时，会判断server-id，如果是自己的就丢掉。")])]),_._v(" "),a("p",[_._v("https://www.cnblogs.com/liang24/p/14149412.html")]),_._v(" "),a("h2",{attrs:{id:"性能相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能相关"}},[_._v("#")]),_._v(" 性能相关")]),_._v(" "),a("h4",{attrs:{id:"_1、短时间提高-mysql-性能的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、短时间提高-mysql-性能的方法"}},[_._v("#")]),_._v(" 1、短时间提高 MySQL 性能的方法")]),_._v(" "),a("ul",[a("li",[_._v("第一种方法：先处理掉那些占着连接但是不工作的线程。或者再考虑断开事务内空闲太久的连接。kill connection + id")]),_._v(" "),a("li",[_._v("第二种方法：减少连接过程的消耗：慢查询性能问题在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能：索引没有设计好；SQL 语句没写好；MySQL 选错了索引（force index）。")])]),_._v(" "),a("h4",{attrs:{id:"_2、为什么-mysql-自增主键-id-不连续"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、为什么-mysql-自增主键-id-不连续"}},[_._v("#")]),_._v(" 2、为什么 MySQL 自增主键 ID 不连续？")]),_._v(" "),a("ul",[a("li",[_._v("唯一键冲突")]),_._v(" "),a("li",[_._v("事务回滚")]),_._v(" "),a("li",[_._v("自增主键的批量申请")])]),_._v(" "),a("p",[_._v("深层次原因是：MySQL 不判断自增主键是否存在，从而减少加锁的时间范围和粒度，这样能保持更高的性能，确保自增主键不能回退，所以才有自增主键不连续。")]),_._v(" "),a("p",[_._v("自增主键怎么做到唯一性？自增值加1来通过自增锁控制并发。‘")]),_._v(" "),a("h5",{attrs:{id:"解释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释"}},[_._v("#")]),_._v(" 解释：")]),_._v(" "),a("p",[_._v("唯一键冲突：\n假设执行 SQL 的时候 user 表 id = 10，此时在内存中的自增 id 为11，此时发生唯一键冲突写库失败，则 user 表没有 id = 10 这条记录，之后 id 从11开始写入，因此 id 是不连续的。")]),_._v(" "),a("p",[_._v("事务回滚：\n假设同时需要对 user、staff 表进行写库操作，执行 SQL 的时候 user 表 id = 10，此时在内存中的自增 id 为11；staff 表 id = 20，此时内存中的自增 id 为21，一旦事务执行失败，事务回滚，写库失败，则 user 表没有 id = 10 这条记录，staff 表没有 id = 20 这条记录，user 表从11开始写入，staff 表从21开始写入，如此产生 id 不连续的现象。")]),_._v(" "),a("p",[_._v("批量写库操作：\n对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：")]),_._v(" "),a("ol",[a("li",[a("p",[_._v("语句执行过程中，第一次申请自增 id，会分配 1 个；")])]),_._v(" "),a("li",[a("p",[_._v("1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；")])]),_._v(" "),a("li",[a("p",[_._v("2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；")]),_._v(" "),a("p",[_._v("依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。")]),_._v(" "),a("p",[_._v("假设批量往 user 表中写入四条记录，则这四条记录将分为三次申请id，")]),_._v(" "),a("p",[_._v("第一次分配到 id = 1，第二次分配到 id = 2、3 ，第三次分配到 id = 4、5、6、7，当批量写入四条记录之后，id = 1、2、3、4将会入库，但是 id = 5、6、7就被废弃了，下一个 id 从8开始。")])])]),_._v(" "),a("h4",{attrs:{id:"_3、innodb-为什么要用自增-id-作为主键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、innodb-为什么要用自增-id-作为主键"}},[_._v("#")]),_._v(" 3、InnoDB 为什么要用自增 ID 作为主键？")]),_._v(" "),a("ul",[a("li",[_._v("自增主键的插入模式，符合递增插入，每次都是追加操作，不涉及挪动记录，也不会触发叶子节点的分裂。")]),_._v(" "),a("li",[_._v("每次插入新的记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。")]),_._v(" "),a("li",[_._v("而有业务逻辑的字段做主键，不容易保证有序插入，由于每次插入主键的值近似于随机。因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，写数据成本较高。")])]),_._v(" "),a("h4",{attrs:{id:"_4、mysql-有哪些自增id-各自场景是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、mysql-有哪些自增id-各自场景是什么"}},[_._v("#")]),_._v(" 4、MySQL 有哪些自增ID？各自场景是什么？")]),_._v(" "),a("ul",[a("li",[_._v("表的自增 ID 达到上限之后，在申请值不会变化，进而导致联系插入数据的时候报主键冲突错误。")]),_._v(" "),a("li",[_._v("row_id：达到上限之后，归 0 在重新递增，如果出现相同的 row_id 后写的数据会覆盖之前的数据。")]),_._v(" "),a("li",[_._v("Xid：看下面5。只需要不在同一个 binlog 文件出现重复值即可，理论上会出现重复值，但概率极小可忽略不计。")]),_._v(" "),a("li",[_._v("max_trx_id：InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。递增值每次 MySQL 重启会保存起来。")]),_._v(" "),a("li",[_._v("thread_id：系统保存了一个环境变量"),a("strong",[_._v("thread_id_counter")]),_._v(" 每新建一个连接，就将"),a("strong",[_._v("thread_id_counter")]),_._v("赋值给这个"),a("strong",[_._v("新连接的线程变量")]),_._v("。使用了insert_unique算法。")])]),_._v(" "),a("p",[_._v("https://blog.csdn.net/u013487071/article/details/123429195")]),_._v(" "),a("h4",{attrs:{id:"_5、xid-在-mysql-内部是怎么生成的呢-xid-和-trx-id-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、xid-在-mysql-内部是怎么生成的呢-xid-和-trx-id-区别"}},[_._v("#")]),_._v(" 5、Xid 在 MySQL 内部是怎么生成的呢？xid 和 trx_id 区别？")]),_._v(" "),a("p",[_._v("Xid 是由 server 层维护的。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。")]),_._v(" "),a("p",[_._v("MySQL 内部维护了一个全局变量 global_query_id，每次执行语句（包括select语句）的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。")]),_._v(" "),a("p",[_._v("而 global_query_id 是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是惟一的。")]),_._v(" "),a("h5",{attrs:{id:"xid-存在的意义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xid-存在的意义"}},[_._v("#")]),_._v(" xid 存在的意义：")]),_._v(" "),a("p",[_._v("redo log 和 binlog 有一个共同的数据字段，叫 XID，崩溃恢复的时候，会按顺序扫描 redo log：")]),_._v(" "),a("p",[_._v("如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；\n如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。")]),_._v(" "),a("h5",{attrs:{id:"trx-id-存在的意义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trx-id-存在的意义"}},[_._v("#")]),_._v(" trx_id 存在的意义：")]),_._v(" "),a("p",[_._v("每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比")]),_._v(" "),a("h2",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[_._v("#")]),_._v(" 其他")]),_._v(" "),a("h4",{attrs:{id:"_1、orderby-排序内部原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、orderby-排序内部原理"}},[_._v("#")]),_._v(" 1、orderby 排序内部原理")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("MySQL 会为每个线程分配一个内存（sort-buffer）用于排序，该内存大小为 sort_buffer_size；")])]),_._v(" "),a("li",[a("p",[_._v("如果排序的数据量小于 sort_buffer_size，排序就会在内存中完成；")])])]),_._v(" "),a("h5",{attrs:{id:"内部排序分为两种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部排序分为两种"}},[_._v("#")]),_._v(" 内部排序分为两种：")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("全字段排序：到索引树上找到满足条件的主键ID根据主键ID去取出数据放到 sort_buffer 然后进行快速排序")])]),_._v(" "),a("li",[a("p",[_._v("rowid排序：通过控制排序的行数据的长度来让 sort_buffer 中尽可能多的存放数据")])])]),_._v(" "),a("p",[_._v("如果数据量很大，内存中无法存下这么多，就会使用磁盘临时文件来辅助排序，称为外部排序；外部排序，MySQL会分为好几份单独的临时文件来存放排序后的数据，一般是磁盘文件中进行归并，然后将这些文件合并成一个大文件；")]),_._v(" "),a("h4",{attrs:{id:"_2、count-实现方式以及各种-count-对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、count-实现方式以及各种-count-对比"}},[_._v("#")]),_._v(" 2、count(*)实现方式以及各种 count 对比")]),_._v(" "),a("ul",[a("li",[_._v("对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。")]),_._v(" "),a("li",[_._v("对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。")]),_._v(" "),a("li",[_._v("对于 count(字段) 来说：如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。")]),_._v(" "),a("li",[_._v("但是 count * 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。")])]),_._v(" "),a("p",[_._v("所以结论是：按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(※)，所以建议尽量使用 count(*)。")]),_._v(" "),a("h2",{attrs:{id:"文章系列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文章系列"}},[_._v("#")]),_._v(" 文章系列")]),_._v(" "),a("p",[_._v("biglog：概念、记录格式、写入机制")]),_._v(" "),a("p",[_._v("bufferPool：缓存页、描述数据、Free 链表、缓存页哈希表、Flush链表、LRU链表、LRU链表优化")]),_._v(" "),a("p",[_._v("数据页变为索引：页分裂、主键目录、索引页")]),_._v(" "),a("p",[_._v("https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMDg2OTAxNg==&action=getalbum&album_id=1952926902587834371&scene=173&from_msgid=2652054938&from_itemidx=1&count=3&nolastread=1#wechat_redirect")])])}),[],!1,null,null,null);t.default=r.exports}}]);