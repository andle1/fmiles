(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{517:function(t,a,s){t.exports=s.p+"assets/img/2019063014391960.7b98f815.png"},690:function(t,a,s){"use strict";s.r(a);var n=s(1),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"核心思想"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#核心思想"}},[t._v("#")]),t._v(" 核心思想")]),t._v(" "),n("p",[t._v("CAS(A,V,B)。当前值 A，内存值 V，要修改的新值 B。如果当前值 A = V，那么就将内存值 V 改成 B。")]),t._v(" "),n("p",[t._v("CAS 操作总是抱着乐观的态度的，它总是认为自己可以成功完成操作。当多个线程同时操作一个变量时，只有一个会胜出并成功更新，其余均会失败，失败的线程不会挂起，仅是被告知失败，并且云允许再次尝试。")]),t._v(" "),n("h2",{attrs:{id:"原子操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原子操作"}},[t._v("#")]),t._v(" 原子操作")]),t._v(" "),n("p",[t._v("为了能让 CAS 操作被 Java 应用程序充分使用，在 JDK 的 java.util.concurrent.atomic 包下，有一组使用无锁算法实现的原子操作类。")]),t._v(" "),n("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/image-20220404195924674.png",alt:"image-20220404195924674"}}),t._v(" "),n("p",[t._v("利用CPU的 CAS 指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而"),n("strong",[t._v("整个J.U.C都是建立在CAS之上的")]),t._v("，因此相比synchronized阻塞算法，J.U.C在性能上有了很大的提升。")]),t._v(" "),n("p",[t._v("以 AtomicInteger 为 getAndSet() 方法为例，看下 CAS 算法如何工作的：")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAndSet")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newValue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAndSetInt")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" valueOffset"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newValue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br")])]),n("p",[t._v("调用的是 unsafe 类的 getAndSetInt() 方法")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAndSetInt")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" o"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" offset"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newValue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        v "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getIntVolatile")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" offset"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSwapInt")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" offset"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newValue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br")])]),n("p",[t._v("UnSafe 类是 CAS 的核心类由于 Java 方法无法直接访问底层，需要通过本地(native)方法来访问，基于该类可以直接操作特额定的内存数据.UnSafe类在于 sun.misc 包中，其内部方法操作可以向 C 的指针一样直接操作内存,因为 Java 中 CAS 操作的助兴依赖于 UNSafe 类的方法。")]),t._v(" "),n("h2",{attrs:{id:"cas-存在的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cas-存在的问题"}},[t._v("#")]),t._v(" CAS 存在的问题")]),t._v(" "),n("h3",{attrs:{id:"_1、aba-问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、aba-问题"}},[t._v("#")]),t._v(" 1、ABA 问题")]),t._v(" "),n("ul",[n("li",[t._v("描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。")]),t._v(" "),n("li",[t._v("例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！")])]),t._v(" "),n("h5",{attrs:{id:"解决办法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[t._v("#")]),t._v(" 解决办法：")]),t._v(" "),n("p",[t._v("JDK1.5 可以利用 AtomicStampedReference 类来解决这个问题，AtomicStampedReference 内部不仅维护了对象值，还维护了一个时间戳。当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳，对象值和时间戳都必须满足期望值，写入才会成功")]),t._v(" "),n("h3",{attrs:{id:"_2、循环时间长开销大-这里应该是自旋锁的问题-自旋锁和-cas-是两种东西"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、循环时间长开销大-这里应该是自旋锁的问题-自旋锁和-cas-是两种东西"}},[t._v("#")]),t._v(" "),n("strong",[t._v("2、循环时间长开销大")]),t._v("（这里应该是自旋锁的问题？自旋锁和 CAS 是两种东西）")]),t._v(" "),n("p",[t._v("因为CAS 经常和自旋锁一起使用。看上面的 getAndSetInt() 法方法可知，自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。")]),t._v(" "),n("p",[t._v("解决办法：JVM支持处理器提供的pause指令，使得效率会有一定的提升，pause指令有两个作用：")]),t._v(" "),n("p",[t._v("第一它可以延迟流水线执行指令,使CPU不会消耗过多的执行资源，\n第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。")]),t._v(" "),n("h3",{attrs:{id:"_3、不能保证多个共享变量的原子操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、不能保证多个共享变量的原子操作"}},[t._v("#")]),t._v(" 3、不能保证多个共享变量的原子操作")]),t._v(" "),n("p",[t._v("问题描述：当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。")]),t._v(" "),n("p",[t._v("解决办法：从Java1.5 开始JDK提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。")]),t._v(" "),n("h2",{attrs:{id:"concurrent-包的实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-包的实现"}},[t._v("#")]),t._v(" concurrent 包的实现")]),t._v(" "),n("p",[t._v("由于 java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面四种方式：")]),t._v(" "),n("ul",[n("li",[t._v("A线程写 volatile 变量，随后 B 线程读这个 volatile 变量。")]),t._v(" "),n("li",[t._v("A线程写 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。")]),t._v(" "),n("li",[t._v("A线程用 CAS 更新一个 volatile 变量，随后 B 线程读这个 volatile 变量。")]),t._v(" "),n("li",[t._v("A线程用 CAS 更新一个 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。")])]),t._v(" "),n("p",[t._v("Java 的 CAS 会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile 变量的读/写和 CAS 可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent 包得以实现的基石。如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：")]),t._v(" "),n("ul",[n("li",[t._v("首先，声明共享变量为 volatile；")]),t._v(" "),n("li",[t._v("然后，使用 CAS 的原子条件更新来实现线程之间的同步；")]),t._v(" "),n("li",[t._v("同时，配合以 volatile 的读/写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。")])]),t._v(" "),n("p",[n("strong",[t._v("AQS")]),t._v("，"),n("strong",[t._v("非阻塞数据结构")]),t._v("和"),n("strong",[t._v("原子变量类")]),t._v("（java.util.concurrent.atomic包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(517),alt:"img",loading:"lazy"}})]),t._v(" "),n("p",[t._v("注：AQS（AbstractQueuedSynchronizer抽象队列同步器），提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架。")]),t._v(" "),n("p",[t._v("https://blog.csdn.net/lixinkuan328/article/details/94319775")])])}),[],!1,null,null,null);a.default=e.exports}}]);