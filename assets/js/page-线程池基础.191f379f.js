(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{528:function(o,e,v){o.exports=v.p+"assets/img/4134622-fbbdbcb6bcc00178.a2c6d8f3.png"},701:function(o,e,v){"use strict";v.r(e);var _=v(1),r=Object(_.a)({},(function(){var o=this,e=o.$createElement,_=o._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[_("h2",{attrs:{id:"线程池工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程池工作原理"}},[o._v("#")]),o._v(" 线程池工作原理")]),o._v(" "),_("p",[_("img",{attrs:{src:v(528),alt:"img",loading:"lazy"}})]),o._v(" "),_("p",[_("strong",[_("code",[o._v("ThreadPoolExecutor")]),o._v(" 3 个最重要的参数：")])]),o._v(" "),_("ul",[_("li",[_("strong",[_("code",[o._v("corePoolSize")]),o._v(" :")]),o._v(" 核心线程数定义了最小可以同时运行的线程数量。")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("maximumPoolSize")]),o._v(" :")]),o._v(" 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("workQueue")]),o._v(":")]),o._v(" 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。")])]),o._v(" "),_("p",[_("code",[o._v("ThreadPoolExecutor")]),o._v("其他常见参数:")]),o._v(" "),_("ol",[_("li",[_("strong",[_("code",[o._v("keepAliveTime")])]),o._v(":当线程池中的线程数量大于 "),_("code",[o._v("corePoolSize")]),o._v(" 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 "),_("code",[o._v("keepAliveTime")]),o._v("才会被回收销毁；")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("unit")])]),o._v(" : "),_("code",[o._v("keepAliveTime")]),o._v(" 参数的时间单位。")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("threadFactory")])]),o._v(" :executor 创建新线程的时候会用到。")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("handler")])]),o._v(" :饱和策略。关于饱和策略下面单独介绍一下。")])]),o._v(" "),_("h4",{attrs:{id:"threadpoolexecutor-饱和策略定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#threadpoolexecutor-饱和策略定义"}},[o._v("#")]),o._v(" "),_("strong",[_("code",[o._v("ThreadPoolExecutor")]),o._v(" 饱和策略定义:")])]),o._v(" "),_("p",[o._v("如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，"),_("code",[o._v("ThreadPoolTaskExecutor")]),o._v(" 定义一些策略")]),o._v(" "),_("ul",[_("li",[_("strong",[_("code",[o._v("ThreadPoolExecutor.AbortPolicy")]),o._v("：")]),o._v(" 抛出 "),_("code",[o._v("RejectedExecutionException")]),o._v("来拒绝新任务的处理。")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("ThreadPoolExecutor.CallerRunsPolicy")]),o._v("：")]),o._v(" 调用执行自己的线程运行任务，也就是直接在调用"),_("code",[o._v("execute")]),o._v("方法的线程中运行("),_("code",[o._v("run")]),o._v(")被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("ThreadPoolExecutor.DiscardPolicy")]),o._v("：")]),o._v(" 不处理新任务，直接丢弃掉。")]),o._v(" "),_("li",[_("strong",[_("code",[o._v("ThreadPoolExecutor.DiscardOldestPolicy")]),o._v("：")]),o._v(" 此策略将丢弃最早的未处理的任务请求。")])]),o._v(" "),_("p",[o._v("举个例子： Spring 通过 "),_("code",[o._v("ThreadPoolTaskExecutor")]),o._v(" 或者我们直接通过 "),_("code",[o._v("ThreadPoolExecutor")]),o._v(" 的构造函数创建线程池的时候，当我们不指定 "),_("code",[o._v("RejectedExecutionHandler")]),o._v(" 饱和策略的话来配置线程池的时候默认使用的是 "),_("code",[o._v("ThreadPoolExecutor.AbortPolicy")]),o._v("。在默认情况下，"),_("code",[o._v("ThreadPoolExecutor")]),o._v(" 将抛出 "),_("code",[o._v("RejectedExecutionException")]),o._v(" 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 "),_("code",[o._v("ThreadPoolExecutor.CallerRunsPolicy")]),o._v("。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 "),_("code",[o._v("ThreadPoolExecutor")]),o._v(" 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）")])])}),[],!1,null,null,null);e.default=r.exports}}]);