(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{530:function(t,a,v){t.exports=v.p+"assets/img/Java+线程状态变迁.c79c909e.png"},703:function(t,a,v){"use strict";v.r(a);var n=v(1),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"线程的生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程的生命周期"}},[t._v("#")]),t._v(" 线程的生命周期")]),t._v(" "),n("p",[t._v("Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：")]),t._v(" "),n("p",[n("img",{attrs:{src:v(530),alt:"Java 线程状态变迁 ",loading:"lazy"}})]),t._v(" "),n("p",[t._v("由上图可以看出：线程创建之后它将处于 "),n("strong",[t._v("NEW（新建）")]),t._v(" 状态，调用 "),n("code",[t._v("start()")]),t._v(" 方法后开始运行，线程这时候处于 "),n("strong",[t._v("READY（可运行）")]),t._v(" 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 "),n("strong",[t._v("RUNNING（运行）")]),t._v(" 状态。")]),t._v(" "),n("blockquote",[n("p",[t._v("在操作系统中层面线程有 READY 和 RUNNING 状态，而在 JVM 层面只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 "),n("strong",[t._v("RUNNABLE（运行中）")]),t._v(" 状态 。")]),t._v(" "),n("p",[n("strong",[t._v("为什么 JVM 没有区分这两种状态呢？")])]),t._v(" "),n("p",[t._v("现在的"),n("strong",[t._v("时分")]),t._v("（time-sharing）"),n("strong",[t._v("多任务")]),t._v("（multi-task）操作系统架构通常都是用所谓的“"),n("strong",[t._v("时间分片")]),t._v("（time quantum or time slice）”方式进行"),n("strong",[t._v("抢占式")]),t._v("（preemptive）轮转调度（round-robin式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。")])]),t._v(" "),n("h3",{attrs:{id:"阻塞与等待的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#阻塞与等待的区别"}},[t._v("#")]),t._v(" 阻塞与等待的区别")]),t._v(" "),n("p",[t._v("阻塞：当一个线程试图获取对象锁（非java.util.concurrent库中的锁，即synchronized），而该锁被其他线程持有，则该线程进入阻塞状态。它的特点是"),n("strong",[t._v("使用简单，由JVM调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断")]),t._v("。\n等待：当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。它的特点是"),n("strong",[t._v("需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断")]),t._v("。例如调用：Object.wait()、Thread.join()以及等待Lock或Condition。")]),t._v(" "),n("p",[t._v("需要强调的是虽然 synchronized 和 JUC 里的 Lock 都实现锁的功能，但线程进入的状态是不一样的。"),n("strong",[t._v("synchronized 会让线程进入阻塞态，而 JUC 里的 Lock 是用 LockSupport.park()/unpark() 来实现阻塞/唤醒的，会让线程进入等待态")]),t._v("。但话又说回来，虽然等锁时进入的状态不一样，但被唤醒后又都进入runnable态，从行为效果来看又是一样的。")]),t._v(" "),n("h2",{attrs:{id:"等待集合-和-唤醒-wait-sets-and-notification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#等待集合-和-唤醒-wait-sets-and-notification"}},[t._v("#")]),t._v(" 等待集合 和 唤醒（Wait Sets and Notification）")]),t._v(" "),n("p",[t._v("每个 java 对象，都关联了一个监视器，也关联了一个"),n("strong",[t._v("等待集合")]),t._v("。等待集合是一个线程集合。")]),t._v(" "),n("p",[t._v("当对象被创建出来时，它的等待集合是空的，"),n("em",[t._v("对于向等待集合中添加或者移除线程的")]),t._v("操作都是原子的，以下几个操作可以操纵这个等待集合：Object.wait, Object.notify, Object.notifyAll。")]),t._v(" "),n("p",[t._v("等待集合也可能受到线程的中断状态的影响，也受到线程中处理中断的方法的影响。另外，sleep 方法和 join 方法可以感知到线程的 wait 和 notify。")]),t._v(" "),n("blockquote",[n("ul",[n("li",[t._v("Thread 中的 sleep、join、interrupt")]),t._v(" "),n("li",[t._v("继承自 Object 的 wait、notify、notifyAll")]),t._v(" "),n("li",[t._v("还有 Java 的中断，这个概念也很重要")])])]),t._v(" "),n("h3",{attrs:{id:"等待-wait"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#等待-wait"}},[t._v("#")]),t._v(" 等待(Wait)")])])}),[],!1,null,null,null);a.default=r.exports}}]);