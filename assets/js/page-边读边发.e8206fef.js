(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{473:function(t,e,s){t.exports=s.p+"assets/img/749_e1b_062.a110ec7e.jpg"},474:function(t,e,s){t.exports=s.p+"assets/img/750_d5a_a84.bb495b3c.jpg"},653:function(t,e,s){"use strict";s.r(e);var _=s(1),r=Object(_.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"边读边发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#边读边发"}},[t._v("#")]),t._v(" 边读边发")]),t._v(" "),_("h2",{attrs:{id:"_1、引子"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、引子"}},[t._v("#")]),t._v(" 1、引子")]),t._v(" "),_("p",[t._v("我常常会被问到这样一个问题：个人主机内存只有 100G，如今要对一个 200G 的大表作全表扫描，会不会把数据库主机的内存用光了？mysql")]),t._v(" "),_("p",[t._v("这个问题确实值得担忧，被系统 OOM（out of memory）可不是闹着玩的。可是，反过来想一想，逻辑备份的时候，可不就是作整库扫描吗？若是这样就会把内存吃光，逻辑备份\n不是早就挂了？算法")]),t._v(" "),_("p",[t._v("因此说，对大表作全表扫描，看来应该是没问题的。可是，这个流程究竟是怎么样的呢？sql")]),t._v(" "),_("h2",{attrs:{id:"_2、全表扫描对-server-层的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、全表扫描对-server-层的影响"}},[t._v("#")]),t._v(" 2、全表扫描对 server 层的影响")]),t._v(" "),_("p",[t._v("假设，咱们如今要对一个 200G 的 InnoDB 表 db1. t，执行一个全表扫描。固然，你要把扫描结果保存在客户端，会使用相似这样的命令：数据库")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('mysql -h$host -P$port -u$user -p$pwd -e "select * from db1.t" > $target_file\n')])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("你已经知道了，InnoDB 的数据是保存在主键索引上的，因此全表扫描其实是直接扫描表 t 的主键索引。这条查询语句因为没有其余的判断条件，因此查到的每一行均可以直接放到结果集里面，而后返回给客户端。")]),t._v(" "),_("h3",{attrs:{id:"一、mysql-查询结果发送流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、mysql-查询结果发送流程"}},[t._v("#")]),t._v(" 一、MySQL 查询结果发送流程")]),t._v(" "),_("p",[t._v("那么，这个“结果集”存在哪里呢？服务器")]),t._v(" "),_("p",[t._v("**实际上，服务端并不须要保存一个完整的结果集。取数据和发数据的流程是这样的：**网络")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。")])]),t._v(" "),_("li",[_("p",[t._v("重复获取行，直到 net_buffer 写满，调用网络接口发出去。")])]),t._v(" "),_("li",[_("p",[t._v("若是发送成功，就清空 net_buffer，而后继续取下一行，并写入 net_buffer。")])]),t._v(" "),_("li",[_("p",[t._v("若是发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socketsend buffer）写满了，进入等待。直到网络栈从新可写，再继续发送。")])])]),t._v(" "),_("p",[_("strong",[t._v("这个过程对应的流程图以下所示。")])]),t._v(" "),_("p",[_("img",{attrs:{src:s(473),alt:"img",loading:"lazy"}})]),t._v(" "),_("p",[_("strong",[t._v("从这个流程中，你能够看到：")])]),t._v(" "),_("ol",[_("li",[t._v("一个查询在发送过程当中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，并不会达到 200G；")]),t._v(" "),_("li",[t._v("socket send buffer 也不可能达到 200G（默认定义/proc/sys/net/core/wmem_default），若是 socket send buffer 被写满，就会暂停读数据的流程。")])]),t._v(" "),_("h3",{attrs:{id:"二、mysql-是-边读边发的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、mysql-是-边读边发的"}},[t._v("#")]),t._v(" 二、MySQL 是“边读边发的")]),t._v(" "),_("p",[t._v("也就\t是说，MySQL 是“边读边发的”，这个概念很重要。这就意味着，若是客户端接收得慢，会致使 MySQL 服务端因为结果发不出去，这个事务的执行时间变长。")]),t._v(" "),_("p",[t._v("好比下面这个状态，就是我故意让客户端不去读 socket receive buffer 中的内容，而后在服务端 show processlist 看到的结果。")]),t._v(" "),_("p",[_("img",{attrs:{src:s(474),alt:"img",loading:"lazy"}})]),t._v(" "),_("p",[t._v("若是你看到 State 的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。")]),t._v(" "),_("p",[t._v("若是客户端使用 –quick 参数，会使用 mysql_use_result 方法。这个方法是读一行处理一行。你能够想象一下，假设有一个业务的逻辑比较复杂，每\n读一行数据之后要处理的逻辑若是很慢，就会致使客户端要过好久才会去取下一行数据，可能就会出现如图 2 所示的这种状况。")]),t._v(" "),_("p",[t._v("所以，对于正常的线上业务来讲，若是一个查询的返回结果不会不少的话，我都建议你使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。")])])}),[],!1,null,null,null);e.default=r.exports}}]);