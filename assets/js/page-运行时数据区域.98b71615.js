(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{608:function(a,t,s){a.exports=s.p+"assets/img/JVM运行时数据区域.5f095134.02fcff63.png"},609:function(a,t,s){a.exports=s.p+"assets/img/Java运行时数据区域JDK1.8.5a3971fc.5527a2cd.png"},610:function(a,t,s){a.exports=s.p+"assets/img/jvmimage-20220331175738692.4e9c096b.png"},738:function(a,t,s){"use strict";s.r(t);var v=s(1),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"运行时数据区域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区域"}},[a._v("#")]),a._v(" 运行时数据区域")]),a._v(" "),v("p",[a._v("Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。")]),a._v(" "),v("p",[v("strong",[a._v("JDK 1.8 之前")]),a._v(" ：")]),a._v(" "),v("p",[v("img",{attrs:{src:s(608),alt:"img",loading:"lazy"}})]),a._v(" "),v("p",[v("strong",[a._v("JDK 1.8")]),a._v(" ：")]),a._v(" "),v("p",[v("img",{attrs:{src:s(609),alt:"img",loading:"lazy"}})]),a._v(" "),v("p",[a._v("方法区是 Java 虚拟机规范中的一个逻辑概念，常量池是方法区的一部分，而永久代和元空间则是方法区的具体实现。1.8 的元空间是方法区代替永久代的一种实现，与永久代不同是元空间并不在虚拟机中，而是使用本地内存")]),a._v(" "),v("p",[v("strong",[a._v("线程私有的：")])]),a._v(" "),v("ul",[v("li",[a._v("程序计数器")]),a._v(" "),v("li",[a._v("虚拟机栈")]),a._v(" "),v("li",[a._v("本地方法栈")])]),a._v(" "),v("p",[v("strong",[a._v("线程共享的：")])]),a._v(" "),v("ul",[v("li",[a._v("堆")]),a._v(" "),v("li",[a._v("方法区")]),a._v(" "),v("li",[a._v("直接内存 (非运行时数据区的一部分)")])]),a._v(" "),v("h4",{attrs:{id:"_1、虚拟机栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、虚拟机栈"}},[a._v("#")]),a._v(" 1、虚拟机栈：")]),a._v(" "),v("p",[a._v("​\t主要数据是栈帧（Stack Frame）。线程私有的内存空间，当线程创建的时候，与之相关的虚拟机栈就诞生了，当线程消亡了，与之对应的虚拟机栈也就消失。")]),a._v(" "),v("p",[a._v("方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。")]),a._v(" "),v("p",[a._v("栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。")]),a._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"images/stack.b24530b8.png",alt:"栈"}}),a._v(" "),v("p",[v("strong",[a._v("局部变量表")]),a._v(" 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。")]),a._v(" "),v("p",[v("strong",[a._v("操作数栈")]),a._v(" 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。")]),a._v(" "),v("p",[v("strong",[a._v("动态链接")]),a._v(" 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在Class 文件的常量池里。*当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。*动态链接的作用就是为了将符号引用转换为调用方法的直接引用。")]),a._v(" "),v("p",[v("img",{attrs:{src:s(610),alt:"img",loading:"lazy"}})]),a._v(" "),v("p",[a._v("Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， "),v("strong",[a._v("栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。")])]),a._v(" "),v("h4",{attrs:{id:"_2、程序计数器-program-counter"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、程序计数器-program-counter"}},[a._v("#")]),a._v(" 2、程序计数器（Program Counter）：")]),a._v(" "),v("ul",[v("li",[a._v("主要标识当前线程执行代码的行号，存放下一条执行代码的位置，比如第三行执行完后执行到哪行，可能执行到第四行，也可能执行到第八行。")]),a._v(" "),v("li",[a._v("多个线程同时执行的时候，按照时间片的方式，多个线程轮执行，比如在第一个线程执行到一半的时候执行其他线程，这时候程序计数器就得记住线程挂起的位置。其他的线程是不能获取这个线程的代码执行的位置，即程序计数器线程私有的。")])]),a._v(" "),v("h4",{attrs:{id:"_3、本地方法栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、本地方法栈"}},[a._v("#")]),a._v(" 3、本地方法栈：")]),a._v(" "),v("p",[a._v("和虚拟机栈所发挥的作用非常相似，区别是： "),v("strong",[a._v("虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。")])]),a._v(" "),v("p",[a._v("本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。")]),a._v(" "),v("p",[a._v("方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 "),v("code",[a._v("StackOverFlowError")]),a._v(" 和 "),v("code",[a._v("OutOfMemoryError")]),a._v(" 两种错误")]),a._v(" "),v("h4",{attrs:{id:"_4、堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、堆"}},[a._v("#")]),a._v(" 4、堆")]),a._v(" "),v("p",[a._v("Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。"),v("strong",[a._v("此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。")])]),a._v(" "),v("p",[a._v("Java 堆是垃圾收集器管理的主要区域，因此也被称作 "),v("strong",[a._v("GC 堆（Garbage Collected Heap）")]),a._v("。")]),a._v(" "),v("p",[a._v("大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 "),v("code",[a._v("-XX:MaxTenuringThreshold")]),a._v(" 来设置。")]),a._v(" "),v("h5",{attrs:{id:"_4-1-字符串常量池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-字符串常量池"}},[a._v("#")]),a._v(" 4.1 字符串常量池：")]),a._v(" "),v("p",[a._v("字符串常量池和静态变量在堆上。")]),a._v(" "),v("h5",{attrs:{id:"字符串常量池作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池作用"}},[a._v("#")]),a._v(" 字符串常量池作用？")]),a._v(" "),v("p",[v("strong",[a._v("字符串常量池")]),a._v(" 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。")]),a._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" aa "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ab"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 放在常量池中")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" bb "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ab"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 从常量池中查找")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("aa"),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v("bb"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),v("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br")])]),v("p",[v("strong",[a._v("JDK 1.7 为什么要将字符串常量池移动到堆中？")])]),a._v(" "),v("p",[a._v("主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。")]),a._v(" "),v("h4",{attrs:{id:"_5、方法区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、方法区"}},[a._v("#")]),a._v(" 5、方法区")]),a._v(" "),v("p",[a._v("方法区是 Java 虚拟机规范中的一个逻辑概念，常量池是方法区的一部分，而永久代和元空间则是方法区的具体实现。1.8 的元空间是方法区代替永久代的一种实现，与永久代不同是元空间并不在虚拟机中，而是使用本地内存。")]),a._v(" "),v("p",[a._v("当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 "),v("strong",[a._v("类信息、字段信息、方法信息、常量即时编译器编译后的代码缓存等数据")]),a._v("。")]),a._v(" "),v("h5",{attrs:{id:"_5-1-运行时常量池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-运行时常量池"}},[a._v("#")]),a._v(" 5.1 运行时常量池：")]),a._v(" "),v("p",[a._v("在编译期间就能确定好的。是方法区一部分内容，就是字节码中的常量池，再加载完以后就会进入运行时常量池。")]),a._v(" "),v("blockquote",[v("ol",[v("li",[a._v("JDK1.7 之前，运行时常量池包含的字符串常量池和静态变量存放在方法区, 此时 HotSpot 虚拟机对方法区的实现为永久代。")]),a._v(" "),v("li",[a._v("JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 HotSpot 中的永久代 。")]),a._v(" "),v("li",[a._v("JDK1.8 HotSpot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池和静态变量还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)")])])]),a._v(" "),v("p",[v("strong",[a._v("为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?")])]),a._v(" "),v("p",[a._v("1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。")]),a._v(" "),v("p",[a._v("2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 "),v("code",[a._v("MaxPermSize")]),a._v(" 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。")]),a._v(" "),v("h4",{attrs:{id:"_6、直接内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、直接内存"}},[a._v("#")]),a._v(" 6、直接内存")]),a._v(" "),v("p",[a._v("直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。")]),a._v(" "),v("p",[a._v("JDK1.4 中新加入的 "),v("strong",[a._v("NIO(New Input/Output) 类")]),a._v("，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。")]),a._v(" "),v("p",[a._v("本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。")])])}),[],!1,null,null,null);t.default=_.exports}}]);