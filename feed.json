{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "fmiles",
  "home_page_url": "https://fmiles.cn/",
  "feed_url": "https://fmiles.cn/feed.json",
  "description": "Java个人博客",
  "author": {
    "name": "siyue"
  },
  "items": [
    {
      "title": "Home",
      "url": "https://fmiles.cn/",
      "id": "https://fmiles.cn/",
      "content_html": "",
      "date_published": "2022-03-03T13:05:45.000Z",
      "date_modified": "2022-03-03T15:56:56.000Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "数据只有两种存储方式：",
      "url": "https://fmiles.cn/algorithms/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      "id": "https://fmiles.cn/algorithms/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      "content_html": "<h3 id=\"数据只有两种存储方式\"> 数据只有两种存储方式：</h3>\n<p>数组 （顺序存储）、链表（链式存储）</p>\n<h3 id=\"数据结构的基本操作\"> 数据结构的基本操作：</h3>\n<p>线性就是 for/while 迭代为代表，非线性就是递归为代表。</p>\n<h5 id=\"典型线性迭代结构\"> 典型线性迭代结构：</h5>\n<div><pre><code><span>void</span> <span>traverse</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>// 迭代访问 arr[i]</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h5 id=\"典型的非线性递归遍历结构\"> 典型的非线性递归遍历结构：</h5>\n<div><pre><code><span>/* 基本的二叉树节点 */</span>\n<span>class</span> <span>TreeNode</span> <span>{</span>\n    <span>int</span> val<span>;</span>\n    <span>TreeNode</span> left<span>,</span> right<span>;</span>\n<span>}</span>\n\n<span>void</span> <span>traverse</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n    <span>traverse</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>\n    <span>traverse</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>",
      "date_modified": "2022-04-29T06:23:42.979Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "530. 二叉搜索树的最小绝对差",
      "url": "https://fmiles.cn/algorithms/%E6%A0%91/",
      "id": "https://fmiles.cn/algorithms/%E6%A0%91/",
      "content_html": "<h4 id=\"_530-二叉搜索树的最小绝对差\"> <a href=\"https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/\" target=\"_blank\" rel=\"noopener noreferrer\">530. 二叉搜索树的最小绝对差</a></h4>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>int</span> <span>getMinimumDifference</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n        <span>//二叉搜索树中序遍历 重要性质：为一个递增序列</span>\n        <span>inorder</span><span>(</span>root<span>)</span><span>;</span>\n        <span>int</span> minNum <span>=</span> res<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span> <span>-</span> res<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> res<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            minNum <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>minNum<span>,</span> <span>(</span>res<span>.</span><span>get</span><span>(</span>i<span>)</span> <span>-</span> res<span>.</span><span>get</span><span>(</span>i <span>-</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> minNum<span>;</span>\n\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>inorder</span><span>(</span><span>TreeNode</span> root<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>!=</span> <span>null</span><span>)</span><span>{</span>\n            <span>inorder</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>\n            res<span>.</span><span>add</span><span>(</span>root<span>.</span>val<span>)</span><span>;</span>\n            <span>inorder</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h4 id=\"_235-二叉搜索树的最近公共祖先\"> <a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener noreferrer\">235. 二叉搜索树的最近公共祖先</a></h4>\n<div><pre><code><span>public</span> <span>TreeNode</span> <span>lowestCommonAncestor</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>TreeNode</span> p<span>,</span> <span>TreeNode</span> q<span>)</span> <span>{</span>\n    <span>//如果根节点和p,q的差相乘是正数，说明这两个差值要么都是正数要么都是负数，也就是说</span>\n    <span>//他们肯定都位于根节点的同一侧，就继续往下找</span>\n    <span>while</span> <span>(</span><span>(</span>root<span>.</span>val <span>-</span> p<span>.</span>val<span>)</span> <span>*</span> <span>(</span>root<span>.</span>val <span>-</span> q<span>.</span>val<span>)</span> <span>></span> <span>0</span><span>)</span><span>{</span>\n        root <span>=</span> p<span>.</span>val <span>&lt;</span> root<span>.</span>val <span>?</span> root<span>.</span>left <span>:</span> root<span>.</span>right<span>;</span>\n    <span>}</span>\n    <span>//如果相乘的结果是负数，说明p和q位于根节点的两侧，如果等于0，说明至少有一个就是根节点</span>\n    <span>return</span> root<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"_669-修剪二叉搜索树\"> <a href=\"https://leetcode-cn.com/problems/trim-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener noreferrer\">669. 修剪二叉搜索树</a></h4>\n<p>递归三部曲</p>\n<h5 id=\"_1、确定递归函数的参数和返回值\"> 1、确定递归函数的参数和返回值</h5>\n<p>参数是需要判断的节点 root 和给定的边界 low 和 high 。\n返回值是修剪后的节点，可能是空，也可能是一棵树。</p>\n<h5 id=\"_2、确定终止条件\"> 2、确定终止条件</h5>\n<p>当遇到空节点时，无法修剪，直接返回 null 。</p>\n<h5 id=\"_3、确定单层递归的逻辑\"> 3、确定单层递归的逻辑</h5>\n<p>先判断当前节点是否在给定的边界内，如果不在，判断其值是小于 low 还是大于 high。</p>\n<p>当 root.val &lt; low 时，说明当前节点和左子树的所有值都不可能在 [low, high] 内，但是右子树的值都大于根节点，有可能存在节点位于 [low, high] 内，因此递归判断右子树的节点 trimBST(root.right, low, high) 。</p>\n<p>当 root.val &gt; high 时，说明当前节点和右子树的所有值都不可能在 [low, high] 内，但是左子树的值都小于根节点，有可能存在节点位于 [low, high] 内，因此递归判断左子树的节点 trimBST(root.left, low, high) 。</p>\n<p>如果当前节点处于给定的边界内，那么就递归的判断节点的左右子树，寻找左右子树中符合边界条件的，并利用 root.left 和 root.right 接收返回值，这样一来，假设左右子树中进行了修剪的操作，就会返回上面两种情况中符合边界返回的节点，从而使根节点和修剪后的节点建立了联系。</p>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>TreeNode</span> <span>trimBST</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span> low<span>,</span> <span>int</span> high<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>null</span><span>)</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>if</span><span>(</span>root<span>.</span>val <span>&lt;</span> low<span>)</span>\n            <span>return</span> <span>trimBST</span><span>(</span>root<span>.</span>right<span>,</span> low<span>,</span> high<span>)</span><span>;</span>\n        <span>else</span> <span>if</span><span>(</span>root<span>.</span>val <span>></span> high<span>)</span>\n            <span>return</span> <span>trimBST</span><span>(</span>root<span>.</span>left<span>,</span> low<span>,</span> high<span>)</span><span>;</span>\n        root<span>.</span>left <span>=</span> <span>trimBST</span><span>(</span>root<span>.</span>left<span>,</span> low<span>,</span> high<span>)</span><span>;</span>\n        root<span>.</span>right <span>=</span> <span>trimBST</span><span>(</span>root<span>.</span>right<span>,</span> low<span>,</span> high<span>)</span><span>;</span>\n        <span>return</span> root<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id=\"_513-找树左下角的值\"> <a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\" target=\"_blank\" rel=\"noopener noreferrer\">513. 找树左下角的值</a></h4>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>int</span> <span>findBottomLeftValue</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n        <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        queue<span>.</span><span>offer</span><span>(</span>root<span>)</span><span>;</span>\n        <span>while</span><span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            root <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>root<span>.</span>right <span>!=</span> <span>null</span><span>)</span> queue<span>.</span><span>offer</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>root<span>.</span>left <span>!=</span> <span>null</span><span>)</span> queue<span>.</span><span>offer</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> root<span>.</span>val<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>",
      "date_modified": "2022-04-29T06:23:42.982Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "160. 相交链表",
      "url": "https://fmiles.cn/algorithms/%E9%93%BE%E8%A1%A8/",
      "id": "https://fmiles.cn/algorithms/%E9%93%BE%E8%A1%A8/",
      "content_html": "<h4 id=\"_160-相交链表\"> <a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener noreferrer\">160. 相交链表</a></h4>\n<h4 id=\"思维误区\"> 思维误区：</h4>\n<p>1、这里 next 永远是下一个节点，死循环。</p>\n<p><img src=\"./images/image-20220305190410177.png\" alt=\"image-20220305190410177\" loading=\"lazy\"></p>\n<p>2、两个 ListNode 链表并不是等长。</p>\n<h4 id=\"个人解法\"> 个人解法：</h4>\n<p>两个 stack去存两个链表值，然后从链表尾部开始遍历对比。问题在于如果是长度为 1 的链表，就需要特殊处理，麻烦。</p>\n<h4 id=\"优化解法\"> 优化解法：</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>ListNode</span> <span>getIntersectionNode</span><span>(</span><span>ListNode</span> headA<span>,</span> <span>ListNode</span> headB<span>)</span> <span>{</span>\n        <span>/**\n       和个人思路有相同的地方，两轮，第一轮结束如果都没相同，指针换对象，然后在第二轮刚好又是新的一轮遍历。\n        **/</span>\n        <span>if</span><span>(</span>headA <span>==</span> <span>null</span> <span>||</span> headB <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>\n        <span>ListNode</span> pA <span>=</span> headA<span>,</span> pB <span>=</span> headB<span>;</span>\n     \n        <span>while</span><span>(</span>pA <span>!=</span> pB<span>)</span> <span>{</span>\n            pA <span>=</span> pA <span>==</span> <span>null</span> <span>?</span> headB <span>:</span> pA<span>.</span>next<span>;</span>  <span>//当你走到终点时，开始走她走过的路</span>\n            pB <span>=</span> pB <span>==</span> <span>null</span> <span>?</span> headA <span>:</span> pB<span>.</span>next<span>;</span>  <span>// 当她走到终点时，开始走你走过的路</span>\n        <span>}</span>\n        <span>return</span> pA<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id=\"_21-合并两个有序链表\"> <a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener noreferrer\">21. 合并两个有序链表</a></h4>\n<h4 id=\"个人解法-2\"> 个人解法：</h4>\n<p>类似于归并。</p>\n<div><pre><code><span>public</span> <span>ListNode</span> <span>mergeTwoLists</span><span>(</span><span>ListNode</span> l1<span>,</span> <span>ListNode</span> l2<span>)</span> <span>{</span>\n        <span>// 类似归并排序中的合并过程</span>\n        <span>ListNode</span> dummyHead <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>ListNode</span> cur <span>=</span> dummyHead<span>;</span>\n        <span>while</span> <span>(</span>l1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> l2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>l1<span>.</span>val <span>&lt;</span> l2<span>.</span>val<span>)</span> <span>{</span>\n                cur<span>.</span>next <span>=</span> l1<span>;</span>\n                cur <span>=</span> cur<span>.</span>next<span>;</span>\n                l1 <span>=</span> l1<span>.</span>next<span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                cur<span>.</span>next <span>=</span> l2<span>;</span>\n                cur <span>=</span> cur<span>.</span>next<span>;</span>\n                l2 <span>=</span> l2<span>.</span>next<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// 任一为空，直接连接另一条链表</span>\n        <span>if</span> <span>(</span>l1 <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            cur<span>.</span>next <span>=</span> l2<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            cur<span>.</span>next <span>=</span> l1<span>;</span>\n        <span>}</span>\n        <span>return</span> dummyHead<span>.</span>next<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h5 id=\"递归解法\"> 递归解法：</h5>\n<div><pre><code> <span>public</span> <span>ListNode</span> <span>mergeTwoLists</span><span>(</span><span>ListNode</span> list1<span>,</span> <span>ListNode</span> list2<span>)</span> <span>{</span>\n       <span>if</span> <span>(</span>list1 <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> list2<span>;</span>  <span>// 终止条件</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>list2 <span>==</span> <span>null</span><span>)</span><span>{</span>\n            <span>return</span> list1<span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>list1<span>.</span>val <span>&lt;</span> list2<span>.</span>val<span>)</span><span>{</span>\n            list1<span>.</span>next <span>=</span> <span>mergeTwoLists</span><span>(</span>list1<span>.</span>next<span>,</span>list2<span>)</span><span>;</span>  <span>// l1 的下个节点一定是一个从 l1.next 到 l2 的一个有序列表</span>\n            <span>return</span> list1<span>;</span>\n        <span>}</span><span>else</span> <span>{</span>\n            list2<span>.</span>next <span>=</span> <span>mergeTwoLists</span><span>(</span>list1<span>,</span>list2<span>.</span>next<span>)</span><span>;</span>\n            <span>return</span> list2<span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id=\"_142-环形链表-ii\"> <a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">142. 环形链表 II</a></h4>\n<h4 id=\"优化解法-2\"> 优化解法：</h4>\n<h5 id=\"双指针法\"> 双指针法：</h5>\n<p>设 fast 指针路程为 f，slow 指针为 s，fast 指针每次移动 2 步，slow 每次  1 步。则可推出如下</p>\n<ol>\n<li>f = 2s (快指针每次 2 步，慢指针 1 步)</li>\n<li>f = s + nb (相遇时， 双指针都走过 <em>a</em> 步，然后在环内绕圈直到重合，重合时 <code>fast</code> 比 <code>slow</code> 多走环的长度整数倍，即 nb)</li>\n</ol>\n<p>由上推出：s = nb （这个结果说明在相遇的时候，slow 走了 nb 步）。</p>\n<p>在第一次相遇的时候，slow 的步数是 nb。从 head 节点走到入环点（这里值为 1 的点）需要 a + nb，而 slow 已经走了 nb ，那么 slow 还需要走 a 步就是入环点。</p>\n<p>如何知道 slow 刚好走了 a 步？fast 从 head 开始，和 slow 一起走，相遇时刚好就是 a 步。在第一次相遇 fast 从 head 开始走时，f = 0，s = nb，第二次相遇时，f = a，s = a + nb，相遇刚好在入环点。</p>\n<p><img src=\"./images/image-20220305224746147.png\" alt=\"image-20220305224746147\" loading=\"lazy\"></p>\n<div><pre><code><span>public</span> <span>ListNode</span> <span>detectCycle</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>\n    <span>ListNode</span> fast <span>=</span> head<span>;</span>\n    <span>ListNode</span> slow <span>=</span> head<span>;</span>\n    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>fast <span>==</span> <span>null</span> <span>||</span> fast<span>.</span>next <span>==</span> <span>null</span><span>)</span><span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n        fast <span>=</span> fast<span>.</span>next<span>.</span>next<span>;</span>\n        slow <span>=</span> slow<span>.</span>next<span>;</span>\n        <span>// 第一次相遇</span>\n        <span>if</span> <span>(</span>fast <span>==</span> slow<span>)</span><span>{</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    fast <span>=</span> head<span>;</span>\n    <span>// 再走 a 步,在入环口相遇</span>\n    <span>while</span> <span>(</span>fast <span>!=</span> slow<span>)</span><span>{</span>\n        fast <span>=</span> fast<span>.</span>next<span>;</span>\n        slow <span>=</span> slow<span>.</span>next<span>;</span>\n    <span>}</span>\n    <span>return</span> fast<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h4 id=\"_92-反转链表-ii\"> <a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">92. 反转链表 II</a></h4>\n",
      "date_modified": "2022-04-29T06:23:42.984Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "changeBuffer",
      "url": "https://fmiles.cn/database/mysql/ChangBuffer/",
      "id": "https://fmiles.cn/database/mysql/ChangBuffer/",
      "content_html": "<h2 id=\"changbuffer-是什么\"> ChangBuffer 是什么</h2>\n",
      "date_modified": "2022-04-29T06:23:42.984Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "二叉树标题文章",
      "url": "https://fmiles.cn/algorithms/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%AE%E5%BD%95/",
      "id": "https://fmiles.cn/algorithms/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%AE%E5%BD%95/",
      "content_html": "<h1 id=\"二叉树文章\"> 二叉树文章</h1>\n<h2 id=\"二叉树解题思维模式\"> 二叉树解题思维模式</h2>\n<p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>\n<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>\n<p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p>\n<h2 id=\"深入理解前中后序\"> 深入理解前中后序</h2>\n<p>前序位置的代码在刚刚进入一个二叉树节点的时候执行；</p>\n<p>后序位置的代码在将要离开一个二叉树节点的时候执行；</p>\n<p>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</p>\n<img src=\"images/2.jpeg\" alt=\"img\" style=\"zoom: 33%;\" />\n<p><strong>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</p>\n<p>前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的。</p>\n<h2 id=\"leetcode\"> leetcode</h2>\n<h4 id=\"_144-二叉树的前序遍历\"> <a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">144. 二叉树的前序遍历</a></h4>\n<p>这题比较容易的是递归。</p>\n<h5 id=\"解法二-利用栈深度优先\"> 解法二：利用栈深度优先</h5>\n<p>这里利用了指针 node，遍历节点。</p>\n<div><pre><code><span>/**\n* 前序遍历（栈方式,深度优先)\n*/</span>\n<span>public</span> <span>void</span> <span>frontShow2</span><span>(</span><span>)</span><span>{</span>\n    <span>Stack</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>TreeNode</span> node <span>=</span> root<span>;</span>\n    <span>while</span> <span>(</span>node <span>!=</span> <span>null</span> <span>||</span> <span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>node <span>!=</span> <span>null</span><span>)</span> <span>{</span><span>// 根指针进栈，遍历左子树</span>\n            stack<span>.</span><span>push</span><span>(</span>node<span>)</span><span>;</span>\n            node <span>=</span> node<span>.</span>leftNode<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span> <span>// 根指针出栈，访问根节点，遍历右子树</span>\n            node <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n            node <span>=</span> node<span>.</span>rightNode<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h5 id=\"\"> </h5>\n<p>下面这种则是利用栈本身的特点，栈顶元素的下一个元素即为父节点。</p>\n<div><pre><code><span>public</span> <span>void</span> <span>frontShow3</span><span>(</span><span>)</span> <span>{</span>\n    <span>Stack</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    stack<span>.</span><span>push</span><span>(</span>root<span>)</span><span>;</span>  <span>// 根元素进栈</span>\n    <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>while</span> <span>(</span>stack<span>.</span><span>peek</span><span>(</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            stack<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>peek</span><span>(</span><span>)</span><span>.</span>leftNode<span>)</span><span>;</span>  <span>// 向左走到尽头</span>\n        <span>}</span>\n        stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span> <span>// 删除空指针。最后的左子节点为空</span>\n\n        <span>if</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            stack<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>.</span>rightNode<span>)</span><span>;</span> <span>//访问根节点，向右一步</span>\n        <span>}</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id=\"_102-二叉树的层序遍历\"> <a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">102. 二叉树的层序遍历</a></h4>\n<p>基本的 BFS 算法：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>levelFrontShow</span><span>(</span><span>)</span> <span>{</span>\n    <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    queue<span>.</span><span>offer</span><span>(</span>root<span>)</span><span>;</span>\n    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>//出队</span>\n        <span>TreeNode</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>\n        <span>//把节点左节点放入队列(先放的左节点，所以先遍历左节点。</span>\n        <span>if</span> <span>(</span>node<span>.</span>leftNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>//入队</span>\n            queue<span>.</span><span>offer</span><span>(</span>node<span>.</span>leftNode<span>)</span><span>;</span>\n        <span>}</span>\n        <span>//把右节点放入队列</span>\n        <span>if</span> <span>(</span>node<span>.</span>rightNode <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            queue<span>.</span><span>offer</span><span>(</span>node<span>.</span>rightNode<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>但是此题中含有每一层的节点，上述算法无法区分是哪一层的节点，因此需要变化一下。</p>\n<p>n 代表每层需要处理的节点数量，当上一层遍历完后，下一层所有需要遍历的节点已经进队列了，这时候队列的大小就是下一层节点数量。</p>\n<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> <span>levelOrder</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> res <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>Queue</span><span><span>&lt;</span><span>TreeNode</span><span>></span></span> queue <span>=</span> <span>new</span> <span>ArrayDeque</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        queue<span>.</span><span>add</span><span>(</span>root<span>)</span><span>;</span>\n    <span>}</span>\n    <span>while</span> <span>(</span><span>!</span>queue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> queue<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> <span>// 每层需要遍历的数量</span>\n        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> level <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span> \n            <span>TreeNode</span> node <span>=</span> queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n            level<span>.</span><span>add</span><span>(</span>node<span>.</span>val<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                queue<span>.</span><span>add</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                queue<span>.</span><span>add</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        res<span>.</span><span>add</span><span>(</span>level<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> res<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div>",
      "date_modified": "2022-04-29T06:23:42.987Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "binlog",
      "url": "https://fmiles.cn/database/mysql/BinLog/",
      "id": "https://fmiles.cn/database/mysql/BinLog/",
      "content_html": "<h1 id=\"binlog\"> binLog</h1>\n<h2 id=\"概念\"> 概念</h2>\n<p><code>redo log</code>它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于<code>InnoDB</code>存储引擎。</p>\n<p>而<code>binlog</code>是逻辑日志，记录内容是语句的原始逻辑，类似于“给ID=2这一行的c字段加1”，属于<code>MySQL Server</code>层。</p>\n<p>不管用什么存储引擎，只要发生了表数据更新，都会产生<code>binlog</code>日志。</p>\n<p>那<code>binlog</code>到底是用来干嘛的？</p>\n<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYtbPVxIRF2q52j5bF5rNnZZWXMlH75uJLIOficicYib5ib6tPVNrys15RrNw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>\n<h2 id=\"记录格式\"> 记录格式</h2>\n<p><code>binlog</code>日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>\n<ul>\n<li><strong>statement</strong></li>\n<li><strong>row</strong></li>\n<li><strong>mixed</strong></li>\n</ul>\n<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYtIct6NdhQicG44BZRlAicFZ60Kr5bmuvFWgN4fa3uicj5cYUNTejPiach9w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\" loading=\"lazy\"></p>\n<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>\n<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYt2RFw9v7vvUOPhMDhIR0yZa2QeD4PuWpKoUW2RV433icYuytoPqbIV9w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>\n<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3都是该行数据第1个~3个字段的原始值（<strong>假设这张表只有3个字段</strong>）。</p>\n<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>\n<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>\n<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>\n<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>\n<h2 id=\"写入机制\"> <strong>写入机制</strong></h2>\n<p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>\n<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>\n<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程<code>binlog cache</code>大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>\n<p><code>binlog</code>日志刷盘流程如下</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYtrdpDibhNGocdGJebjZxtTl2JAUwN9DJu3W0gH5CuvY6Dcx5b8FGzXCA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<ul>\n<li><strong>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>\n<li><strong>上图的  fsync，才是将数据持久化到磁盘的操作</strong></li>\n</ul>\n<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>\n<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYtZm96AgiaZtGFS52ib9yu2crr1f6CJc5XS9zRSahLWg3rgQPlXPe26Eog/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的<code>binglog</code>会丢失。</p>\n<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>binlog日志刷盘流程</strong>一样。</p>\n<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYtQKz5uIObVfZBWzO59SE9DPpDp8SXovvkj6cfJrHibGwm0JRfgyMdk5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>\n<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>\n",
      "image": "https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxiaXqrSndLqJZv7ic9wSaRYtIct6NdhQicG44BZRlAicFZ60Kr5bmuvFWgN4fa3uicj5cYUNTejPiach9w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1",
      "date_modified": "2022-04-29T06:23:42.989Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "两阶段提交",
      "url": "https://fmiles.cn/database/mysql/RedoAndBinLog/",
      "id": "https://fmiles.cn/database/mysql/RedoAndBinLog/",
      "content_html": "<h1 id=\"redo-log与binlog怎样保持一致\"> redo log与binlog怎样保持一致</h1>\n<p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>\n<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>\n<p>虽然它们都属于持久化的保证，但是则重点不同。</p>\n<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nyq7TPySfnaZkZlwBscQ1TKCF1P0plT6VqFDupQPxG5fKiaSKdE5AksqO64Qnfkb4wox51rVC2HNXA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>\n<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>\n<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nyq7TPySfnaZkZlwBscQ1TKpP6Ztb44qRNgbPiaCibQPLtZ5vFIxvJXoha1jAbIybsT89x0ayjdbGeQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\" loading=\"lazy\"></p>\n<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nyq7TPySfnaZkZlwBscQ1TKYlAQ1IwJXfpbAl2YPSkfFCr8RoicNjwicXh0s8dfiarhg944OdTAY68dg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>\n<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nyq7TPySfnaZkZlwBscQ1TKObGZHzrNY2hhGsRzHDMwXmuL79fA1bKBz5GfSQL8VvCSEz5sT2Un5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nyq7TPySfnaZkZlwBscQ1TK2ySUBibRXA1Us8Mm6IV5QPEWhytPq2qalyCHOVhwu2eTYAshP4icQ3PA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nyq7TPySfnaZkZlwBscQ1TKTgM6SIW09SygzLicSicTskPVIAUwV9mmH181fSdV1ofSPXxtK2DM9cbw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>\n",
      "image": "https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nyq7TPySfnaZkZlwBscQ1TKpP6Ztb44qRNgbPiaCibQPLtZ5vFIxvJXoha1jAbIybsT89x0ayjdbGeQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1",
      "date_modified": "2022-04-29T06:23:42.989Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "redoLog",
      "url": "https://fmiles.cn/database/mysql/RedoLog/",
      "id": "https://fmiles.cn/database/mysql/RedoLog/",
      "content_html": "<h2 id=\"概念\"> 概念</h2>\n<p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>\n<p>比如<code>MySQL</code>实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54bBA4hk3gw55HvxibrWwaj8Ms6mhmAL5RWEfk5YKiaEz4H45DUaWCYepw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p><code>MySQL</code>中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到<code>Buffer Pool</code>中。</p>\n<p>后续的查询都是先从<code>Buffer Pool</code>中找，没有命中再去硬盘加载，减少硬盘<code>IO</code>开销，提升性能。</p>\n<p>更新表数据的时候，也是如此，发现<code>Buffer Pool</code>里存在要更新的数据，就直接在<code>Buffer Pool</code>里更新。</p>\n<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到<code>redo log</code>文件里。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54zUDHSoo2miaeyicIo2SGBY0FicnkbWeicrTlQH0LenmpScjibL35u61KVoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>\n<blockquote>\n<p>小贴士：每条redo记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>\n</blockquote>\n<h2 id=\"刷盘时机\"> 刷盘时机</h2>\n<p><code>InnoDB</code>存储引擎为<code>redo log</code>的刷盘策略提供了<code>innodb_flush_log_at_trx_commit</code>参数，它支持三种策略</p>\n<ul>\n<li><strong>设置为0的时候，表示每次事务提交时不进行刷盘操作</strong></li>\n<li><strong>设置为1的时候，表示每次事务提交时都将进行刷盘操作（默认值）</strong></li>\n<li><strong>设置为2的时候，表示每次事务提交时都只把redo log buffer内容写入page cache</strong></li>\n</ul>\n<p>另外<code>InnoDB</code>存储引擎有一个后台线程，每隔<code>1</code>秒，就会把<code>redo log buffer</code>中的内容写到文件系统缓存（<code>page cache</code>），然后调用<code>fsync</code>刷盘。由于 fsync 的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54Ad70tZojSrwI8YOGP7ibboticxTic0pmOk6FClqx08AA75BictzAdJDD7g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>也就是说，一个没有提交事务的<code>redo log</code>记录，也可能会刷盘。</p>\n<p>为什么呢？</p>\n<p>因为在事务执行过程<code>redo log</code>记录是会写入<code>redo log buffer</code>中，这些<code>redo log</code>记录会被后台线程刷盘。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54v2N1so73Jm9TKRrmQCyA3dxNmMgwJhCiaNYrKyXBxv5ydMQm9GRIhUg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>一半的时候，后台线程会主动刷盘。</p>\n<p>下面是不同刷盘策略的流程图</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54oWOszyDsmLmIt7hhyicaia7PMUL5kMr1rUQ8AhA2QqaFJfucySByb5ag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54APdmn5HovTEfk1qS4Z8jX9rGFQqqpAibibfRuR6K3VmxWk7CoUBe8QbQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就 一定在硬盘里，不会有任何数据丢失。</p>\n<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54IlvrwXTNgOcv8aCIicNXzhicdOKqicpibJOLLhOqmicBHWoTayWm7TfEYAQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>\n<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>\n<h2 id=\"日志文件组\"> <strong>日志文件组</strong></h2>\n<p>硬盘上存储的<code>redo log</code>日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>\n<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是<code>1GB</code>，整个<code>redo log</code>日志文件组可以记录<code>4G</code>的内容。</p>\n<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54XsdKnbUPKlA4OUSQY709Mhr5G55YB6TiadxyrtVQXUzCJ0HbRiaKw5zg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是<code>write pos、checkpoint</code></p>\n<ul>\n<li><strong>write pos是当前记录的位置，一边写一边后移</strong></li>\n<li><strong>checkpoint是当前要擦除的位置，也是往后推移</strong></li>\n</ul>\n<p>每次刷盘<code>redo log</code>记录到<strong>日志文件组</strong>中，<code>write pos</code>位置就会后移更新。</p>\n<p>每次<code>MySQL</code>加载<strong>日志文件组</strong>恢复数据时，会清空加载过的<code>redo log</code>记录，并把<code>checkpoint</code>后移更新。</p>\n<p><code>write pos</code>和<code>checkpoint</code>之间的还空着的部分可以用来写入新的<code>redo log</code>记录。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L54ep2l4ibKADGr0jytCgLvDW1G8mibfoyn0GNtFXQzSnuu9lhIAL4sGw4Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>如果<code>write pos</code>追上<code>checkpoint</code>，表示<strong>日志文件组</strong>满了，这时候不能再写入新的<code>redo log</code>记录，<code>MySQL</code>得停下来，清空一些记录，把<code>checkpoint</code>推进一下。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nzoia78ia1wnynufibsPx05L5428py5ic4JkiaD7hyKr8zZZbCZjtb0Ah7x8Vy7t15gBN2eaGs5a5icvZ2Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<h4 id=\"注意\"> 注意：</h4>\n<p>在数据已经刷盘之后，会从 redo log 日志文件里删除。</p>\n<h3 id=\"小结\"> 小结</h3>\n<p>现在我们来思考一问题，只要每次把修改后的数据页直接刷盘不就好了，还有<code>redo log</code>什么事。</p>\n<p>它们不都是刷盘么？差别在哪里？</p>\n<p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几<code>Byte</code>数据，有必要把完整的数据页刷盘吗？</p>\n<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>\n<p>如果是写<code>redo log</code>，一行记录可能就占几十<code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p>\n<p>所以用<code>redo log</code>形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>\n",
      "date_modified": "2022-04-29T06:23:42.990Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "undoLog",
      "url": "https://fmiles.cn/database/mysql/UndoLog/",
      "id": "https://fmiles.cn/database/mysql/UndoLog/",
      "content_html": "<h2 id=\"undo-log-格式\"> Undo log 格式</h2>\n<p>在InnoDB引擎中，undo log分为：</p>\n<ul>\n<li>insert undo log</li>\n<li>update undo log</li>\n</ul>\n<p>insert undo log是指在insert操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除，不需要进行purge操作。而update undo log记录的是delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除，提交时放入undo log链表，等待purge线程进行最后的删除。</p>\n<h2 id=\"purge\"> purge</h2>\n<p>对于一条delete语句 <code>delete from t where a = 1</code>，如果列a有聚集索引，则不会进行真正的删除，而只是在主键列等于1的记录delete flag设置为1，即记录还是存在在B+树中。而对于update操作，不是直接对记录进行更新，而是标识旧记录为删除状态，然后新产生一条记录。那这些旧版本标识位删除的记录何时真正的删除？怎么删除？</p>\n<p>其实InnoDB是通过undo日志来进行旧版本的删除操作的，在InnoDB内部，这个操作被称之为purge操作，原来在srv_master_thread主线程中完成，后来进行优化，开辟了purge线程进行purge操作，并且可以设置purge线程的数量。purge操作每10s进行一次。</p>\n<p>为了节省存储空间，InnoDB存储引擎的undo log设计是这样的：一个页上允许多个事务的undo log存在。虽然这不代表事务在全局过程中提交的顺序，但是后面的事务产生的undo log总在最后。此外，InnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行连接，如下面的一种情况：</p>\n<img src=\"images/999329-50f21af4015111d3.png\" alt=\"img\" style=\"zoom:80%;\" />\n<p>在执行purge过程中，InnoDB存储引擎首先从history list中找到第一个需要被清理的记录，这里为trx1，清理之后InnoDB存储引擎会在trx1所在的Undo page中继续寻找是否存在可以被清理的记录，这里会找到事务trx3，接着找到trx5，但是发现trx5被其他事务所引用而不能清理，故再去history list中取查找，发现最尾端的记录时trx2，接着找到trx2所在的Undo page，依次把trx6、trx4清理，由于Undo page2中所有的记录都被清理了，因此该Undo page可以进行重用。</p>\n<p>InnoDB存储引擎这种先从history list中找undo log，然后再从Undo page中找undo log的设计模式是为了避免大量随机读操作，从而提高purge的效率。</p>\n<p>Uodolog 会产生 redolog，也就是undolog 的产生会伴随着 redo log 的产生，这是因为 undolog 也需要持久性的保护。</p>\n",
      "date_modified": "2022-04-29T06:23:42.990Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MVCC",
      "url": "https://fmiles.cn/database/mysql/mvcc/",
      "id": "https://fmiles.cn/database/mysql/mvcc/",
      "content_html": "<h2 id=\"innodb存储引擎的行结构\"> InnoDB存储引擎的行结构</h2>\n<p>InnoDB表数据的组织方式为主键聚簇索引，二级索引中采用的是(索引键值, 主键键值)的组合来唯一确定一条记录。</p>\n<p>InnoDB表数据为主键聚簇索引,mysql默认为每个索引行添加了4个隐藏的字段,分别是：</p>\n<ul>\n<li>**DB_ROW_ID：**InnoDB引擎中一个表只能有一个主键,用于聚簇索引,如果表没有定义主键会选择第一个非Null的唯一索引作为主键,如果还没有,生成一个隐藏的DB_ROW_ID作为主键构造聚簇索引。</li>\n<li>**DB_TRX_ID：**最近更改该行数据的事务ID。</li>\n<li>**DB_ROLL_PTR：**undo log的指针,用于记录之前历史数据在undo log中的位置。</li>\n<li>**DELETE BIT：**索引删除标志,如果DB删除了一条数据,是优先通知索引将该标志位设置为1,然后通过(purge)清除线程去异步删除真实的数据。</li>\n</ul>\n<img src=\"images/999329-93c151894ec951fa.png\" alt=\"img\" style=\"zoom:80%;\" />\n<p>整个MVCC的机制都是通过<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>这2个隐藏字段来实现的。</p>\n<h2 id=\"事务链表\"> 事务链表</h2>\n<p>当一个事务开始的时候,会将当前数据库中正在活跃的所有事务(执行begin,但是还没有commit的事务)保存到一个叫<code>trx_sys</code>的事务链表中,事务链表中保存的都是未提交的事务,当事务提交之后会从其中删除。</p>\n<img src=\"images/999329-e836b86aa4cd7630.png\" alt=\"img\" style=\"zoom:80%;\" />\n<h2 id=\"readview\"> ReadView</h2>\n<p>ReadView说白了就是一个数据结构，在事务开始的时候会根据上面的事务链表构造一个ReadView,初始化方法如下：</p>\n<div><pre><code><span>// readview 初始化</span>\n<span>// m_low_limit_id = trx_sys->max_trx_id; </span>\n<span>// m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span>\n<span>ReadView</span><span>::</span><span>ReadView</span><span>(</span><span>)</span>\n    <span>:</span>\n    <span>m_low_limit_id</span><span>(</span><span>)</span><span>,</span>\n    <span>m_up_limit_id</span><span>(</span><span>)</span><span>,</span>\n    <span>m_creator_trx_id</span><span>(</span><span>)</span><span>,</span>\n    <span>m_ids</span><span>(</span><span>)</span><span>,</span>\n    <span>m_low_limit_no</span><span>(</span><span>)</span>\n<span>{</span>\n    <span>ut_d</span><span>(</span><span>::</span><span>memset</span><span>(</span><span>&amp;</span>m_view_list<span>,</span> <span>0x0</span><span>,</span> <span>sizeof</span><span>(</span>m_view_list<span>)</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>总共做了以下几件事：</p>\n<ol>\n<li>活跃事务链表(<code>trx_sys</code>)中事务id最大的值被赋值给<code>m_low_limit_id</code>。</li>\n<li>活跃事务链表中第一个值(也就是事务id最小)被赋值给<code>m_up_limit_id</code>。</li>\n<li><code>m_ids</code> 为事务链表。</li>\n</ol>\n<img src=\"images/999329-a67509d48416e3b1.png\" alt=\"img\" style=\"zoom:80%;\" />\n<p>通过该ReadView，新的事务可以根据查询到的所有活跃事务记录的事务ID来匹配能够看见该记录，从而实现数据库的事务隔离，主要逻辑如下：</p>\n<ol>\n<li>通过聚簇索引的行结构中DB_TRX_ID隐藏字段可以知道最近被哪个事务ID修改过。</li>\n<li>一个新的事务开始时会根据事务链表构造一个ReadView。</li>\n<li>当前事务根据ReadView中的数据去跟检索到的每一条数据去校验,看看当前事务是不是能看到这条数据。</li>\n</ol>\n<p>那么问题来了，怎么来判断可见性呢？我们来通过源码一探究竟：</p>\n<div><pre><code><span>// 判断数据对应的聚簇索引中的事务id在这个readview中是否可见</span>\nbool <span>changes_visible</span><span>(</span>\n        trx_id_t        id<span>,</span> <span>// 记录的id</span>\n    <span>const</span> table_name_t<span>&amp;</span> name<span>)</span> <span>const</span>\n<span>MY_ATTRIBUTE</span><span>(</span><span>(</span>warn_unused_result<span>)</span><span>)</span>\n<span>{</span>\n    <span>ut_ad</span><span>(</span>id <span>></span> <span>0</span><span>)</span><span>;</span>\n    <span>// 如果当前记录id &lt; 事务链表的最小值或者等于创建该readview的id就是它自己,那么是可见的</span>\n    <span>if</span> <span>(</span>id <span>&lt;</span> m_up_limit_id <span>||</span> id <span>==</span> m_creator_trx_id<span>)</span> <span>{</span>\n        <span>return</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>check_trx_id_sanity</span><span>(</span>id<span>,</span> name<span>)</span><span>;</span>\n    <span>// 如果该记录的事务id大于事务链表中的最大值,那么不可见</span>\n    <span>if</span> <span>(</span>id <span>>=</span> m_low_limit_id<span>)</span> <span>{</span>\n        <span>return</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 如果事务链表是空的,那也是可见的</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>m_ids<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>return</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>const</span> ids_t<span>::</span><span>value_type</span><span>*</span>    p <span>=</span> m_ids<span>.</span><span>data</span><span>(</span><span>)</span><span>;</span>\n\n    <span>//判断是否在ReadView中，如果在说明在创建ReadView时 此条记录还处于活跃状态则不应该查询到，否则说明创建ReadView是此条记录已经是不活跃状态则可以查询到</span>\n    <span>return</span><span>(</span><span>!</span>std<span>::</span><span>binary_search</span><span>(</span>p<span>,</span> p <span>+</span> m_ids<span>.</span><span>size</span><span>(</span><span>)</span><span>,</span> id<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>总结一下可见性判断逻辑：</p>\n<ol>\n<li>当检索到的数据的事务ID小于事务链表中的最小值(数据行的DB_TRX_ID &lt; m_up_limit_id)表示这个数据在当前事务开启前就已经被其他事务修改过了,所以是可见的。</li>\n<li>当检索到的数据的事务ID表示的是当前事务自己修改的数据(数据行的DB_TRX_ID = m_creator_trx_id) 时，数据可见。</li>\n<li>当检索到的数据的事务ID大于事务链表中的最大值(数据行的DB_TRX_ID &gt;= m_low_limit_id) 表示这个数据在当前事务开启后到下一次查询之间又被其他的事务修改过,那么就是不可见的。</li>\n<li>如果事务链表为空,那么也是可见的,也就是当前事务开始的时候,没有其他任意一个事务在执行。</li>\n<li>当检索到的数据的事务ID在事务链表中的最小值和最大值之间，从m_low_limit_id到m_up_limit_id进行遍历，取出DB_ROLL_PTR指针所指向的回滚段的事务ID，把它赋值给 <code>trx_id_current</code> ，然后从步骤1重新开始判断，这样总能最后找到一个可用的记录。</li>\n</ol>\n<h2 id=\"rc和rr隔离级别readview的实现方式\"> RC和RR隔离级别ReadView的实现方式</h2>\n<p>我们知道，RC隔离级别是能看到其他事务提交后的修改记录的，也就是不可重复读，但是RR隔离级别完美的避免了，但是它们都是使用的MVCC机制，那又为何有两种截然不同的结果呢？其实我们看一下他们创建ReadView的区别就知道了。</p>\n<ul>\n<li>在RC事务隔离级别下,每次语句执行都关闭ReadView,然后重新创建一份ReadView。</li>\n<li>在RR下,事务开始后第一个读操作创建ReadView,一直到事务结束关闭。</li>\n</ul>\n",
      "date_modified": "2022-04-29T06:23:42.992Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "边读边发",
      "url": "https://fmiles.cn/database/mysql/%E8%BE%B9%E8%AF%BB%E8%BE%B9%E5%8F%91/",
      "id": "https://fmiles.cn/database/mysql/%E8%BE%B9%E8%AF%BB%E8%BE%B9%E5%8F%91/",
      "content_html": "<h1 id=\"边读边发\"> 边读边发</h1>\n<h2 id=\"_1、引子\"> 1、引子</h2>\n<p>我常常会被问到这样一个问题：个人主机内存只有 100G，如今要对一个 200G 的大表作全表扫描，会不会把数据库主机的内存用光了？mysql</p>\n<p>这个问题确实值得担忧，被系统 OOM（out of memory）可不是闹着玩的。可是，反过来想一想，逻辑备份的时候，可不就是作整库扫描吗？若是这样就会把内存吃光，逻辑备份\n不是早就挂了？算法</p>\n<p>因此说，对大表作全表扫描，看来应该是没问题的。可是，这个流程究竟是怎么样的呢？sql</p>\n<h2 id=\"_2、全表扫描对-server-层的影响\"> 2、全表扫描对 server 层的影响</h2>\n<p>假设，咱们如今要对一个 200G 的 InnoDB 表 db1. t，执行一个全表扫描。固然，你要把扫描结果保存在客户端，会使用相似这样的命令：数据库</p>\n<div><pre><code>mysql -h$host -P$port -u$user -p$pwd -e &quot;select * from db1.t&quot; &gt; $target_file\n</code></pre>\n<div><span>1</span><br></div></div><p>你已经知道了，InnoDB 的数据是保存在主键索引上的，因此全表扫描其实是直接扫描表 t 的主键索引。这条查询语句因为没有其余的判断条件，因此查到的每一行均可以直接放到结果集里面，而后返回给客户端。</p>\n<h3 id=\"一、mysql-查询结果发送流程\"> 一、MySQL 查询结果发送流程</h3>\n<p>那么，这个“结果集”存在哪里呢？服务器</p>\n<p>**实际上，服务端并不须要保存一个完整的结果集。取数据和发数据的流程是这样的：**网络</p>\n<ol>\n<li>\n<p>获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。</p>\n</li>\n<li>\n<p>重复获取行，直到 net_buffer 写满，调用网络接口发出去。</p>\n</li>\n<li>\n<p>若是发送成功，就清空 net_buffer，而后继续取下一行，并写入 net_buffer。</p>\n</li>\n<li>\n<p>若是发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socketsend buffer）写满了，进入等待。直到网络栈从新可写，再继续发送。</p>\n</li>\n</ol>\n<p><strong>这个过程对应的流程图以下所示。</strong></p>\n<p><img src=\"./images/749_e1b_062.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>从这个流程中，你能够看到：</strong></p>\n<ol>\n<li>一个查询在发送过程当中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，并不会达到 200G；</li>\n<li>socket send buffer 也不可能达到 200G（默认定义/proc/sys/net/core/wmem_default），若是 socket send buffer 被写满，就会暂停读数据的流程。</li>\n</ol>\n<h3 id=\"二、mysql-是-边读边发的\"> 二、MySQL 是“边读边发的</h3>\n<p>也就\t是说，MySQL 是“边读边发的”，这个概念很重要。这就意味着，若是客户端接收得慢，会致使 MySQL 服务端因为结果发不出去，这个事务的执行时间变长。</p>\n<p>好比下面这个状态，就是我故意让客户端不去读 socket receive buffer 中的内容，而后在服务端 show processlist 看到的结果。</p>\n<p><img src=\"./images/750_d5a_a84.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<p>若是你看到 State 的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。</p>\n<p>若是客户端使用 –quick 参数，会使用 mysql_use_result 方法。这个方法是读一行处理一行。你能够想象一下，假设有一个业务的逻辑比较复杂，每\n读一行数据之后要处理的逻辑若是很慢，就会致使客户端要过好久才会去取下一行数据，可能就会出现如图 2 所示的这种状况。</p>\n<p>所以，对于正常的线上业务来讲，若是一个查询的返回结果不会不少的话，我都建议你使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。</p>\n",
      "date_modified": "2022-04-29T06:23:42.992Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "分布式事务",
      "url": "https://fmiles.cn/distributed-system/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/",
      "id": "https://fmiles.cn/distributed-system/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/",
      "content_html": "<p><img src=\"./images/20210710220330858.png\" alt=\"img\" loading=\"lazy\"></p>\n<h4 id=\"分布式事务和分布式锁的区别\"> 分布式事务和分布式锁的区别</h4>\n<p>分布式锁解决的是分布式资源抢占的问题；分布式事务和本地事务是解决流程化提交问题。</p>\n<h2 id=\"分布式事务出现背景\"> 分布式事务出现背景</h2>\n<p>当本地事务要扩展到分布式时，它的复杂性进一步增加了。</p>\n<p><strong>存储端的多样性：</strong></p>\n<p>首先就是存储端的多样性。本地事务的情况下，所有数据都会落到同一个DB中，但是，在分布式的情况下，就会出现数据可能要落到多个DB，或者还会落到Redis，落到MQ等中。</p>\n<p><strong>事务链路的延展性</strong>：</p>\n<p>本地事务的情况下，通常所有事务相关的业务操作，会被我们封装到一个Service方法中。而在分布式的情况下，请求链路被延展，拉长，一个操作会被拆分成多个服务，它们呈现线状或网状，依靠网络通信构建成一个整体。在这种情况下，事务无疑变得更复杂。</p>\n<p>基于上述两个复杂性，期望有一个统一的分布式事务方案，能够像本地事务一样，以几乎无侵入的方式，满足各种存储介质，各种复杂链路，是不现实的。至少，在当前，还没有一个十分成熟的解决方案。所以，一般情况下，在分布式下，事务会被拆分解决，并根据不同的情况，采用不同的解决方案。</p>\n<h2 id=\"什么是分布式事务\"> 什么是分布式事务</h2>\n<p>对于分布式系统而言，需要保证分布式系统中的数据一致性，保证数据在子系统中始终保持一致，避免业务出现问题。分布式系统中对数要么一起成功，要么一起失败，必须是一个整体性的事务。</p>\n<p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>\n<p>简单的说，在分布式系统上一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务节点上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p>\n<p>举个例子：在电商网站中，用户对商品进行下单，需要在订单表中创建一条订单数据，同时需要在库存表中修改当前商品的剩余库存数量，两步操作一个添加，一个修改，我们一定要保证这两步操作一定同时操作成功或失败，否则业务就会出现问题。</p>\n<p>任何事务机制在实现时，都应该考虑事务的ACID特性，包括：本地事务、分布式事务。对于分布式事务而言，即使不能都很好的满足，也要考虑支持到什么程度。</p>\n<h4 id=\"典型的分布式事务场景\"> 典型的分布式事务场景</h4>\n<h5 id=\"_1、跨库事务\"> 1、跨库事务</h5>\n<p>跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。</p>\n<h5 id=\"_2、分库分表\"> 2、分库分表</h5>\n<p>通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。</p>\n<h5 id=\"_3、微服务化\"> 3、微服务化</h5>\n<h2 id=\"cap-理论\"> CAP 理论</h2>\n<p>CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能能同时满足以下三点中的两个：</p>\n<ul>\n<li><strong>一致性（Consistence）</strong> : 一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值 (这个无论哪个节点就包含了故障和非故障节点)</li>\n<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>\n<li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>\n</ul>\n<h6 id=\"网络分区\"> 网络分区？</h6>\n<blockquote>\n<p>​\t\t分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p>\n</blockquote>\n<p>​        <strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>\n<h5 id=\"分布式一致性的-3-种级别\"> 分布式一致性的 3 种级别：</h5>\n<ul>\n<li>\n<p><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</p>\n</li>\n<li>\n<p><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</p>\n</li>\n<li>\n<p><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</p>\n</li>\n</ul>\n<h2 id=\"base-理论\"> BASE 理论</h2>\n<p>CA 都要是无法实现的，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而追求最终一致性，所以引入 BASE 理论，在分布式事务中，BASE 最重要是为 CAP 提出了最终一致性的解决方案，BASE 强调牺牲强一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p>\n<p>1、基本可用：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>\n<p>(1）响应时间上的损失</p>\n<blockquote>\n<p>当出现故障时，响应时间增加</p>\n</blockquote>\n<p>（2）功能上的损失</p>\n<blockquote>\n<p>流量高峰期时，屏蔽一些功能的使用以保证系统稳定性（服务降级）</p>\n</blockquote>\n<p>2、软状态：软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>\n<p>3、最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态</p>\n<p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>\n<h2 id=\"分布式事务分类\"> 分布式事务分类</h2>\n<h3 id=\"柔性事务\"> 柔性事务</h3>\n<p>柔性事务指的是，不要求强一致性，而是要求最终一致性，允许有中间状态，也就是 Base 理论，换句话说，就是 AP 状态。</p>\n<blockquote>\n<p>与刚性事务相比，柔性事务的特点为：有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。</p>\n</blockquote>\n<p>柔性事务分为：</p>\n<ul>\n<li>补偿型</li>\n<li>异步确保型</li>\n<li>最大努力通知型。</li>\n</ul>\n<p>柔型事务：TCC/FMT、Saga（状态机模式、Aop模式）、本地事务消息、消息事务（半消息）</p>\n<h3 id=\"刚性事务\"> 刚性事务</h3>\n<p>刚性事务指的是，要使分布式事务，达到像本地式事务一样，具备数据强一致性，从 CAP 来看，就是说，要达到 CP 状态。</p>\n<blockquote>\n<p>刚性事务：通常无业务改造，强一致性，原生支持回滚/隔离性，低并发，适合短事务。</p>\n</blockquote>\n<p>刚性事务：XA 协议（2PC、JTA、JTS）、3PC，但由于同步阻塞，处理效率低，不适合大型网站分布式场景。</p>\n<h3 id=\"\"> </h3>\n<h4 id=\"参考\"> 参考：</h4>\n<p>https://www.cnblogs.com/crazymakercircle/p/13917517.html</p>\n",
      "date_modified": "2022-04-29T06:23:42.993Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "bean AOP",
      "url": "https://fmiles.cn/frame/spring/AOP/",
      "id": "https://fmiles.cn/frame/spring/AOP/",
      "content_html": "<p>Spring AOP 的原理很简单，就是<strong>动态代理</strong>，它和 AspectJ 不一样，AspectJ 是直接修改掉你的字节码。</p>\n<p>DefaultAdvisorAutoProxyCreator 类，它能实现自动将所有的 advisor 生效，而不需要配置代理类。</p>\n<p>我们来追踪下 DefaultAdvisorAutoProxyCreator 类，看看它是怎么一步步实现的动态代理。然后在这个基础上，我们再简单追踪下 @AspectJ 配置方式下的源码实现。</p>\n<p>首先，先看下 DefaultAdvisorAutoProxyCreator 的继承结构：</p>\n<img src=\"images/1.png\" alt=\"1\" style=\"zoom: 50%;\" />\n<p>我们可以发现，DefaultAdvisorAutoProxyCreator 最后居然是一个 <strong>BeanPostProcessor</strong>，在 Spring IOC 源码分析的时候说过，BeanPostProcessor 的两个方法，分别在 init-method 的前后得到执行。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>BeanPostProcessor</span> <span>{</span>\n    <span>Object</span> <span>postProcessBeforeInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n    <span>Object</span> <span>postProcessAfterInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过 Bean 的创建过程中的 initializeBean 方法：</p>\n<div><pre><code><span>protected</span> <span>Object</span> <span>initializeBean</span><span>(</span><span>final</span> <span>String</span> beanName<span>,</span> <span>final</span> <span>Object</span> bean<span>,</span> <span>RootBeanDefinition</span> mbd<span>)</span> <span>{</span>\n   <span>.</span><span>.</span><span>.</span>\n   <span>Object</span> wrappedBean <span>=</span> bean<span>;</span>\n   <span>if</span> <span>(</span>mbd <span>==</span> <span>null</span> <span>||</span> <span>!</span>mbd<span>.</span><span>isSynthetic</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>// 1. 执行每一个 BeanPostProcessor 的 postProcessBeforeInitialization 方法</span>\n      wrappedBean <span>=</span> <span>applyBeanPostProcessorsBeforeInitialization</span><span>(</span>wrappedBean<span>,</span> beanName<span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>try</span> <span>{</span>\n      <span>// 调用 bean 配置中的 init-method=\"xxx\"</span>\n      <span>invokeInitMethods</span><span>(</span>beanName<span>,</span> wrappedBean<span>,</span> mbd<span>)</span><span>;</span>\n   <span>}</span>\n   <span>.</span><span>.</span><span>.</span>\n   <span>if</span> <span>(</span>mbd <span>==</span> <span>null</span> <span>||</span> <span>!</span>mbd<span>.</span><span>isSynthetic</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>// 我们关注的重点是这里！！！</span>\n      <span>// 2. 执行每一个 BeanPostProcessor 的 postProcessAfterInitialization 方法</span>\n      wrappedBean <span>=</span> <span>applyBeanPostProcessorsAfterInitialization</span><span>(</span>wrappedBean<span>,</span> beanName<span>)</span><span>;</span>\n   <span>}</span>\n   <span>return</span> wrappedBean<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>applyBeanPostProcessorsAfterInitialization 方法中会调用 postProcessAfterInitialization：</p>\n<div><pre><code><span>@Override</span>\n<span>public</span> <span>Object</span> <span>applyBeanPostProcessorsAfterInitialization</span><span>(</span><span>Object</span> existingBean<span>,</span> <span>String</span> beanName<span>)</span>\n      <span>throws</span> <span>BeansException</span> <span>{</span>\n\n   <span>Object</span> result <span>=</span> existingBean<span>;</span>\n   <span>for</span> <span>(</span><span>BeanPostProcessor</span> processor <span>:</span> <span>getBeanPostProcessors</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>Object</span> current <span>=</span> processor<span>.</span><span>postProcessAfterInitialization</span><span>(</span>result<span>,</span> beanName<span>)</span><span>;</span>\n      <span>if</span> <span>(</span>current <span>==</span> <span>null</span><span>)</span> <span>{</span>\n         <span>return</span> result<span>;</span>\n      <span>}</span>\n      result <span>=</span> current<span>;</span>\n   <span>}</span>\n   <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>也就是说，Spring AOP 会在 IOC 容器创建 bean 实例的最后对 bean 进行处理。其实就是在这一步进行代理增强。</p>\n<p>我们回过头来，DefaultAdvisorAutoProxyCreator 的继承结构中，postProcessAfterInitialization() 方法在其父类 AbstractAutoProxyCreator 这一层被覆写了：</p>\n<div><pre><code><span>// AbstractAutoProxyCreator</span>\n<span>@Override</span>\n<span>public</span> <span>Object</span> <span>postProcessAfterInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n   <span>if</span> <span>(</span>bean <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>Object</span> cacheKey <span>=</span> <span>getCacheKey</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>)</span><span>;</span>\n      <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>earlyProxyReferences<span>.</span><span>contains</span><span>(</span>cacheKey<span>)</span><span>)</span> <span>{</span>\n         <span>return</span> <span>wrapIfNecessary</span><span>(</span>bean<span>,</span> beanName<span>,</span> cacheKey<span>)</span><span>;</span>\n      <span>}</span>\n   <span>}</span>\n   <span>return</span> bean<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>继续往里看 wrapIfNecessary(...) 方法，这个方法将返回代理类（如果需要的话）。其实到这了 AOP 已经借差不多了，下面是怎么实现动态代理的：</p>\n<div><pre><code><span>protected</span> <span>Object</span> <span>wrapIfNecessary</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>,</span> <span>Object</span> cacheKey<span>)</span> <span>{</span>\n   <span>if</span> <span>(</span>beanName <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>this</span><span>.</span>targetSourcedBeans<span>.</span><span>contains</span><span>(</span>beanName<span>)</span><span>)</span> <span>{</span>\n      <span>return</span> bean<span>;</span>\n   <span>}</span>\n   <span>if</span> <span>(</span><span>Boolean</span><span>.</span>FALSE<span>.</span><span>equals</span><span>(</span><span>this</span><span>.</span>advisedBeans<span>.</span><span>get</span><span>(</span>cacheKey<span>)</span><span>)</span><span>)</span> <span>{</span>\n      <span>return</span> bean<span>;</span>\n   <span>}</span>\n   <span>if</span> <span>(</span><span>isInfrastructureClass</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span> <span>||</span> <span>shouldSkip</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>)</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>advisedBeans<span>.</span><span>put</span><span>(</span>cacheKey<span>,</span> <span>Boolean</span><span>.</span>FALSE<span>)</span><span>;</span>\n      <span>return</span> bean<span>;</span>\n   <span>}</span>\n\n   <span>// 返回匹配当前 bean 的所有的 advisor、advice、interceptor</span>\n   <span>// 对于本文的例子，\"userServiceImpl\" 和 \"OrderServiceImpl\" 这两个 bean 创建过程中，</span>\n   <span>//   到这边的时候都会返回两个 advisor</span>\n   <span>Object</span><span>[</span><span>]</span> specificInterceptors <span>=</span> <span>getAdvicesAndAdvisorsForBean</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>,</span> <span>null</span><span>)</span><span>;</span>\n   <span>if</span> <span>(</span>specificInterceptors <span>!=</span> DO_NOT_PROXY<span>)</span> <span>{</span>\n      <span>this</span><span>.</span>advisedBeans<span>.</span><span>put</span><span>(</span>cacheKey<span>,</span> <span>Boolean</span><span>.</span>TRUE<span>)</span><span>;</span>\n      <span>// 创建代理...创建代理...创建代理...</span>\n      <span>Object</span> proxy <span>=</span> <span>createProxy</span><span>(</span>\n            bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>,</span> specificInterceptors<span>,</span> <span>new</span> <span>SingletonTargetSource</span><span>(</span>bean<span>)</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>proxyTypes<span>.</span><span>put</span><span>(</span>cacheKey<span>,</span> proxy<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>return</span> proxy<span>;</span>\n   <span>}</span>\n\n   <span>this</span><span>.</span>advisedBeans<span>.</span><span>put</span><span>(</span>cacheKey<span>,</span> <span>Boolean</span><span>.</span>FALSE<span>)</span><span>;</span>\n   <span>return</span> bean<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>这里有两个点提一下：</p>\n<p>getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)，这个方法将得到所有的<strong>可用于拦截当前 bean 的</strong> advisor、advice、interceptor。</p>\n<div><pre><code><span>// 注意看这个方法的几个参数，</span>\n<span>//   第三个参数携带了所有的 advisors</span>\n<span>//   第四个参数 targetSource 携带了真实实现的信息</span>\n<span>protected</span> <span>Object</span> <span>createProxy</span><span>(</span>\n      <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> beanClass<span>,</span> <span>String</span> beanName<span>,</span> <span>Object</span><span>[</span><span>]</span> specificInterceptors<span>,</span> <span>TargetSource</span> targetSource<span>)</span> <span>{</span>\n\n   <span>if</span> <span>(</span><span>this</span><span>.</span>beanFactory <span>instanceof</span> <span>ConfigurableListableBeanFactory</span><span>)</span> <span>{</span>\n      <span>AutoProxyUtils</span><span>.</span><span>exposeTargetClass</span><span>(</span><span>(</span><span>ConfigurableListableBeanFactory</span><span>)</span> <span>this</span><span>.</span>beanFactory<span>,</span> beanName<span>,</span> beanClass<span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>// 创建 ProxyFactory 实例</span>\n   <span>ProxyFactory</span> proxyFactory <span>=</span> <span>new</span> <span>ProxyFactory</span><span>(</span><span>)</span><span>;</span>\n   proxyFactory<span>.</span><span>copyFrom</span><span>(</span><span>this</span><span>)</span><span>;</span>\n\n   <span>// 在 schema-based 的配置方式中，我们介绍过，如果希望使用 CGLIB 来代理接口，可以配置</span>\n   <span>// proxy-target-class=\"true\",这样不管有没有接口，都使用 CGLIB 来生成代理：</span>\n   <span>//   &lt;aop:config proxy-target-class=\"true\">......&lt;/aop:config></span>\n   <span>if</span> <span>(</span><span>!</span>proxyFactory<span>.</span><span>isProxyTargetClass</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>shouldProxyTargetClass</span><span>(</span>beanClass<span>,</span> beanName<span>)</span><span>)</span> <span>{</span>\n         proxyFactory<span>.</span><span>setProxyTargetClass</span><span>(</span><span>true</span><span>)</span><span>;</span>\n      <span>}</span>\n      <span>else</span> <span>{</span>\n         <span>// 点进去稍微看一下代码就知道了，主要就两句：</span>\n         <span>// 1. 有接口的，调用一次或多次：proxyFactory.addInterface(ifc);</span>\n         <span>// 2. 没有接口的，调用：proxyFactory.setProxyTargetClass(true);</span>\n         <span>evaluateProxyInterfaces</span><span>(</span>beanClass<span>,</span> proxyFactory<span>)</span><span>;</span>\n      <span>}</span>\n   <span>}</span>\n\n   <span>// 这个方法会返回匹配了当前 bean 的 advisors 数组</span>\n   <span>// 对于本文的例子，\"userServiceImpl\" 和 \"OrderServiceImpl\" 到这边的时候都会返回两个 advisor</span>\n   <span>// 注意：如果 specificInterceptors 中有 advice 和 interceptor，它们也会被包装成 advisor，进去看下源码就清楚了</span>\n   <span>Advisor</span><span>[</span><span>]</span> advisors <span>=</span> <span>buildAdvisors</span><span>(</span>beanName<span>,</span> specificInterceptors<span>)</span><span>;</span>\n   <span>for</span> <span>(</span><span>Advisor</span> advisor <span>:</span> advisors<span>)</span> <span>{</span>\n      proxyFactory<span>.</span><span>addAdvisor</span><span>(</span>advisor<span>)</span><span>;</span>\n   <span>}</span>\n\n   proxyFactory<span>.</span><span>setTargetSource</span><span>(</span>targetSource<span>)</span><span>;</span>\n   <span>customizeProxyFactory</span><span>(</span>proxyFactory<span>)</span><span>;</span>\n\n   proxyFactory<span>.</span><span>setFrozen</span><span>(</span><span>this</span><span>.</span>freezeProxy<span>)</span><span>;</span>\n   <span>if</span> <span>(</span><span>advisorsPreFiltered</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      proxyFactory<span>.</span><span>setPreFiltered</span><span>(</span><span>true</span><span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>return</span> proxyFactory<span>.</span><span>getProxy</span><span>(</span><span>getProxyClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>这个方法主要是在内部创建了一个 ProxyFactory 的实例，然后 set 了一大堆内容，剩下的工作就都是这个 ProxyFactory 实例的了，通过这个实例来创建代理: <code>getProxy(classLoader)</code>。</p>\n<h3 id=\"proxyfactory-详解\"> ProxyFactory 详解</h3>\n<p>顺着上面的路子，我们首先到 ProxyFactory#getProxy(classLoader) 方法：</p>\n<div><pre><code><span>public</span> <span>Object</span> <span>getProxy</span><span>(</span><span>ClassLoader</span> classLoader<span>)</span> <span>{</span>\n   <span>return</span> <span>createAopProxy</span><span>(</span><span>)</span><span>.</span><span>getProxy</span><span>(</span>classLoader<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该方法首先通过 createAopProxy() 创建一个 AopProxy 的实例：</p>\n<div><pre><code><span>protected</span> <span>final</span> <span>synchronized</span> <span>AopProxy</span> <span>createAopProxy</span><span>(</span><span>)</span> <span>{</span>\n   <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>active<span>)</span> <span>{</span>\n      <span>activate</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n   <span>return</span> <span>getAopProxyFactory</span><span>(</span><span>)</span><span>.</span><span>createAopProxy</span><span>(</span><span>this</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>创建 AopProxy 之前，我们需要一个 AopProxyFactory 实例，然后看 ProxyCreatorSupport （ProxyCreatorSupport 就是 ProxyFactory父类 ）的构造方法：</p>\n<div><pre><code><span>public</span> <span>ProxyCreatorSupport</span><span>(</span><span>)</span> <span>{</span>\n   <span>this</span><span>.</span>aopProxyFactory <span>=</span> <span>new</span> <span>DefaultAopProxyFactory</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这样就将我们导到 <code>DefaultAopProxyFactory</code> 这个类了，我们看它的 createAopProxy(…) 方法：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DefaultAopProxyFactory</span> <span>implements</span> <span>AopProxyFactory</span><span>,</span> <span>Serializable</span> <span>{</span>\n\n   <span>@Override</span>\n   <span>public</span> <span>AopProxy</span> <span>createAopProxy</span><span>(</span><span>AdvisedSupport</span> config<span>)</span> <span>throws</span> <span>AopConfigException</span> <span>{</span>\n      <span>// (我也没用过这个optimize，默认false) || (proxy-target-class=true) || (没有接口)</span>\n      <span>if</span> <span>(</span>config<span>.</span><span>isOptimize</span><span>(</span><span>)</span> <span>||</span> config<span>.</span><span>isProxyTargetClass</span><span>(</span><span>)</span> <span>||</span> <span>hasNoUserSuppliedProxyInterfaces</span><span>(</span>config<span>)</span><span>)</span> <span>{</span>\n         <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass <span>=</span> config<span>.</span><span>getTargetClass</span><span>(</span><span>)</span><span>;</span>\n         <span>if</span> <span>(</span>targetClass <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>AopConfigException</span><span>(</span><span>\"TargetSource cannot determine target class: \"</span> <span>+</span>\n                  <span>\"Either an interface or a target is required for proxy creation.\"</span><span>)</span><span>;</span>\n         <span>}</span>\n         <span>// 如果要代理的类本身就是接口，也会用 JDK 动态代理</span>\n         <span>// 我也没用过这个。。。</span>\n         <span>if</span> <span>(</span>targetClass<span>.</span><span>isInterface</span><span>(</span><span>)</span> <span>||</span> <span>Proxy</span><span>.</span><span>isProxyClass</span><span>(</span>targetClass<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>JdkDynamicAopProxy</span><span>(</span>config<span>)</span><span>;</span>\n         <span>}</span>\n         <span>return</span> <span>new</span> <span>ObjenesisCglibAopProxy</span><span>(</span>config<span>)</span><span>;</span>\n      <span>}</span>\n      <span>else</span> <span>{</span>\n         <span>// 如果有接口，会跑到这个分支</span>\n         <span>return</span> <span>new</span> <span>JdkDynamicAopProxy</span><span>(</span>config<span>)</span><span>;</span>\n      <span>}</span>\n   <span>}</span>\n   <span>// 判断是否有实现自定义的接口</span>\n   <span>private</span> <span>boolean</span> <span>hasNoUserSuppliedProxyInterfaces</span><span>(</span><span>AdvisedSupport</span> config<span>)</span> <span>{</span>\n      <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> ifcs <span>=</span> config<span>.</span><span>getProxiedInterfaces</span><span>(</span><span>)</span><span>;</span>\n      <span>return</span> <span>(</span>ifcs<span>.</span>length <span>==</span> <span>0</span> <span>||</span> <span>(</span>ifcs<span>.</span>length <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>SpringProxy</span><span>.</span><span>class</span><span>.</span><span>isAssignableFrom</span><span>(</span>ifcs<span>[</span><span>0</span><span>]</span><span>)</span><span>)</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>到这里，我们知道 createAopProxy 方法有可能返回 JdkDynamicAopProxy 实例，也有可能返回 ObjenesisCglibAopProxy 实例，这里总结一下：</p>\n<p>如果被代理的目标类实现了一个或多个自定义的接口，那么就会使用 JDK 动态代理，如果没有实现任何接口，会使用 CGLIB 实现代理，如果设置了 proxy-target-class=&quot;true&quot;，那么都会使用 CGLIB。</p>\n<p>JDK 动态代理基于接口，所以只有接口中的方法会被增强，而 CGLIB 基于类继承，需要注意就是如果方法使用了 final 修饰，或者是 private 方法，是不能被增强的。</p>\n<p>有了 AopProxy 实例以后，我们就回到这个方法了：</p>\n<div><pre><code><span>public</span> <span>Object</span> <span>getProxy</span><span>(</span><span>ClassLoader</span> classLoader<span>)</span> <span>{</span>\n   <span>return</span> <span>createAopProxy</span><span>(</span><span>)</span><span>.</span><span>getProxy</span><span>(</span>classLoader<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们分别来看下两个 AopProxy 实现类的 getProxy(classLoader) 实现。</p>\n<p>JdkDynamicAopProxy 类的源码比较简单，总共两百多行，</p>\n<div><pre><code><span>@Override</span>\n<span>public</span> <span>Object</span> <span>getProxy</span><span>(</span><span>ClassLoader</span> classLoader<span>)</span> <span>{</span>\n   <span>if</span> <span>(</span>logger<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      logger<span>.</span><span>debug</span><span>(</span><span>\"Creating JDK dynamic proxy: target source is \"</span> <span>+</span> <span>this</span><span>.</span>advised<span>.</span><span>getTargetSource</span><span>(</span><span>)</span><span>)</span><span>;</span>\n   <span>}</span>\n   <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> proxiedInterfaces <span>=</span> <span>AopProxyUtils</span><span>.</span><span>completeProxiedInterfaces</span><span>(</span><span>this</span><span>.</span>advised<span>,</span> <span>true</span><span>)</span><span>;</span>\n   <span>findDefinedEqualsAndHashCodeMethods</span><span>(</span>proxiedInterfaces<span>)</span><span>;</span>\n   <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>classLoader<span>,</span> proxiedInterfaces<span>,</span> <span>this</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>java.lang.reflect.Proxy.newProxyInstance(…) 方法需要三个参数，第一个是 ClassLoader，第二个参数代表需要实现哪些接口，第三个参数最重要，是 InvocationHandler 实例，我们看到这里传了 this，因为 JdkDynamicAopProxy 本身实现了 InvocationHandler 接口。</p>\n<p>InvocationHandler 只有一个方法，当生成的代理类对外提供服务的时候，都会导到这个方法中：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>\n        <span>throws</span> <span>Throwable</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面来看看 JdkDynamicAopProxy 对其的实现：</p>\n<p>就到这把，肝不动了。。。</p>\n<p>参考：</p>\n<p>https://javadoop.com/post/spring-aop-intro</p>\n<p>https://javadoop.com/post/spring-aop-source</p>\n",
      "date_modified": "2022-04-29T06:23:42.996Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "bean 生命周期",
      "url": "https://fmiles.cn/frame/spring/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
      "id": "https://fmiles.cn/frame/spring/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
      "content_html": "<h3 id=\"总体的创建过程\"> 总体的创建过程</h3>\n<p><img src=\"./images/20200224111702108.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>以注解类变成Spring Bean为例，Spring会扫描指定包下面的Java类，然后将其变成beanDefinition对象，然后Spring会根据beanDefinition来创建bean，特别要记住一点，Spring是根据beanDefinition来创建Spring bean的</p>\n<h3 id=\"java类-beandefinition对象\"> <strong>java类 -&gt; beanDefinition对象</strong></h3>\n<div><pre><code><span>@Override</span>\n<span>public</span> <span>void</span> <span>refresh</span><span>(</span><span>)</span> <span>throws</span> <span>BeansException</span><span>,</span> <span>IllegalStateException</span> <span>{</span>\n    <span>synchronized</span> <span>(</span><span>this</span><span>.</span>startupShutdownMonitor<span>)</span> <span>{</span>\n        <span>// Prepare this context for refreshing.</span>\n        准备工作包括设置启动时间，是否激活标识位，\n            <span>// 初始化属性源(property source)配置</span>\n            <span>prepareRefresh</span><span>(</span><span>)</span><span>;</span>\t\n        <span>// Tell the subclass to refresh the internal bean factory.</span>\n        <span>//返回一个factory 为什么需要返回一个工厂</span>\n        <span>//因为要对工厂进行初始化</span>\n        <span>ConfigurableListableBeanFactory</span> beanFactory <span>=</span> <span>obtainFreshBeanFactory</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// Prepare the bean factory for use in this context.</span>\n        <span>//准备工厂</span>\n        <span>prepareBeanFactory</span><span>(</span>beanFactory<span>)</span><span>;</span>\n\n        <span>try</span> <span>{</span>\n            <span>// Allows post-processing of the bean factory in context subclasses.</span>\n            <span>//这个方法在当前版本的spring是没用任何代码的</span>\n            <span>//可能spring期待在后面的版本中去扩展吧</span>\n            <span>postProcessBeanFactory</span><span>(</span>beanFactory<span>)</span><span>;</span>\n\n            <span>// Invoke factory processors registered as beans in the context.</span>\n            <span>//在spring的环境中去执行已经被注册的 factory processors</span>\n            <span>//设置执行自定义的ProcessBeanFactory 和spring内部自己定义的</span>\n            <span>invokeBeanFactoryPostProcessors</span><span>(</span>beanFactory<span>)</span><span>;</span>\n\n            <span>// Register bean processors that intercept bean creation.</span>\n            <span>//注册beanPostProcessor</span>\n            <span>registerBeanPostProcessors</span><span>(</span>beanFactory<span>)</span><span>;</span>\n\n            <span>// Initialize message source for this context.</span>\n            <span>initMessageSource</span><span>(</span><span>)</span><span>;</span>\n\n            <span>// Initialize event multicaster for this context.</span>\n            <span>//初始化应用事件广播器</span>\n            <span>initApplicationEventMulticaster</span><span>(</span><span>)</span><span>;</span>\n\n            <span>// Initialize other special beans in specific context subclasses.</span>\n            <span>onRefresh</span><span>(</span><span>)</span><span>;</span>\n\n            <span>// Check for listener beans and register them.</span>\n            <span>registerListeners</span><span>(</span><span>)</span><span>;</span>\n\n            <span>// Instantiate all remaining (non-lazy-init) singletons.</span>\n            <span>finishBeanFactoryInitialization</span><span>(</span>beanFactory<span>)</span><span>;</span>\n\n            <span>// Last step: publish corresponding event.</span>\n            <span>finishRefresh</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>catch</span> <span>(</span><span>BeansException</span> ex<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>logger<span>.</span><span>isWarnEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                logger<span>.</span><span>warn</span><span>(</span><span>\"Exception encountered during context initialization - \"</span> <span>+</span>\n                            <span>\"cancelling refresh attempt: \"</span> <span>+</span> ex<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>// Destroy already created singletons to avoid dangling resources.</span>\n            <span>destroyBeans</span><span>(</span><span>)</span><span>;</span>\n\n            <span>// Reset 'active' flag.</span>\n            <span>cancelRefresh</span><span>(</span>ex<span>)</span><span>;</span>\n\n            <span>// Propagate exception to caller.</span>\n            <span>throw</span> ex<span>;</span>\n        <span>}</span>\n\n        <span>finally</span> <span>{</span>\n            <span>// Reset common introspection caches in Spring's core, since we</span>\n            <span>// might not ever need metadata for singleton beans anymore...</span>\n            <span>resetCommonCaches</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p>有关Spring Bean生命周期最主要的方法有三个invokeBeanFactoryPostProcessors、registerBeanPostProcessors和finishBeanFactoryInitialization。</p>\n<p>​\t其中invokeBeanFactoryPostProcessors方法会执行BeanFactoryPostProcessors后置处理器及其子接口BeanDefinitionRegistryPostProcessor，执行顺序先是执行BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法，然后执行BeanFactoryPostProcessor接口的postProcessBeanFactory方法。</p>\n<p>对于BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法，该步骤会扫描到指定包下面的标有注解的类，然后将其变成BeanDefinition对象，然后放到一个Spring中的Map中，用于下面创建 Spring bean 的时候使用这个BeanDefinition</p>\n<p>其中 registerBeanPostProcessors 方法根据实现了 PriorityOrdered、Ordered 接口，排序后注册所有的 BeanPostProcessor 后置处理器，主要用于 Spring Bean 创建时，执行这些后置处理器的方法，这也是 Spring 中提供的扩展点，让我们能够插手 Spring bean 创建过程。</p>\n<p><img src=\"./images/20200224114129481.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"beandefinition对象-spring中的bean\"> <strong>beanDefinition对象 -&gt; Spring中的bean</strong></h3>\n<p>​    finishBeanFactoryInitialization 是完成非懒加载的 Spring bean 的创建的工作，你要想说 Spring 的生命周期，不要整其他没用的，直接告诉他在该步骤中会有8个后置处理的方法4个后置处理器的类贯穿在对象的实例化、赋值、初始化、和销毁的过程中，这4个后置处理器出现的地方分别为：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020072612595369.png\" alt=\"img\" loading=\"lazy\"></p>\n<h4 id=\"关于每个后置处理的作用如下\"> 关于每个后置处理的作用如下：</h4>\n<p><img src=\"./images/20200707132832315.png\" alt=\"img\" loading=\"lazy\"></p>\n<h4 id=\"一、instantiationawarebeanpostprocessor\"> 一、InstantiationAwareBeanPostProcessor</h4>\n<p>添加实例化前回调的 BeanPostProcessor 子接口，以及实例化后但在设置显式属性或发生自动装配之前的回调。\n通常用于抑制特定目标 bean 的默认实例化，例如创建具有特殊 TargetSources 的代理（池化目标、延迟初始化目标等），或实现额外的注入策略，如字段注入。\n注意：此接口为专用接口，主要供框架内部使用。</p>\n<p>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);方法里面执行了这个后置处理器。</p>\n<h4 id=\"二、smartinstantiationawarebeanpostprocessor\"> 二、SmartInstantiationAwareBeanPostProcessor</h4>\n<p>InstantiationAwareBeanPostProcessor接口的扩展，添加了用于预测已处理 bean 的最终类型的回调。</p>\n<h4 id=\"三、mergedbeandefinitionpostprocessor\"> 三、MergedBeanDefinitionPostProcessor</h4>\n<p>BeanDefition 相关</p>\n<h4 id=\"四、smartinitializingsingleton\"> 四、SmartInitializingSingleton</h4>\n<p>智能初始化Singleton，该接口只有一个方法，是在所有的非懒加载单实例bean都成功创建并且放到Spring IOC容器之后进行执行的。</p>\n<h4 id=\"下面按照图中的顺序进行说明每个后置处理的作用\"> 下面按照图中的顺序进行说明每个后置处理的作用：</h4>\n<h5 id=\"对象实例化之前\"> 对象实例化之前：</h5>\n<h5 id=\"_1、instantiationawarebeanpostprocessor-postprocessbeforeinstantiation\"> 1、InstantiationAwareBeanPostProcessor# postProcessBeforeInstantiation</h5>\n<p>createBean#resolveBeforeInstantiation ；</p>\n<p>在目标对象实例化之前调用，方法的返回值类型是 Object，我们可以返回任何类型的值。由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(一般都是代理对象)。如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；否则按照正常的流程走</p>\n<h5 id=\"_2、smartinstantiationawarebeanpostprocessor-determinecandidateconstructors\"> 2、SmartInstantiationAwareBeanPostProcessor# determineCandidateConstructors</h5>\n<p>createBean#createBeanInstance#determineConstructorsFromBeanPostProcessors；</p>\n<p>实例化之前根据根据参数解析构造函数。允许开发人员自己来判断用哪个构造器。</p>\n<h5 id=\"实例化之后-属性填充之前\"> 实例化之后，属性填充之前：</h5>\n<h5 id=\"_3、mergedbeandefinitionpostprocessor-postprocessmergedbeandefinition\"> 3、MergedBeanDefinitionPostProcessor# postProcessMergedBeanDefinition</h5>\n<p>createBean#applyMergedBeanDefinitionPostProcessors；</p>\n<p>允许 post-processors  更改合并的 bean defition</p>\n<h5 id=\"_4、smartinstantiationawarebeanpostprocessor-getearlybeanreference\"> 4、SmartInstantiationAwareBeanPostProcessor# getEarlyBeanReference</h5>\n<p>createBean#addSingletonFactory#getEarlyBeanReference</p>\n<p>循环引用的后置处理器， 获得提前暴露的bean引用，就是为了解决aop场景下的循环依赖。就是提前暴露需要代理的 bean。</p>\n<h5 id=\"_5、instantiationawarebeanpostprocessor-postprocessafterinstantiation\"> 5、InstantiationAwareBeanPostProcessor# postProcessAfterInstantiation</h5>\n<p>createBean#populateBean#postProcessAfterInstantiation；</p>\n<p>方法在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是 null。如果该方法返回 false，会忽略属性值的设置；如果返回 true，会按照正常流程设置属性值。方法不管 postProcessBeforeInstantiation 方法的返回值是什么都会执行</p>\n<h5 id=\"属性填充时\"> 属性填充时：</h5>\n<h5 id=\"_6、instantiationawarebeanpostprocessor-postprocesspropertie\"> 6、InstantiationAwareBeanPostProcessor# postProcessPropertie</h5>\n<p>createBean#populateBean#postProcessPropertie；</p>\n<p>方法对属性值进行修改(这个时候属性值还未被设置，但是我们可以修改原本该设置进去的属性值)。如果postProcessAfterInstantiation方法返回false，该方法不会被调用。可以在该方法内完成对属性的自动注入。</p>\n<h5 id=\"属性赋值之后-初始化之前\"> 属性赋值之后，初始化之前：</h5>\n<h5 id=\"_7-beanpostprocessor-postprocessbeforeinitialization\"> 7.BeanPostProcessor# postProcessBeforeInitialization</h5>\n<p>createBean#initializeBean#applyBeanPostProcessorsBeforeInitialization；</p>\n<p>该方法会在初始化之前进行执行，其中有一个实现类比较重要 ApplicationContextAwareProcessor，该后置处理的一个作用就是自定义的Bean 实现 ApplicationContextAware 接口时注入  ApplicationContext对象。</p>\n<p>简单说就是当一个类实现了这个接口（ApplicationContextAware）之后，这个类就可以方便获得<a href=\"https://so.csdn.net/so/search?q=ApplicationContext&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener noreferrer\">ApplicationContext</a>中的所有bean。换句话说，就是这个类可以直接获取<a href=\"http://lib.csdn.net/base/javaee\" target=\"_blank\" rel=\"noopener noreferrer\">spring</a>配置文件中，所有有引用到的bean对象。</p>\n<h5 id=\"初始化之后\"> 初始化之后：</h5>\n<p><strong>8.BeanPostProcessor# postProcessAfterInitialization</strong></p>\n<p>createBean#initializeBean#applyBeanPostProcessorsAfterInitialization</p>\n<p>该后置处理器的执行是在调用init方法后面进行执行，主要是判断该bean是否需要被AOP代理增强，如果需要的话，则会在该步骤返回一个代理对象。</p>\n<h5 id=\"_9-smartinitializingsingleton-aftersingletonsinstantiated\"> 9.SmartInitializingSingleton# afterSingletonsInstantiated</h5>\n<p>该方法会在所有的非懒加载单实例  bean 都成功创建并且放到Spring IOC容器之后，依次遍历所有的bean，如果当前这个bean是SmartInitializingSingleton 的子类，那么就强转成 SmartInitializingSingleton 类，然后调用SmartInitializingSingleton的afterSingletonsInstantiated  方法。</p>\n<p>参考：</p>\n<p>https://blog.csdn.net/qq_35634181/article/details/104473308</p>\n",
      "date_modified": "2022-04-29T06:23:42.999Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "放入bean",
      "url": "https://fmiles.cn/frame/spring/abort-bean/",
      "id": "https://fmiles.cn/frame/spring/abort-bean/",
      "content_html": "<h1 id=\"如何放入bean\"> 如何放入bean</h1>\n<h2 id=\"加载-bean\"> 加载 bean</h2>\n<p>这里介绍的是通过 xml 加载的方式。</p>\n<h3 id=\"defaultlistablebeanfactory\"> DefaultListableBeanFactory</h3>\n<p>整个 bean 加载的核心部分。</p>\n<h3 id=\"_2、xmlbeanfactory\"> 2、XmlBeanFactory</h3>\n<p>DefaultListableBeanFactory 的子类，使用自定义的 xml 读取器 XmlBeanDefinitionReader，实现个性化的 BeanDefinitionReader。</p>\n<h4 id=\"_2-1-resource\"> 2.1 Resource</h4>\n<p>继承 InputStreamSource。</p>\n<h4 id=\"_2-2-beandefinition\"> 2.2 BeanDefinition</h4>\n<p>BeanDefinition 是一个接口，在 Spring 中有三种实现：RootBeanDefinition、ChildBeanDefinition、GenericBeanDefinition。三者均继承自AbstractBeanDefinition。</p>\n<p>BeanDefinition  和 <bean> 中的属性是一一对应的。</p>\n<p>​\t\tSpring 通过 BeanDefinition 将配置文件中的 ＜bean&gt; 配置信息转换为容器的内部表示，并将这些 BeanDefiniton 注册到 BeanDefinitonReistry Spring 容器的 BeanDefin tionRegistrγ 就像是 Spring 配置信息的内存数据库，主要是以 map 的形式保存，后续操作直接从 BeanDefinitionRegistry 中读取配置信息。</p>\n<h3 id=\"_3、xmlbeandefinitionreader\"> 3、XmlBeanDefinitionReader</h3>\n<p>从 XML 文件读取配置文件。</p>\n<p>在 Xml</p>\n",
      "date_modified": "2022-04-29T06:23:42.999Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "加载bean",
      "url": "https://fmiles.cn/frame/spring/load-bean/",
      "id": "https://fmiles.cn/frame/spring/load-bean/",
      "content_html": "<h1 id=\"bean-加载\"> bean 加载</h1>\n<h2 id=\"factorybean\"> FactoryBean</h2>\n<h2 id=\"循环依赖\"> 循环依赖</h2>\n<h3 id=\"_1、构造器循环依赖\"> 1、构造器循环依赖</h3>\n<p>这种循环依赖是无法解决的，只能抛出 BeanCurrentlyInCreatingExcepetion。因为构造器创建 bean 的时候，会优先去创建依赖的 bean，当存在循环依赖的时候，自己本身会被创建两次，存在问题。</p>\n<p>​\t\tSpring 容器将每一个正在创建的 bean 标识符放在一个 “当前创建 bean 池” 中，bean 标识符在创建过程中将一致保持在这个池中，因此如果在创建 bean 过程中发现自己已经在 “当前创建 bean 池” 里时，将抛出 BeanCurrentlyInCreatingExcepetion 异常表示循环依赖。</p>\n<h3 id=\"_2、setter-循环依赖\"> 2、setter 循环依赖</h3>\n<p>​\t\t通过 Spring 容器提前暴露刚完成构造器注入当未完成其他步骤（如 setter 注入）的 bean 来完成的，而且只能解决单例作用域的 bean 循环依赖。通过提前暴露一个单例工厂方法，从而使其他 bean 能引用到该 bean。</p>\n<h3 id=\"_3、prototype-范围的依赖处理\"> 3、prototype 范围的依赖处理</h3>\n<p>用 prototype 作用域 bean，Spring 容器无法完成依赖注入。</p>\n<p>对于 “singleton” 作用域 bean，可以通过 &quot;setAllowCircularReferences(false)&quot; 来禁用循环依赖引用。</p>\n<h5 id=\"补充\"> 补充：</h5>\n<p>这个禁用循环依赖没有配置文件配置方法，只能通过硬编码改变：</p>\n<div><pre><code><span>ClassPathXmlA</span>\tpplicationContext bf <span>=</span> <span>new</span> <span>ClassPathxmlApplicationContext</span> <span>(</span><span>\"aspectTest .xml\"</span><span>)</span> <span>;</span> \nbf <span>.</span><span>setAllowBeanDefinitionOverriding</span><span>(</span><span>false</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "date_modified": "2022-04-29T06:23:42.999Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "初始化bean",
      "url": "https://fmiles.cn/frame/spring/abort-spring/",
      "id": "https://fmiles.cn/frame/spring/abort-spring/",
      "content_html": "<h2 id=\"前言\"> 前言</h2>\n<p>​\t\t为了不需要每个对象使用的时候都 new 一个对象实例，可以使用单例模式去解决。但是每个对象实现类转换为单利模式又提高了开发成本。所以引入池子的思想，将我们的接口实现类对象放入到这个池子中，我们在使用的时候直接从这个池子里边取就行了！</p>\n<p>​\t\t如果我们要创建这个池子，首先要确定需要把哪些对象放进这个池子，通过怎样的方式放进去，放进去之后如何进行管理，如何进行获取，池子中的每一个对象的生命周期是怎么样的等等这些东西都是我们需要考虑到的！</p>\n<p>​\t\t<code>Spring</code>的依赖注入/控制反转就是从我们的配置文件或注解中的得到我们需要进行注入到Spring容器的实现类的信息，<code>Spring IOC</code>通过这些配置信息创建一个个单利的对象并放入Spring容器中，而DI个人理解是获取应用程序依赖的对象。<code>Spring</code>容器可以看做是一个集合保存着我们的这些对象。</p>\n<p>bean 是什么，哪些对象是bean</p>\n<p>怎么放入 bean</p>\n<p>怎么管理 bean</p>\n<p>bean 的生命周期</p>\n<p>怎么拿出bean</p>\n<h3 id=\"spring-bean的实例化和初始化\"> Spring Bean的实例化和初始化：</h3>\n<p>实例化----实例化的过程是一个创建Bean的过程，即调用Bean的<a href=\"https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener noreferrer\">构造函数</a>，单例的Bean放入单例池中</p>\n<p>初始化----初始化的过程是一个赋值的过程，即调用Bean的setter，设置Bean的属性。</p>\n<h3 id=\"sping中bean的实例化包含jvm规范中类的初始化与实例化。\"> sping中bean的实例化包含jvm规范中类的初始化与实例化。</h3>\n<p>spirngbean实例化（父类的类构造器<clinit>() -&gt; 子类的类构造器<clinit>() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数。）-&gt;springbean初始化。</p>\n",
      "date_modified": "2022-04-29T06:23:43.000Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "SpringBoot 自动装配原理",
      "url": "https://fmiles.cn/frame/springboot/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/",
      "id": "https://fmiles.cn/frame/springboot/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/",
      "content_html": "<h2 id=\"什么是-springboot-自动装配\"> 什么是 SpringBoot 自动装配？</h2>\n<p><strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>\n<blockquote>\n<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>\n</blockquote>\n",
      "date_modified": "2022-04-29T06:23:43.000Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "Nacos",
      "url": "https://fmiles.cn/interview/cloud/",
      "id": "https://fmiles.cn/interview/cloud/",
      "content_html": "<h2 id=\"nacos\"> Nacos</h2>\n<h4 id=\"nacos-作用\"> Nacos 作用？</h4>\n<p>注册中心，服务的注册发现。</p>\n<h4 id=\"在nacos中服务提供者是如何向nacos注册中心-registry-续约的\"> 在Nacos中服务提供者是如何向Nacos注册中心(Registry)续约的？</h4>\n<p>5秒心跳包，定时向 nocas 发送请求，告诉它自己还活着，这就叫做续约。</p>\n<h4 id=\"nacos-如何判断服务实例状态的\"> Nacos 如何判断服务实例状态的？</h4>\n<p>在 15 s 没收到心跳会将实例设置为不健康状态，超过 30 s 就会删除。</p>\n<h2 id=\"feign\"> Feign</h2>\n<h4 id=\"loadbalanced的作用是什么\"> @LoadBalanced的作用是什么？</h4>\n<p>(描述RestTemplate对象，用于告诉spring框架，在使用RestTemplate进行服务调用时，这个调用过程会被一个拦截器进行拦截，然后在拦截器内部启动负载均衡策略)</p>\n<h2 id=\"hystrix\"> Hystrix</h2>\n<p>作用就是防止服务雪崩。</p>\n<p>解决办法：</p>\n<p>资源隔离和服务降级。</p>\n<p><strong>资源隔离：</strong></p>\n<p>​    在 Hystrix 中，主要通过线程池来实现资源隔离。通常在使用的时候我们会根据调用的远程服务划分出多个线程池。例如调用产品服务的 Command 放入 A 线程池，调用账户服务的 Command 放入 B 线程池。这样做的主要优点是运行环境被隔离开了。这样就算调用服务的代码存在 bug 或者由于其他原因导致自己所在线程池被耗尽时，不会对系统的其他服务造成影响。</p>\n<p><strong>服务降级：</strong></p>\n<p>​    对于查询操作，我们可以实现一个 fallback 方法，当请求后端服务出现异常的时候，可以使用 fallback 方法返回的值。fallback 方法的返回值一般是设置的默认值或者来自缓存。</p>\n<p>​     如果线程池已满，或者请求超时，则会进行降级处理。降级服务优先保证核心服务，而非核心服务不可用或者弱可用。服务降级虽然会导致请求失败，但是不会导致阻塞，最多是影响这个依赖服务对应的线程池中的资源，对其他服务没有影响。</p>\n<h4 id=\"熔断机制\"> 熔断机制：</h4>\n<p>当请求后端服务失败数量超过一定阈值，熔断器会切换到开路状态 (Open)。这时所有请求会直接失败而不会发送到后端服务。</p>\n<h2 id=\"ribbon\"> Ribbon</h2>\n<p>默认是轮询。</p>\n<h2 id=\"gateway\"> Gateway</h2>\n<p>路由转发、权限校验、限流控制等作用。</p>\n",
      "date_modified": "2022-04-29T06:23:43.000Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "HashMap",
      "url": "https://fmiles.cn/interview/collection/",
      "id": "https://fmiles.cn/interview/collection/",
      "content_html": "<h1 id=\"hashmap\"> HashMap</h1>\n<h2 id=\"hash-算法\"> Hash 算法</h2>\n<h4 id=\"hash算法-为什么是-key-hashcode-key-hashcode-16\"> hash算法 为什么是 key.hashCode() ^(key.hashCode() &gt;&gt;&gt; 16)</h4>\n<p>https://wenku.baidu.com/view/79197504ac45b307e87101f69e3143323968f5c7.html</p>\n<h2 id=\"数组-链表-树问题\"> 数组+链表/树问题</h2>\n<h4 id=\"hashmap-为什么引入链表\"> hashmap 为什么引入链表？</h4>\n<h4 id=\"为什么-jdk-1-8-引入红黑树呢\"> 为什么 Jdk 1.8 引入红黑树呢？</h4>\n<h4 id=\"为什么一开始不就使用红黑树-而是大于-8-才变为红黑树\"> 为什么一开始不就使用红黑树，而是大于 8 才变为红黑树？</h4>\n<h4 id=\"底层数组取值的时候-为什么不用取模-而是\"> 底层数组取值的时候，为什么不用取模，而是 &amp; ？</h4>\n<h4 id=\"为什么数组的长度是-2-的次方\"> 为什么数组的长度是 2 的次方？</h4>\n<h2 id=\"源码\"> 源码</h2>\n<h4 id=\"put-的过程\"> put() 的过程？</h4>\n<h4 id=\"get-过程\"> get() 过程？</h4>\n<h4 id=\"hashmap-resize-扩容机制\"> HashMap resize 扩容机制</h4>\n<p>首先 HashMap 扩容发生在这几种情况下：</p>\n<p>第一个添加值以后大于阈值；第二个是表为空；第三个就是 treeifyBin 的时候或者数组长度小于最小树化阈值（默认  64）的时候才会执行。</p>\n<p>这里重点讲一下第一种情况，先要知道几个字段：</p>\n<p>容量(capacaity）：这个容量表示的是数组的大小；</p>\n<p>size：表示的是整个 hash 表中记录的所有数据的个数；</p>\n<p>负载因子（<strong>load factor</strong>）：默认是 0.75；</p>\n<p>还有个阈值，值是 负载因子乘以容量</p>\n<p>当添加一个数据后，会判断此时 size 是否大于阈值，大于阈值的话就会扩容。</p>\n<p>然后扩容大小的话默认是翻倍的，因为默认是容量左移一位，也就是容量翻倍。之后就会在创建一个新的数组，把老数组的值复制过去。这里需要</p>\n<p>需要几点：第一个就是如果节点是数节点的话，会拆分。如果本身就是个链表的话，按照（ (e.hash &amp; oldCap) == 0 ）节点的 hash 值与上老的容量值是否等于 0 拆分成两个新的链表，这两个链表就是扩容后在新链表的位置了。</p>\n<h4 id=\"resize-扩容的原理\"> resize() 扩容的原理</h4>\n<p>主要就是扩容后位置的变化。最要的就是 oldCap&amp;hash == 0 这个算法。</p>\n<h2 id=\"hashmap-多线程不安全的原因\"> HashMap 多线程不安全的原因</h2>\n<h4 id=\"多线程-put-丢失数据\"> 多线程 put 丢失数据</h4>\n<h4 id=\"多线程-get-数据可能为-null\"> 多线程 get 数据可能为 null</h4>\n<h4 id=\"jdk-1-7-中头插入-导致-get-死循环\"> JDk 1.7 中头插入，导致 get 死循环</h4>\n<p>线程安全的话，建议 ConcurrnetHashMap。</p>\n<h4 id=\"hashmap-1-7-和-1-8-的区别\"> HashMap 1.7 和 1.8 的区别</h4>\n<p>从底层数据结构来看，1.7 底层使用的是数组 + 链表。而 1.8 底层使用的是数组+链表+数。默认是链表长度大于 8 的时候，会判断数组长度是否大于 <code>MIN_TREEIFY_CAPACITY</code>，默认是 64 ，当小于这个值的时候，是会扩容而不是树化。</p>\n<p>从 hash 方法来看， 1.7 的 hash 算法是异或了四次，1.8 则是通过hashcode 的高16位异或低16位实现，这样做的优点是影响 hash 的分布性，降低冲突率。</p>\n<h1 id=\"concurrenthashmap\"> ConcurrentHashMap</h1>\n<h2 id=\"_1-7-和-1-8-区别\"> 1.7 和 1.8 区别</h2>\n<h4 id=\"concurrenthashmap-的实现原理是什么\"> ConcurrentHashMap 的实现原理是什么？</h4>\n<h4 id=\"put-方法\"> put() 方法？</h4>\n<h4 id=\"get-方法\"> get() 方法？</h4>\n<h2 id=\"其他\"> 其他</h2>\n<h4 id=\"concurrenthashmap-不支持-key-或者-value-为-null-的原因\"> ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</h4>\n<h4 id=\"concurrenthashmap-的并发度是什么\"> ConcurrentHashMap 的并发度是什么？</h4>\n<h4 id=\"concurrenthashmap-迭代器是强一致性还是弱一致性\"> ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h4>\n<h4 id=\"jdk1-7-与-jdk1-8-中concurrenthashmap-的区别\"> JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？</h4>\n<h4 id=\"concurrenthashmap-和-hashtable-的效率哪个更高-为什么\"> ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？</h4>\n<p>https://blog.csdn.net/yunzhaji3762/article/details/113623168?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2</p>\n",
      "date_modified": "2022-04-29T06:23:43.001Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "这是文章主页",
      "url": "https://fmiles.cn/home/",
      "id": "https://fmiles.cn/home/",
      "content_html": "",
      "date_published": "2022-03-03T13:05:45.000Z",
      "date_modified": "2022-03-03T15:29:19.000Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "BIO，NIO，AIO 区别",
      "url": "https://fmiles.cn/interview/java%E5%9F%BA%E7%A1%80/",
      "id": "https://fmiles.cn/interview/java%E5%9F%BA%E7%A1%80/",
      "content_html": "<h4 id=\"bio-nio-aio-区别\"> BIO，NIO，AIO 区别</h4>\n<p>UNIX 系统下，IO模型有 <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、**异步 I/O **这几种。</p>\n<p>首先说BIO，在linux中的Java进程中，默认情况下所有的 socket 都是 blocking IO。在阻塞式 I/O 模型中，应用程序在从 IO 系统调用开始，一直到到系统调用返回，这段时间是阻塞的。返回成功后，应用进程开始处理用户空间的缓存数据。BIO 优先就是简单，用户线程不占用 CPU，但是缺点也很明显，在高并发场景下是不可用的。</p>\n<p>接着说NIO，NIO 模型中应用程序在一旦开始 IO 系统调用，会出现以下两种情况：</p>\n<p>（1）在内核缓冲区没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。</p>\n<p>（2）在内核缓冲区有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。</p>\n<p>它的特点就是应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止。</p>\n<p>NIO 优点就是用户线程不会阻塞，实时性较好，缺点需要不断的重复发起IO系统调用，这种不断的轮询，将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低。和 BIO 一样在高并发下不咋地。</p>\n<p>IO 多路复用：通过一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核能够通知程序进行相应的 IO 系统调用。已这种通知的方式，优势是能处理更多的链接。通过一次 select/epoll 系统调用，就查询到到可以读写的一个甚至是成百上千的网络连接。</p>\n<p>零拷贝</p>\n<h4 id=\"_2、反射底层原理\"> 2、反射底层原理</h4>\n<p>反射的定义就是对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。</p>\n<p>从使用开始说，平时我们使用反射都是</p>\n<p>Method method = XXX.class.getDeclaredMethod(xx,xx);</p>\n<p>method.invoke(target,params)。</p>\n<p>首先介绍这个根据方法名获取方法的方法，底层主要的是使用了reflectionData 这个数据结构，保存了从 JVM 里获取的一些类的属性和方法等，通过这个方法返回了封装在 Method 类中的关于方法的信息。在获取到 Method 后，并不是直接 返回，而是 copy了一份。</p>\n<p>Method 类中最主要的信息是两个字段：root 和 MethodAccessor  和一个方法：invoke。root 主要指向缓存中的 Method 对象，也就是当前这个 Method 对象其实是根据 root 这个 Method 构建出来的，原因是在上面步骤的获取到 Method 之后，并不会直接返回，而是调用 copy() 方法复制一个 Metohd 对象，每个复制的 Method 对象的 root 都指向这个 Method。</p>\n<p>另外一个 MethodAccessor，本身只是一个接口，内部只有一个 invoke 方法，而 Method 类中的 invoke 方法正是调用 MethodAccessor 中的这个 invoke 方法；其主要的实现类有三个，</p>\n<ul>\n<li>DelegatingMethodAccessorImpl</li>\n<li>NativeMethodAccessorImpl</li>\n<li>GeneratedMethodAccessorXXX</li>\n</ul>\n<p>NativeMethodAccessorImpl 主要是 Native 实现的，而<code>GeneratedMethodAccessorXXX</code>是为每个需要反射调用的<code>Method</code>动态生成的类，DelegatingMethodAccessorImpl 就是给这两个类做代理的，在调用 15 次 invoke 方法之前都是调用 NativeMethodAccessorImpl。原因也是因为 native 的效率高。</p>\n<h6 id=\"优缺点\"> 优缺点：</h6>\n<ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li>\n</ul>\n<h4 id=\"_3、动态代理底层原理\"> 3、动态代理底层原理</h4>\n<p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。动态代理分为 Jdk 动态代理和 Cglib 动态代理。</p>\n<p>从使用角度来说，要实现动态代理的话，我们需要定义个代理类需要实现 InvocationHandler，然后重写其中的 Invoke 方法来自定义处理的逻辑；</p>\n<p>然后需要调用 Proxy.newProxyInstance 方法，这个方法一共有 3 个参数：</p>\n<ol>\n<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>\n<li><strong>interfaces</strong> : 代理类实现的一些接口；</li>\n<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>\n</ol>\n<p>其中最重要的就是 h。 JVM 会在运行调用 newProxyInstance 动态生成一个代理类，这个类的构造函数参数就是传入的 h，并且 $Proxy0 即动态生成的代理类是继承自 Proxy。</p>\n<p>在动态代理类的构造函数中，调用了 super(h)；这时候把实现了 InvocationHandler 接口的对象又传给父类 Proxy，并且赋值给 Proxy 的字段  h;</p>\n<p>接着调用被代理类方法的时候，就会调用 super.h.invoke()，即 Proxy 类的 h，即调用了代理类的 invoke 方法。</p>\n<p>本质来说，动态代理的底层就是反射。</p>\n<h5 id=\"_2、java-中的几种基本数据类型是什么-对应的包装类型是什么-各自占用多少字节呢\"> 2、Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</h5>\n<p>​    注意boolen，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，（因此）每个boolean元素占8位。</p>\n<p>可以得知：boolean类型的数据如果单独使用，占4个字节的空间，而如果存储到boolean数组中，每个元素又只占1个字节。</p>\n<h5 id=\"_3、string-、-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的\"> 3、<code>String</code> <code>、 StringBuffer</code> 和 <code>StringBuilder</code> 的区别是什么? <code>String</code> 为什么是不可变的?</h5>\n<p>​            <code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>\n<h5 id=\"_4、深拷贝和浅拷贝\"> 4、深拷贝和浅拷贝</h5>\n<ol>\n<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>\n<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>\n</ol>\n<h5 id=\"_5、java-反射-反射有什么缺点-你是怎么理解反射的-为什么框架需要反射\"> 5、Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</h5>\n<p>​\t\tJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>\n<ul>\n<li></li>\n</ul>\n<h6 id=\"_2、为什么框架需要反射\"> 2、为什么框架需要反射</h6>\n<p>框架用反射会易于扩展，譬如修改配置文件。又譬如 Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系。</p>\n<h6 id=\"_3、获取class对象的四种方式\"> 3、获取Class对象的四种方式？</h6>\n<blockquote>\n<p>1、.Class</p>\n<p>2、forName 方法</p>\n<p>3、.getClass() 方法</p>\n<p>4、ClassLoader.LoadClass()</p>\n</blockquote>\n<h5 id=\"_6、java-泛型了解么-什么是类型擦除-介绍一下常用的通配符\"> 6、Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h5>\n<p>简单来说就是在创建对象或调用方法的时候明确具体的类型。</p>\n<p>好处就是代码更加简洁（不需要强制转换），程序更加健壮（编译期不出错，运行期就不会出现ClassCastException）。</p>\n<h6 id=\"_1、什么是类型擦除\"> 1、什么是类型擦除</h6>\n<p>​\t\tJava 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。</p>\n<h6 id=\"_2、通配符\"> 2、通配符</h6>\n<blockquote>\n<ul>\n<li>？ 表示不确定的 java 类型</li>\n<li>T (type) 表示具体的一个 java 类型</li>\n<li>K V (key value) 分别代表 java 键值中的 Key Value</li>\n<li>E (element) 代表 Element</li>\n</ul>\n</blockquote>\n<h5 id=\"_7、内部类和匿名内部类\"> 7、内部类和匿名内部类？</h5>\n<p>内部类即一个方法的内部类。</p>\n<p>匿名内部类：匿名内部类不能有构造方法。 匿名内部类不能定义任何静态成员、方法和类。 只能创建匿名内部类的一个实例。</p>\n",
      "date_modified": "2022-04-29T06:23:43.001Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "垃圾回收相关",
      "url": "https://fmiles.cn/interview/jvm/",
      "id": "https://fmiles.cn/interview/jvm/",
      "content_html": "<h2 id=\"垃圾回收相关\"> 垃圾回收相关</h2>\n<h4 id=\"垃圾回收算法有哪些\"> 垃圾回收算法有哪些？</h4>\n<h4 id=\"垃圾收集器有哪些-有什么优缺点\"> 垃圾收集器有哪些？有什么优缺点？</h4>\n<h4 id=\"cms-垃圾回收器工作流程\"> CMS 垃圾回收器工作流程？</h4>\n<h4 id=\"卡表是什么\"> 卡表是什么？</h4>\n<h4 id=\"yonggc-和-full-gc-的时机\"> yongGC 和 full GC 的时机？</h4>\n<h4 id=\"什么情况会进入老年代\"> 什么情况会进入老年代？</h4>\n<h4 id=\"gcroot-有哪些\"> GCroot 有哪些？</h4>\n<h4 id=\"逃逸分析是什么\"> 逃逸分析是什么？</h4>\n<p>逃逸的方式：</p>\n<ol>\n<li><strong>方法逃逸：</strong> 在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。</li>\n<li><strong>线程逃逸：</strong> 这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。</li>\n</ol>\n<p>逃逸分析是一种数据流分析算法，通过逃逸分析，编译器能够<strong>分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</strong>。</p>\n<h5 id=\"追问1-逃逸分析的原理\"> 追问1：逃逸分析的原理？</h5>\n<p>简单说就是不逃逸的对象，只存在于栈中，减少了堆的压力从而达到优化效果。</p>\n<p>逃逸分析的优点：栈上分配；同步消除；标量替换。</p>\n<h5 id=\"https-blog-csdn-net-weixin-40597409-article-details-115260954\"> https://blog.csdn.net/weixin_40597409/article/details/115260954</h5>\n<h2 id=\"内存相关\"> 内存相关</h2>\n<h4 id=\"jvm-内存结构有哪些\"> JVM 内存结构有哪些？</h4>\n<h5 id=\"追问-每个区域的作用\"> 追问：每个区域的作用？</h5>\n<h4 id=\"oom-的种类\"> OOM 的种类？</h4>\n<p>1、unable to create new native thread。没有足够的内存空间给线程分配栈</p>\n<p>基本的排查思路是线程池的代码写的有问题，所以先成代码层面检查，使用 jstack 或 jmap，</p>\n<p>2、Java heap space。 堆的内存占用达到了 -Xmx 设置的最大值。</p>\n<p>排查思路还是先在代码中查找，怀疑是内存泄漏的话，通过 jstack 和 jmap 去定位问题，如果都正常，需要调整 -Xmx 值。</p>\n<p>3、Meta space 元数据区的占用值达到了 -XX:MaxMetaSpaceSize 设置的值大小。排查思路与上面类似。</p>\n<p>代码层面引发的OOM情况比较多，比如大量重复创建的对象没有及时回收；进行文件操作但是不 close等等。</p>\n<h4 id=\"oom-如何定位问题\"> OOM 如何定位问题？</h4>\n<p>先可以在启动参数中加入 HeapDumpOnOutOfMemoryError 参数，出错了以后可以使用 jvvisuaml 分析 dump 文件。也可以通过Jmp 导出 dump 文件，然后分析 dump 。</p>\n<h4 id=\"markwork-里面有什么\"> MarkWork 里面有什么？</h4>\n<h2 id=\"类加载相关\"> 类加载相关</h2>\n<h4 id=\"类加载器有哪些\"> 类加载器有哪些？</h4>\n<h4 id=\"类加载过程\"> 类加载过程？</h4>\n<h4 id=\"双亲委派是什么\"> 双亲委派是什么？</h4>\n",
      "date_modified": "2022-04-29T06:23:43.002Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "CAS",
      "url": "https://fmiles.cn/interview/juc/",
      "id": "https://fmiles.cn/interview/juc/",
      "content_html": "<h1 id=\"cas\"> CAS</h1>\n<h2 id=\"cas-2\"> CAS</h2>\n<h4 id=\"什么是-cas\"> 什么是 CAS ？</h4>\n<h4 id=\"为什么要用-cas\"> 为什么要用 CAS？</h4>\n<h4 id=\"cas-存在什么问题\"> CAS 存在什么问题？</h4>\n<h4 id=\"cas-的运用\"> CAS 的运用？</h4>\n<p>主要就是 JUC 包下的实现类。</p>\n<h4 id=\"atomaticintiger-类怎么保证线程安全的\"> AtomaticIntiger 类怎么保证线程安全的？</h4>\n<h2 id=\"aba\"> ABA</h2>\n<h4 id=\"aba-是什么\"> ABA 是什么？</h4>\n<h4 id=\"怎么解决-aba-问题\"> 怎么解决 ABA 问题？</h4>\n<p>https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247483977&amp;idx=1&amp;sn=1a3aa3aec27073aa3b422bc41d7fbe2d&amp;chksm=fdf0ea16ca8763005aff64834eeb7bef08bf4ee2d8febb7e8d4d8e5d1542336e13fac71e2881&amp;cur_album_id=1657204970858872832&amp;scene=21#wechat_redirect</p>\n<h2 id=\"longaddr\"> LongAddr</h2>\n<h4 id=\"longaddr-是什么\"> LongAddr 是什么？</h4>\n<h4 id=\"longaddr-的原理\"> LongAddr 的原理？</h4>\n<h1 id=\"unsafe\"> unsafe</h1>\n<h4 id=\"unsafe是什么\"> Unsafe是什么？</h4>\n<p>Java 无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个类 Unsafe，底层是使用C/C++写的，它提供了硬件级别的原子操作。Unsafe为我们提供了访问底层的机制，这种机制仅供java核心类库使用，而不应该被普通用户使用。</p>\n<h4 id=\"unsafe-作用\"> Unsafe 作用？</h4>\n<ul>\n<li>操纵对象属性</li>\n<li>操纵数组元素</li>\n<li>线程挂起与恢复、CAS</li>\n</ul>\n<h4 id=\"unsafe为什么是不安全的\"> Unsafe为什么是不安全的？</h4>\n<h4 id=\"unsafe的实例怎么获取\"> Unsafe的实例怎么获取？</h4>\n<h4 id=\"unsafe的阻塞-唤醒操作\"> Unsafe的阻塞/唤醒操作？</h4>\n<p>LockSupport类中的park与unpark方法对unsafe中的park与unpark方法做了封装，LockSupport类中有各种版本park方法，但最终都调用了Unsafe.park()方法。</p>\n<p>https://blog.csdn.net/qq_21903759/article/details/105914506</p>\n<h1 id=\"aqs\"> AQS</h1>\n<h4 id=\"何为-aqs\"> 何为 AQS？</h4>\n<p><strong>AQS 是一个用于构建锁、同步器等线程协作工具类的框架</strong>，简单说就是 AQS 定义了模板，具体实现由各个子类完成。</p>\n<p>https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247484035&amp;idx=1&amp;sn=ccaec352e192f1fd40020d9a984e9461&amp;chksm=fdf0eadcca8763ca5c44bd19118fd00e843c163deb40cda444b3fc08430c57760db15eca1ea6&amp;scene=178&amp;cur_album_id=1657204970858872832#rd</p>\n<h4 id=\"aqs原理-执行过程源码-入队出队的细节-源码细节\"> AQS原理（执行过程源码，入队出队的细节，源码细节)</h4>\n<p>先讲 AQS 的四个字段，state，head，tail，独占的线程；</p>\n<p>接着讲 Node 结构，waitstatus，thread，prev，next，nextWaiter；</p>\n<p>ReentantLock 的 Lock 源码：1、尝试获取锁；2、获取锁失败入队；3、线程是否需要挂起；4、selfInterrupet()</p>\n<p>unLock 源码：1、尝试解锁；2、唤醒后续节点。注意这里是唤醒，而真正处理 是在 Lock 的第三步。</p>\n<h4 id=\"countdownlatch-怎么用-应用场景是什么\"> CountDownLatch 怎么用？应用场景是什么？</h4>\n<h5 id=\"countdownlatch-两种应用场景\"> CountDownLatch 两种应用场景</h5>\n<ul>\n<li><strong>线程执行完了等待其他线程执行完</strong>。假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</li>\n<li>**多个线程开始执行任务的最大并行性。**类似于赛跑，让线程都同时等待直到所有线程准备好，然后同时唤醒所有线程。</li>\n</ul>\n<h5 id=\"cyclicbarrier-的应用场景\"> CyclicBarrier 的应用场景</h5>\n<p><code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>\n<h4 id=\"countdownlatch-和-cyclicbarrier-的不同之处\"> CountDownLatch 和 CyclicBarrier 的不同之处？</h4>\n<p><code>CountDownLatch</code> 是计数器，只能使用一次，而 <code>CyclicBarrier</code> 的计数器提供 <code>reset</code> 功能，可以多次使用。对于 <code>CountDownLatch</code> 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 <code>CyclicBarrier</code>，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>\n<p><code>CountDownLatch</code> 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 <code>CyclicBarrier</code> 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>\n<h5 id=\"源码层面的不同\"> 源码层面的不同：</h5>\n<h1 id=\"synchronized\"> Synchronized</h1>\n<h2 id=\"为什么有synchronized\"> 为什么有Synchronized</h2>\n<h4 id=\"_1、为什么需要-synchronized-什么场景下使用-synchronized\"> 1、为什么需要 synchronized？什么场景下使用 synchronized？</h4>\n<h2 id=\"synchronized-是什么\"> Synchronized 是什么</h2>\n<h4 id=\"_1、-synchronized-这三种加锁方式-作用对象-静态方法、非静态方法、代码块-作用范围的区别\"> 1、 synchronized 这三种加锁方式（作用对象：静态方法、非静态方法、代码块）作用范围的区别?</h4>\n<h4 id=\"_2、synchronized修饰的方法在抛出异常时-会释放锁吗\"> 2、Synchronized修饰的方法在抛出异常时,会释放锁吗?</h4>\n<h4 id=\"_3、synchronized-是公平锁还是非公平锁\"> 3、synchronized 是公平锁还是非公平锁？</h4>\n<h2 id=\"synchronized-怎么实现的\"> Synchronized 怎么实现的</h2>\n<h4 id=\"_1、synchronized-底层源码如何实现\"> 1、synchronized 底层源码如何实现？</h4>\n<h4 id=\"_2、synchronized-本质上是通过什么保证线程安全的-分三个方面回答-加锁和释放锁的原理-保证可见性原理。\"> 2、synchronized 本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，保证可见性原理。</h4>\n<h5 id=\"追问1-为什么-monitorexit-指令出现了两次\"> 追问1：为什么 monitorexit 指令出现了两次？</h5>\n<h5 id=\"追问2-可重入原理\"> 追问2：可重入原理？</h5>\n<p>status,线程ID</p>\n<h5 id=\"追问3-在并发时-程序的执行可能会出现乱序-直观感觉前面的代码-会在后面执行-为什么\"> 追问3：在并发时，程序的执行可能会出现乱序，直观感觉前面的代码，会在后面执行，为什么？</h5>\n<h4 id=\"_3、那你分别跟我讲讲-jdk-6-以前-synchronized-为什么这么重\"> 3、那你分别跟我讲讲 JDK 6 以前 synchronized 为什么这么重？</h4>\n<h4 id=\"_4、jdk-6-之后-synchronized-做了优化-跟我讲讲-什么是jvm里的偏斜锁、轻量级锁、重量级锁\"> 4、JDK 6 之后 synchronized 做了优化，跟我讲讲？ 什么是JVM里的偏斜锁、轻量级锁、重量级锁?</h4>\n<h5 id=\"追问1-你知道-自旋锁-是做什么的吗-它的使用场景是什么\"> 追问1：你知道“自旋锁”是做什么的吗？它的使用场景是什么？</h5>\n<h4 id=\"_5、什么是锁的升级、降级\"> 5、什么是锁的升级、降级？</h4>\n<h5 id=\"追问1-轻量级锁的实现\"> 追问1：轻量级锁的实现</h5>\n<h2 id=\"synchronized-使用\"> Synchronized 使用</h2>\n<h4 id=\"_1、如何提高synchronized并发性能\"> 1、如何提高Synchronized并发性能？</h4>\n<h4 id=\"_2、使用synchronized关键字需要注意什么\"> 2、使用Synchronized关键字需要注意什么？</h4>\n<h2 id=\"synchronized-延申\"> Synchronized 延申</h2>\n<h4 id=\"_1、-synchronized由什么样的缺陷\"> 1、 Synchronized由什么样的缺陷?</h4>\n<h4 id=\"_2、java-lock怎么弥补这些缺陷的\"> 2、Java Lock怎么弥补这些缺陷的？</h4>\n<h4 id=\"追问1-synchronized和lock的区别\"> 追问1：Synchronized和lock的区别</h4>\n<h4 id=\"_3、synchronized和reentrantlock有什么区别呢\"> 3、synchronized和ReentrantLock有什么区别呢?</h4>\n<p>https://blog.csdn.net/heavendan/article/details/120776181</p>\n<h1 id=\"volatile\"> Volatile</h1>\n<h2 id=\"volatile-2\"> volatile</h2>\n<h4 id=\"为什么有-volaitle-或者-volaitle-作用是什么\"> 为什么有 volaitle？或者 volaitle 作用是什么？</h4>\n<p>多线程环境下，一个共享变量可能存在于多个位置，如主内存、多个本地内存，可能带来数据不一致的问题。不一致有两方面原因，可见性和有序性：</p>\n<p>可见性：一个线程对主内存数据进行了修改，而另外一个线程不知道，导致共享变量值不一样。</p>\n<p>有序性：多线程交替执行，由于编译器优化重排的存在，变量无法保证一致性。</p>\n<p>volatile 就是为了解决这两个问题：</p>\n<p>可见性是使用 lock 前缀实现，lock 前缀可实现嗅探机制，每个处理器都会有一个嗅探机制，去看自己的工作内存中的数值与主内存中那个的是否一致，不一致，会将自己的工作内存中的数值设置成无效，同时会从主内存中读取数值更新到自己的工作内存中。</p>\n<p>有序性是通过内存屏障，禁止指令重排，内存屏障还可以强制刷出各种 CPU 的缓存数据保证可见性。</p>\n<h5 id=\"追问-volatile能保证原子性吗-为什么\"> 追问：volatile能保证原子性吗？为什么？</h5>\n<p>不能完全保证，只能保证单次的读/写操作具有原子性。比如，i++，这是是一个复合操作。</p>\n<h5 id=\"追问2-volatile-是否用的越多越好-或者总线风暴是什么\"> 追问2：volatile 是否用的越多越好？或者总线风暴是什么？</h5>\n<p>不是，可能导致总线风暴。 由于 Volatile 的 MESI 缓存一致性协议，需、要不断从主内存嗅探和 CAS 循环，无效交互会导致总线带宽达到峰值，所以不要大量使用 Volatile。</p>\n<h3 id=\"一、有序性相关问题\"> 一、有序性相关问题</h3>\n<h4 id=\"什么是指令重排\"> 什么是指令重排？</h4>\n<p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p>\n<p>重排序一般可分为三种：</p>\n<ul>\n<li>\n<p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;</p>\n</li>\n<li>\n<p>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;</p>\n</li>\n<li>\n<p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</p>\n</li>\n</ul>\n<h4 id=\"as-if-serial-是什么\"> as-if-serial 是什么？</h4>\n<p>不管怎么重排序，单线程下的执行结果不能被改变。</p>\n<h4 id=\"volitile-的读写内存屏障-或者是有序性是什么实现的\"> volitile 的读写内存屏障？或者是有序性是什么实现的</h4>\n<h3 id=\"二、可见性相关问题\"> 二、可见性相关问题</h3>\n<h4 id=\"happens-before-是什么\"> happens-before 是什么？</h4>\n<p>主要是为了表示操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p>\n<h4 id=\"lock-前缀的作用\"> Lock 前缀的作用？</h4>\n<h2 id=\"jmm\"> JMM</h2>\n<h4 id=\"jmm-是什么\"> JMM 是什么？</h4>\n<p>Java内存模型，是java虚拟机规范中所定义的一种内存模型，目的是为了屏蔽掉了底层不同计算机的区别。</p>\n<h4 id=\"jmm-的主要内容\"> JMM 的主要内容？</h4>\n<p>所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>\n<p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>\n<p><code>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量</code>。</p>\n<p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p>\n<h2 id=\"内存屏障\"> 内存屏障</h2>\n<h4 id=\"内存屏障是什么-或者作用什么-或者怎么保证不会被重排序\"> 内存屏障是什么？或者作用什么？或者怎么保证不会被重排序？</h4>\n<p>java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止特定类型的处理器重排序。</p>\n<h2 id=\"总线机制\"> 总线机制</h2>\n<p>https://blog.csdn.net/heavendan/article/details/121032734</p>\n<h1 id=\"threadlocal\"> ThreadLocal</h1>\n<h4 id=\"threadlocal-是什么-原理是什么-存在什么问题-为什么设计成-key-是虚引用\"> ThreadLocal 是什么？原理是什么？存在什么问题？为什么设计成 key 是虚引用？</h4>\n<p>背景是变量无法共享，ThreadLocal 创建的变量可以共享。</p>\n<p>原理介绍下 Thread 类中 ThreadLocals，主要是 ThreaLcoal 类中的 ThreadLocalMap；</p>\n<p>ThreadLocalMap 的底层是   Entry 数组；</p>\n<p>Entry 数组 key 是ThreadLocal 本身，value 是存放的值。</p>\n<p>存在的问题是内存泄漏，就是 key 为 null，value一致没办法回收。</p>\n<p>为什么 key 是虚引用个人觉得的是为了线程复用，设计成 让 ThreadLocal 自动被回收(讲一下内存引用的图的理解)。</p>\n<h4 id=\"父子线程怎么共享数据-interitablethreadlocals\"> 父子线程怎么共享数据 interitableThreadLocals</h4>\n<p>就是创建 Thread 类的时候，把父线程 interitableThreadLocals 传给 子线程。</p>\n<h4 id=\"线程池的创建形式-使用场景\"> 线程池的创建形式,使用场景</h4>\n<p>其实池化思想大多都是为了减少每次获取资源的消耗，提高对资源的利用率。主要的使用场景是用于执行不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可以让多个不相干的任务同时执行。</p>\n<p>创建形式一般都是通过 ThreadPoolExecutor。</p>\n<p>几个参数：</p>\n<ul>\n<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>\n<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>\n<ol>\n<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>\n<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>\n<li><strong><code>handler</code></strong> :当达到线程池的最大线程数的拒绝策略。当线程池饱和，继续提交任务，需要一种策略来处理该任务。线程池提供了4种策略：</li>\n</ol>\n<ul>\n<li>\n<p>不干了：</p>\n<ul>\n<li>直接抛出异常，这是默认策略；</li>\n<li>直接丢弃任务；</li>\n</ul>\n</li>\n<li>\n<p>干：</p>\n<ul>\n<li>用调用者所在的线程来执行任务；</li>\n<li>丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n</ul>\n</li>\n</ul>\n",
      "date_modified": "2022-04-29T06:23:43.003Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "基础相关",
      "url": "https://fmiles.cn/interview/mysql/",
      "id": "https://fmiles.cn/interview/mysql/",
      "content_html": "<h2 id=\"基础相关\"> 基础相关</h2>\n<h4 id=\"_1、非关系型数据库和关系型数据库的区别\"> 1、非关系型数据库和关系型数据库的区别？</h4>\n<p>数据存储的方式区别，关系型数据库最典型的<strong>数据结构是表</strong>，由<strong>二维表</strong>及其<strong>之间的联系</strong>所组成的一个数据组织。非关系型数据库特点是面向对象或者集合，可以是文档或者键值对等。</p>\n<h4 id=\"_2、详细说一下一条-mysql-语句执行的步骤\"> 2、详细说一下一条 MySQL 语句执行的步骤</h4>\n<p>Server 层按顺序执行 SQL 的步骤为：</p>\n<ul>\n<li>客户端请求 -&gt; 连接器（验证用户身份，给予 权限）</li>\n<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）</li>\n<li>分析器（对 SQL 进行词法分析和语法分析操作）</li>\n<li>优化器（主要对执行的 SQL 优化选择最优的执行方案方法）</li>\n<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>\n</ul>\n<h4 id=\"_3、数据库三范式\"> 3、数据库三范式？</h4>\n<p>https://blog.csdn.net/qq_40899182/article/details/81706253</p>\n<p>第一范式：确保每列保持原子性</p>\n<p>第二范式：确保表中的每列都和主键有关 （主键列与非主键列遵循<strong>完全依赖关系</strong>）</p>\n<p>第三范式：确保每列都和主键列直接相关，而不是间接相关。（非主键列之间没有<strong>传递依赖关系</strong>）</p>\n<p>依赖：指的是表中某个字段的值B可以由另外一个字段A决定。</p>\n<p>譬如：选择一个人姓名之后，可以确定性别，但是选择性别之后，不能确定姓名。</p>\n<p>传递依赖：非主键直接 A -&gt; B -&gt; C</p>\n<p>第二范式：每一行的数据只能与其中一列相关，即一行数据只作一件事。是要数据列中出现重复数据，就需要拆表。</p>\n<h4 id=\"_4、mysql-数据库两种存储引擎的区别\"> 4、MySQL 数据库两种存储引擎的区别?</h4>\n<ol>\n<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>\n<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>\n<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>\n<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现</li>\n</ol>\n<h2 id=\"索引相关\"> 索引相关</h2>\n<h4 id=\"_1、索引的三种常见底层数据结构以及优缺点\"> 1、索引的三种常见底层数据结构以及优缺点</h4>\n<p>三种常见的索引底层数据结构：分别是哈希表、有序数组和搜索树。</p>\n<ul>\n<li>哈希表这种适用于等值查询的场景，比如 memcached 以及其它一些 NoSQL 引擎，不适合范围查询。</li>\n<li>有序数组索引只适用于静态存储引擎，等值和范围查询性能好，但更新数据成本高。</li>\n<li>N 叉树由于读写上的性能优点以及适配磁盘访问模式以及广泛应用在数据库引擎中。</li>\n</ul>\n<p>​        扩展（以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。）</p>\n<h4 id=\"_2、索引的常见类型以及它是如何发挥作用的\"> 2、索引的常见类型以及它是如何发挥作用的？</h4>\n<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>\n<ul>\n<li>主键索引的叶子节点存的整行数据，在InnoDB里也被称为聚簇索引。</li>\n<li>非主键索引叶子节点存的主键的值，在InnoDB里也被称为二级索引。</li>\n</ul>\n<h4 id=\"_3、myisam-和-innodb-实现-b-树索引方式的区别是什么\"> 3、MyISAM 和 InnoDB 实现 B 树索引方式的区别是什么？</h4>\n<ul>\n<li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身，其数据文件本身就是索引文件。</li>\n<li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址，叶节点的 data 域存放的是数据记录的地址，索引文件和数据文件是分离的。</li>\n</ul>\n<h4 id=\"_4、innodb-为什么选择b-树索引-b-树做索引比红黑树好在哪里\"> 4、InnoDB 为什么选择B+ 树索引？B+树做索引比红黑树好在哪里？</h4>\n<p>两个考虑因素：</p>\n<ul>\n<li>InnoDB 需要执行的场景和功能需要在特定查询上拥有较强的性能。</li>\n<li>CPU 将磁盘上的数据加载到内存中需要花费大量时间。</li>\n</ul>\n<p>为什么选择 B+ 树：</p>\n<ul>\n<li>哈希索引虽然能提供O（1）复杂度查询，但对范围查询和排序却无法很好的支持，最终会导致全表扫描。</li>\n<li>B 树能够在非叶子节点存储数据，但会导致在查询连续数据可能带来更多的随机 IO。</li>\n<li>而 B+ 树的所有叶节点可以通过指针来相互连接，减少顺序遍历带来的随机 IO。</li>\n</ul>\n<p>普通索引还是唯一索引？</p>\n<p>由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发建议你优先考虑非唯一索引。</p>\n<p>数据在磁盘等辅助存储设备中的情况（如MySQL等数据库），红黑树并不擅长，因为红黑树长得太高了。当数据在磁盘中时，磁盘IO会成为最大的性能瓶颈，设计的目标应该是尽量减少IO次数；而树的高度越高，增删改查所需要的IO次数也越多，会严重影响性能。</p>\n<h4 id=\"_5、什么是覆盖索引和索引下推\"> 5、什么是覆盖索引和索引下推？</h4>\n<p>覆盖索引：</p>\n<ul>\n<li>在某个查询里面，索引 k 已经“覆盖了”我们的查询需求，称为覆盖索引。</li>\n<li>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>\n</ul>\n<p>索引下推：</p>\n<ul>\n<li>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li>\n</ul>\n<h4 id=\"_6、哪些操作会导致索引失效\"> 6、哪些操作会导致索引失效？</h4>\n<p>查询导致的：</p>\n<ul>\n<li>对索引使用左或者左右模糊匹配，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。原因在于查询的结果可能是多个，不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</li>\n<li>WHERE 子句中的 OR语句，只要有条件列不是索引列，就会进行全表扫描。</li>\n</ul>\n<p>索引字段操作导致的：</p>\n<ul>\n<li>对索引进行函数/对索引进行表达式计算，因为索引保持的是索引字段的原始值，而不是经过函数计算的值，自然就没办法走索引。</li>\n</ul>\n<h4 id=\"_7、字符串加索引\"> 7、字符串加索引</h4>\n<ul>\n<li>直接创建完整索引，这样可能会比较占用空间。</li>\n<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引。</li>\n<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题。</li>\n<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>\n</ul>\n<h4 id=\"_8、最左前缀匹配原则了解么\"> 8、<strong>最左前缀匹配原则了解么？</strong></h4>\n<p>如果查询的时候查询条件精确匹配索引的左边连续一列或几列，那么索引就会生效。但是索引只能用于查找 key 是否存在（相等），遇到范围查询（&gt; ,&lt;,between, like 左匹配）等就不能进一步匹配了，后续退化为线性查找。如有索引（a、b、c、d）,查询条件 a= 1 and b = 2 and c &gt;3 and d = 4，则会在每个节点依次命中 a、b、c,无法命中 d。</p>\n<p>所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>\n<h4 id=\"_9、聚集索引和非聚集索引的区别-非聚集索引一定回表查询吗\"> 9、聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?</h4>\n<p>非聚集索引的索引和行记录是分开存储的，聚集索引的索引和行记录是存储在一起的。</p>\n<p>不一定回表查询，如果查的就是主键本身，那么就直接命中返回了。</p>\n<h4 id=\"_10、索引这么多优点-为什么不对表中的每一个列创建一个索引呢-使用索引一定能提高查询性能吗\"> 10、索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗）?</h4>\n<ol>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>\n<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>\n<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>\n</ol>\n<h4 id=\"页分裂\"> 页分裂</h4>\n<p>有时候主键不是自增长的，有可能后一个数据页的主键值小于前一个数据页的主键值，为了保证顺序，有个交换数据的过程，这个过程就叫页分裂。</p>\n<p>通过页分裂，让前后页数据顺序大小一致。这样就可以生成了主键目录，主键目录存在多个数据页中，这些数据页就称为索引页。再将多个索引页组建成 B+ 数结构，方便二分查找。</p>\n<p>https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMDg2OTAxNg==&amp;action=getalbum&amp;album_id=1952926902587834371&amp;scene=173&amp;from_msgid=2652054938&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect</p>\n<h4 id=\"change-buffer-的作用-或者-change-buffer-怎么提高索引性能的\"> change buffer 的作用？或者 change buffer 怎么提高索引性能的？</h4>\n<p>当索引字段内容发生更新时（<code>update、insert、delete</code>），要更新对应的<strong>索引页</strong>，如果<strong>索引页</strong>在<code>Buffer Pool</code>里命中的话，就直接更新<strong>缓存页</strong>。否则，<code>InnoDB</code>会将这些更新操作缓存在<code>change buffer</code>中，这样就无需从硬盘读入<strong>索引页</strong>。下次查询索引页时，会将索引页读入<code>Buffer Pool</code>，然后将<code>change buffer</code>中的操作应用到对应的缓存页，得到最新结果，这个过程称为<code>merge</code>，通过这种方式就能保证数据逻辑的正确性。</p>\n<h2 id=\"日志相关\"> 日志相关</h2>\n<h4 id=\"mysql-是如何判断一行扫描数的\"> MySQL 是如何判断一行扫描数的？</h4>\n<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条。而只能根据统计信息来估算记录数。这个统计信息就是索引的区分度。</p>\n<h4 id=\"redolog-和-binlog-的区别\"> RedoLog 和 BinLog 的区别？</h4>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/j5D4MI5U9vWic0cyXPB6QagLWhusHiaeTiahdxDgxa75icSp14OicBjUkhu92MG4uyO8aicB9c4vU2RD2rxZCw0TM2fQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:67%;\" />\n<p>保持一致是通过 redolog 两阶段提交实现。</p>\n<h4 id=\"为什么需要-redo-log\"> 为什么需要 redo log</h4>\n<ul>\n<li>当 buffer pool 中的 dirty page 还没有刷新到磁盘的时候，发生 crash，启动服务后，可通过redo log 找到需要重新刷新到磁盘文件的记录；</li>\n<li>buffer pool中的数据直接刷到到磁盘，是一个随机IO，效率较差，而把 buffer pool 中的数据记录到redo log，是一个顺序IO，可以提高事务提交的速度；</li>\n</ul>\n<h4 id=\"_5、为什么-redo-log-具有-crash-safe-的能力-是-binlog-无法替代的\"> 5、为什么 redo log 具有 crash-safe 的能力，是 binlog 无法替代的？</h4>\n<p>第一点：redo log 可确保 innoDB 判断哪些数据已经刷盘，哪些数据还没有</p>\n<ul>\n<li>redo log 和 binlog 有一个很大的区别就是，一个是循环写，一个是追加写。也就是说 redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。</li>\n<li>当数据库 crash 后，想要恢复<strong>未刷盘但已经写入 redo log 和 binlog 的数据</strong>到内存时，binlog 是无法恢复的。虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有。</li>\n<li>但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中抹掉，因为是循环写！数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。</li>\n</ul>\n<p>第二点：如果 redo log 写入失败，说明此次操作失败，事务也不可能提交</p>\n<ul>\n<li>redo log 每次更新操作完成后，就一定会写入日志，如果<strong>写入失败</strong>，说明此次操作失败，事务也不可能提交。</li>\n<li>redo log 内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放，就可以恢复数据。</li>\n</ul>\n<p>这就是为什么 redo log 具有 crash-safe 的能力，而 binlog 不具备。</p>\n<h4 id=\"_6、当数据库-crash-后-如何恢复未刷盘的数据到内存中\"> 6、当数据库 crash 后，如何恢复未刷盘的数据到内存中？</h4>\n<p>根据 redo log 和 binlog 的两阶段提交，未持久化的数据分为几种情况：</p>\n<ul>\n<li>redo log 虽然做了 fsync 但未 commit，binlog 未 fsync 到磁盘，这部分数据丢失。</li>\n<li>redo log fsync 未 commit，binlog 已经 fsync 到磁盘，先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer。</li>\n<li>redo log 和 binlog 都已经 fsync，直接从 redo log 里恢复。</li>\n</ul>\n<h4 id=\"_7、redo-log-写入方式\"> 7、redo log 写入方式？</h4>\n<p>redolog：概念、刷盘时机（三种）、日志文件组</p>\n<h4 id=\"_8、redo-log-的执行流程\"> 8、redo log 的执行流程?</h4>\n<p>我们来看下Redo log的执行流程，假设执行的 SQL 如下：</p>\n<div><pre><code>update T set a =1 where id =666\n</code></pre>\n<div><span>1</span><br></div></div><img src=\"https://mmbiz.qpic.cn/mmbiz_png/j5D4MI5U9vWic0cyXPB6QagLWhusHiaeTiacZCHZEvo8lFysyWtlicTV2vKgnfyHtHoicu9XrMGwoicAUlR7Way5t9wA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom: 67%;\" />\n<ol>\n<li>MySQL 客户端将请求语句 update T set a =1 where id =666，发往 MySQL Server 层。</li>\n<li>MySQL Server 层接收到 SQL 请求后，对其进行分析、优化、执行等处理工作，将生成的 SQL 执行计划发到 InnoDB 存储引擎层执行。</li>\n<li>InnoDB 存储引擎层将<strong>a修改为1</strong>的这个操作记录到内存中。</li>\n<li>记录到内存以后会修改 redo log 的记录，会在添加一行记录，其内容是<strong>需要在哪个数据页上做什么修改</strong>。</li>\n<li>此后，将事务的状态设置为 prepare ，说明已经准备好提交事务了。</li>\n<li>等到 MySQL Server 层处理完事务以后，会将事务的状态设置为 <strong>commit</strong>，也就是提交该事务。</li>\n<li>在收到事务提交的请求以后，<strong>redo log</strong> 会把刚才写入内存中的操作记录写入到磁盘中，从而完成整个日志的记录过程。</li>\n</ol>\n<h4 id=\"_9、redo-log-日志格式\"> 9、redo log 日志格式</h4>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/j5D4MI5U9vWic0cyXPB6QagLWhusHiaeTiabNCFRPbHpV0DLsQxouYcAbrriaZjIrRIicNhMKNvM2tp4YTRDQOJ5vDw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:50%;\" />\n<p>redo log buffer (内存中)是由首尾相连的四个文件组成的，它们分别是：ib_logfile_1、ib_logfile_2、ib_logfile_3、ib_logfile_4。</p>\n<ul>\n<li>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。</li>\n<li>checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</li>\n<li>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。</li>\n<li>如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</li>\n</ul>\n<h4 id=\"_10、什么是两阶段提交\"> 10、什么是两阶段提交？</h4>\n<p>MySQL 将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog，这就是&quot;两阶段提交&quot;。</p>\n<p>具体的看博客自己理解。</p>\n<h4 id=\"_11、mysql-怎么知道-binlog-是完整的\"> 11、MySQL 怎么知道 binlog 是完整的?</h4>\n<p>一个事务的 binlog 是有完整格式的：</p>\n<ul>\n<li>statement 格式的 binlog，最后会有 COMMIT；</li>\n<li>row 格式的 binlog，最后会有一个 XID event。</li>\n</ul>\n<h4 id=\"_12、什么是-wal-技术-有什么优点\"> 12、什么是 WAL 技术，有什么优点？</h4>\n<p>WAL，中文全称是 Write-Ahead Logging，它的关键点就是日志先写内存，再写磁盘。MySQL 执行更新操作后，<strong>在真正把数据写入到磁盘前，先记录日志</strong>。</p>\n<p>好处是不用每一次操作都实时把数据写盘，就算 crash 后也可以通过redo log 恢复，所以能够实现快速响应 SQL 语句。</p>\n<h4 id=\"_13、binlog-日志的三种格式\"> 13、binlog 日志的三种格式</h4>\n<p>binlog 日志有三种格式</p>\n<ul>\n<li>Statement：基于SQL语句的复制 (statement-based replication,SBR)</li>\n<li>Row：基于行的复制。(row-based replication,RBR)</li>\n<li>Mixed：混合模式复制。(mixed-based replication,MBR)</li>\n</ul>\n<p><strong>Statement格式</strong></p>\n<p>每一条会修改数据的 SQL 都会记录在 binlog 中</p>\n<ul>\n<li>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</li>\n<li>缺点：由于记录的只是执行语句，为了这些语句能在备库上正确运行，还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在备库得到和在主库端执行时候相同的结果。</li>\n</ul>\n<p><strong>Row格式</strong></p>\n<p>不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。</p>\n<ul>\n<li>优点：binlog 中可以不记录执行的 SQL 语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。不会出现某些特定情况下的存储过程、或 function、或trigger的调用和触发无法被正确复制的问题。</li>\n<li>缺点:可能会产生大量的日志内容。</li>\n</ul>\n<p><strong>Mixed格式</strong></p>\n<p>实际上就是 Statement 与 Row 的结合。一般的语句修改使用 statment 格式保存 binlog，如一些函数，statement 无法完成主从复制的操作，则采用 row 格式保存 binlog，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式。</p>\n<h4 id=\"_14、原本可以执行得很快的-sql-语句-执行速度却比预期的慢很多-原因是什么-如何解决\"> 14、原本可以执行得很快的 SQL 语句，执行速度却比预期的慢很多，原因是什么？如何解决？</h4>\n<p>原因：从大到小可分为四种情况</p>\n<ul>\n<li>MySQL 数据库本身被堵住了，比如：系统或网络资源不够。</li>\n<li>SQL 语句被堵住了，比如：表锁，行锁等，导致存储引擎不执行对应的 SQL 语句。</li>\n<li>确实是索引使用不当，没有走索引。</li>\n<li>表中数据的特点导致的，走了索引，但回表次数庞大。</li>\n</ul>\n<p>解决：</p>\n<ul>\n<li>考虑采用 force index 强行选择一个索引</li>\n<li>考虑修改语句，引导 MySQL 使用我们期望的索引。比如把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</li>\n<li>第三种方法是，在有些场景下，可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</li>\n<li>如果确定是索引根本没必要，可以考虑删除索引。</li>\n</ul>\n<h4 id=\"_15、innodb-数据页结构\"> 15、InnoDB 数据页结构</h4>\n<p>一个数据页大致划分七个部分</p>\n<ul>\n<li>File Header：表示页的一些通用信息，占固定的38字节。</li>\n<li>page Header：表示数据页专有信息，占固定的56字节。</li>\n<li>inimum+Supermum：两个虚拟的伪记录，分别表示页中的最小记录和最大记录，占固定的26字节。</li>\n<li>User Records：真正存储我们插入的数据，大小不固定。</li>\n<li>Free Space：页中尚未使用的部分，大小不固定。</li>\n<li>Page Directory：页中某些记录的相对位置，也就是各个槽对应的记录在页面中的地址偏移量。</li>\n<li>File Trailer：用于检验页是否完整，占固定大小 8 字节。</li>\n</ul>\n<img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/8/170baaef96af956e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\" style=\"zoom: 50%;\" />\n<h2 id=\"数据相关\"> 数据相关</h2>\n<h4 id=\"_1、在-mysql-中有两个-kill-命令\"> 1、在 MySQL 中有两个 kill 命令</h4>\n<ul>\n<li>一个是 kill query + 线程 id，表示终止这个线程中正在执行的语句</li>\n<li>一个是 kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接</li>\n</ul>\n<p>kill 不掉的原因</p>\n<ul>\n<li>kill命令被堵了，还没到位</li>\n<li>kill命令到位了，但是没被立刻触发</li>\n<li>kill命令被触发了，但执行完也需要时间</li>\n</ul>\n<h4 id=\"_2、如何理解-mysql-的边读边发\"> 2、如何理解 MySQL 的边读边发</h4>\n<ul>\n<li>\n<p>如果客户端接受慢，会导致 MySQL 服务端由于结果发不出去，这个事务的执行时间会很长。</p>\n</li>\n<li>\n<p>服务端并不需要保存一个完整的结果集，取数据和发数据的流程都是通过一个 net_buffer 来操作的。</p>\n</li>\n<li>\n<p>内存的数据页都是在 Buffer_Pool 中操作的。</p>\n</li>\n<li>\n<p>InnoDB 管理 Buffer_Pool 使用的是改进的 LRU 算法，使用链表实现，实现上，按照 7:3 的比例把整个 LRU 链表分成了 young 区域（热区域）和 old 区域（冷区域）。</p>\n</li>\n</ul>\n<h4 id=\"_3、mysql-的大表查询为什么不会爆内存\"> 3、MySQL 的大表查询为什么不会爆内存？</h4>\n<ul>\n<li>由于 MySQL 是边读变发，因此对于数据量很大的查询结果来说，不会再 server 端保存完整的结果集，所以，如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是不会把内存打爆。</li>\n<li>InnoDB 引擎内部，由于有淘汰策略，InnoDB 管理 Buffer_Pool 使用的是改进的 LRU 算法，使用链表实现，实现上，按照 7:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。对冷数据的全扫描，影响也能做到可控制。</li>\n</ul>\n<h4 id=\"_4、mysql-临时表的用法和特性\"> 4、MySQL 临时表的用法和特性</h4>\n<ul>\n<li>只对当前session可见。</li>\n<li>可以与普通表重名。</li>\n<li>增删改查用的是临时表。</li>\n<li>show tables 不显示普通表。</li>\n<li>在实际应用中，临时表一般用于处理比较复杂的计算逻辑。</li>\n<li>由于临时表是每个线程自己可见的，所以不需要考虑多个线程执行同一个处理时临时表的重名问题，在线程退出的时候，临时表会自动删除。</li>\n</ul>\n<h4 id=\"_5、如果数据库误操作-如何执行数据恢复\"> 5、如果数据库误操作, 如何执行数据恢复?</h4>\n<p>数据库在某个时候误操作，就可以找到距离误操作最近的时间节点的bin log，重放到临时数据库里，然后选择误删的数据节点，恢复到线上数据库。</p>\n<h2 id=\"事务\"> 事务</h2>\n<h4 id=\"_1、事务的四大特性了解么\"> 1、<strong>事务的四大特性了解么?</strong></h4>\n<p>事务是逻辑的上的一组操作，要么全部执行，要么都不执行。</p>\n<p>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>\n<p>一致性：执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</p>\n<p>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p>\n<p>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>\n<h4 id=\"_2、并发事务带来哪些问题\"> 2、并发事务带来哪些问题？</h4>\n<ul>\n<li>\n<p><strong>脏读（Dirty read）:</strong> 一个未commit 的事务读到了另一个事务未 commit 的数据。</p>\n</li>\n<li>\n<p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p>\n</li>\n<li>\n<p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。（一个事务在未 commit 之前读到了另一个事务 commit 的数据）</p>\n</li>\n<li>\n<p><strong>幻读（Phantom read）:</strong> 幻读和不可重复读一样，不可重复读是读异常，幻读是写异常。不可重复读是读异常的意思是，如果你不多 select几次，你是发现不了你曾经select过的数据行已经被其他人 update 过了。幻读是写异常的意思是，如果不自己 insert 一下，你是发现不了其他人已经偷偷 insert 过相同的数据了。（Mysql 通过 next-key lock 解决了 幻读）</p>\n</li>\n</ul>\n<h4 id=\"_3、mysql-事务隔离级别-默认是什么级别\"> 3、<strong>MySQL 事务隔离级别？默认是什么级别？</strong></h4>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>\n<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>\n<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。（Mysql InnoDB 不存在幻读问题，next-key lock 机制已经可以解决）</li>\n<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻影读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>READ-UNCOMMITTED</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>READ-COMMITTED</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>REPEATABLE-READ</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>SERIALIZABLE</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_4、mysql怎么保证acid\"> 4、MYSQL怎么保证ACID</h4>\n<p>https://www.cnblogs.com/CuiHongYu/p/10845354.html</p>\n<p>1、<em>Mysql怎么保证一致性的？</em></p>\n<p>​     从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。</p>\n<p>​     从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。</p>\n<p>2、<em>Mysql怎么保证原子性的？</em></p>\n<p>利用Innodb的<code>undo log</code>。</p>\n<p><code>undo log</code>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息</p>\n<h4 id=\"mysql怎么保证持久性的\"> Mysql怎么保证持久性的？</h4>\n<p>通过 redoLog ，宕机后可以通过 redolog 最终将数据刷盘。</p>\n<p>4、<em>Mysql怎么保证隔离性的？</em></p>\n<p>事务间的读写靠MySQL的<a href=\"https://so.csdn.net/so/search?q=%E9%94%81%E6%9C%BA%E5%88%B6&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener noreferrer\">锁机制</a>来保证隔离，事务间的写操作靠MVCC机制（快照读、当前读）来保证隔离性。</p>\n<h4 id=\"_5、事务的分类\"> 5、事务的分类</h4>\n<p>扁平事务：最基本是事务，由 Begin 开始，commit 或者 rollback 结束。</p>\n<p>带有保存点的扁平事务：保存点用来通知系统应该记住事务的当前状态，当发生错误之后，事务能回到保存点当时的状态。</p>\n<p>链事务：带有保存点的扁平事务的变种，带有保存点的扁平事务当系统发生奔溃时，所以保存点都会消失。</p>\n<p>嵌套事务：由一个顶层事务控制着各个层次的事务。顶级事务之下嵌套的事务被称为子事务。</p>\n<p>分布式事务</p>\n<h2 id=\"锁\"> 锁</h2>\n<h4 id=\"_1、行锁的类型\"> 1、行锁的类型</h4>\n<p>共享锁（s lock)：允许事务读一行数据</p>\n<p>排他锁（x lock)：允许事务删除或更新一行数据</p>\n<p>意向共享锁(IS Lock)：事务想要获得一张表中某几行的共享锁</p>\n<p>意向排他锁(IX Lock)：事务想要获得一张表中某几行的排他锁</p>\n<p>锁兼容，在事务 T1 获取了行 r 共享锁的时候，事务 T2 可以立即获得行 r 的共享锁。但是若有其他事务 T3 想获得行r 的排它锁，必读等待 T1，T2 释放行 r 的共享锁，这叫锁不兼容。</p>\n<p><img src=\"./images/image-20220330234043330.png\" alt=\"image-20220330234043330\" loading=\"lazy\"></p>\n<p><img src=\"./images/image-20220401213440063.png\" alt=\"image-20220401213440063\" loading=\"lazy\"></p>\n<h5 id=\"补充-auto-inc-锁\"> 补充：AUTO-INC 锁</h5>\n<p>自增主键的保障就是有 AUTO-INC 锁，是语句级别的：为表的某个列添加 AUTO_INCREMENT 属性，之后在插⼊记录时，可以不指定该列的值，系统会⾃动为它赋上单调递增的值。</p>\n<h4 id=\"_2、innodb-行锁的-3-钟算法\"> 2、InnoDB 行锁的 3 钟算法</h4>\n<ul>\n<li>Record lock：记录锁，单个行记录上的锁</li>\n<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>\n<li>Next-key lock：record + gap 锁定一个范围，包含记录本身。</li>\n</ul>\n<p>当查询的索引含有唯一属性时，InnoDB 会降级 Next-key lock 为 Record。但是若查询的索引是唯一索引中的多个列的某一个列，则依旧使用 Next-key lock。</p>\n<p>InnoDB 存储引擎默认的事务隔离级别是 RR，该隔离级别下，其采用的 Next-Key Locking 的方式来加锁。而在 RC 下，仅采用 Record lock 。故而在 RC 隔离级别下，锁定的是行，可以插入其他行，所以会出现不可重复度问题和幻读问题，而在 RR 下，因为是范围锁定，故而其他事务是无法读取或者插入的。</p>\n<h4 id=\"_3、一致性非锁定读\"> 3、一致性非锁定读</h4>\n<p>指的是 InnoDB 通过多版本的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 INSERT 或 UPDATE 操作，这时读取操作不会因此去等待行上 x 锁的释放，会去读行的一个快照数据。</p>\n<p>一个行记录可能不止一个快照数据，一般称这种技术为行多版本技术，由此带来的并发控制，称之为 <code>多版本并发控制</code>（MVCC）。</p>\n<p>在事务默认的隔离级别 RR 和 RC 下，InnoDB 使用非锁定的一致性读。然而对于快照数据定义不同，在RC下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据，而在 RR 隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>\n<p>（注意，这里的快照数据就是 undolog 的记录。Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生Undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。）</p>\n<h5 id=\"解释下为什么-rc-是最新快照数据-而rr-是事务开始时的数据\"> 解释下为什么 RC 是最新快照数据？而RR 是事务开始时的数据？</h5>\n<p>现在存在两个事务 A，事务B。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">时间</th>\n<th style=\"text-align:center\">事务A</th>\n<th style=\"text-align:center\">事务B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">BEGIN</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">select * from user where id = 1;</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">BEGIN</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">update use set name = &quot;B&quot; where id = 1;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">select * from user where id = 1;</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">COMMIT;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">select * from user where id = 1;</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">COMMIT</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<p>1、当一个事务开始的时候（<em>不包含开始本身这个事务</em>），会将当前数据库中正在活跃的事务（执行 begin 当没有 commit 的事务）保存到名为 trx_sys 的事务链表中，当事务提交后就会从其中删除。</p>\n<img src=\"images/999329-e836b86aa4cd7630.png\" alt=\"img\" style=\"zoom:50%;\" />\n<p>2、同样，在一个事务开始的时候，会根据上面的事务链表构造为一个 ReadView（本质就是一个数据结构）。</p>\n<p>3、当事务A 读取了 id = 1 的数据，事务B 更改完这条数据后。会生成一条 undolog 日志</p>\n<p><img src=\"./images/20210121192523998.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>​\t\t在 RR 隔离级别下，事务A 第一次查询生成 ReadView，当事务 A 第二次查询的时候，现查到的是 trx_id = 18 的那条数据，大于等于事务链表中的最大值 18 (数据行的DB_TRX_ID &gt;= m_low_limit_id)，说明数据在中间被更改过，是不可见的，接着就会按照 roll_pointer 指针继续往下找。故而这时候事务 A 能读取到的还是之前的值，即 RR 是事务开始的数据。</p>\n<p>​\t\t在 RC 隔离级别下，事务 B commit 之后，事务A执行查询的时候，生成了新的 ReadView，又因为这时候没有任何一个事务在执行，所以事务链表是空的，所以是可见的。故而能查事务B 提交的数据，即 RC 是最新的快照数据。</p>\n<h4 id=\"_4、乐观锁与悲观锁的区别\"> 4、<strong>乐观锁与悲观锁的区别?</strong></h4>\n<p>乐观锁：事务认为一定不会出现丢失更新。 添加一个额外的字段，譬如版本号之类的。</p>\n<p>悲观锁：事务认为一定会出现丢失更新。利用数据的锁机制，排他锁，可以在查询的时候加入 for update。</p>\n<h4 id=\"_5、数据库死锁\"> 5、数据库死锁</h4>\n<p>第一种：事务之间对资源访问顺序的交替</p>\n<p>由于两个事务分别持有了一个行锁，分别等待对方释放所持有的行锁，因此导致了死锁</p>\n<p>解决办法：调整程序的逻辑。</p>\n<p>第二种：并发修改同一条记录</p>\n<p>用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项目中经常发生。</p>\n<p>解决办法：</p>\n<p>a.乐观锁。</p>\n<p>b.悲观锁。查询加 for update，但是数据库性能开销很大。</p>\n<h2 id=\"主从备份相关\"> 主从备份相关</h2>\n<h4 id=\"_1、主备同步的实现原理\"> 1、主备同步的实现原理</h4>\n<img src=\"images/56b908c82863817d01b220562dbb1f2328c2e5eb\" alt=\"主备同步流程图\" style=\"zoom:80%;\" />\n<p>上图是一个update语句在节点A执行，然后同步到节点B的完整流程图，具体步骤有：</p>\n<ol>\n<li>主库接受到客户端发送的一条update语句，执行内部事务逻辑，同时写binlog。</li>\n<li>备库通过 change master 命令，设置主库的IP、端口、用户名和密码，以及要从哪个位置开始请求 binlog。这个位置包含文件名和偏移量。</li>\n<li>在备库上执行start slave命令，启动两个线程 io_thread 和 sql_thread，其中 io_thread 负责与主机进行连接。</li>\n<li>主库校验完用户名和密码，按照接收到的位置去读取binlog，发给备库。</li>\n<li>备库接收到binlog后，写到本地文件（relay log，中转文件）。</li>\n<li>备库读取中转文件，解析出命令，然后执行。</li>\n</ol>\n<p>主备同步的工作原理其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上是实时的。</p>\n<p>备库通过两个线程来实现同步：</p>\n<ul>\n<li>一个是 I/O 线程，负责读取主库的二进制日志，并将其保存为中继日志。</li>\n<li>一个是 SQL 线程，负责执行中继日志。</li>\n</ul>\n<h4 id=\"_2、什么是主备延迟\"> 2、什么是主备延迟</h4>\n<p>主库和备库在执行同一个事务的时候出现时间差的问题，主要原因有：</p>\n<ul>\n<li>有些部署条件下，备库所在机器的性能要比主库性能差。</li>\n<li>备库的压力较大。</li>\n<li>大事务，一个主库上语句执行10分钟，那么这个事务可能会导致从库延迟10分钟。</li>\n</ul>\n<h4 id=\"_3、为什么要有多线程复制策略\"> 3、为什么要有多线程复制策略？</h4>\n<ul>\n<li>因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库可能是一直追不上主库的，带来的现象就是备库上seconds_behind_master值越来越大。</li>\n<li>在实际应用中，建议使用可靠性优先策略，减少主备延迟，提升系统可用性，尽量减少大事务操作，把大事务拆分小事务。</li>\n</ul>\n<h4 id=\"_4、mysql-的并行策略有哪些\"> 4、MySQL 的并行策略有哪些？</h4>\n<ul>\n<li>按表分发策略：如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。缺点：如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</li>\n<li>按行分发策略：如果两个事务没有更新相同的行，它们在备库上可以并行。显然，这个模式要求 binlog 格式必须是 row。缺点：相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</li>\n</ul>\n<h4 id=\"_5、mysql的一主一备和一主多从有什么区别\"> 5、MySQL的一主一备和一主多从有什么区别？</h4>\n<p>在一主一备的双 M 架构里，两台机器都是互为主备关系，主备切换只需要把客户端流量切到备库；</p>\n<p>而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。</p>\n<h5 id=\"补充-双-m-架构循环复制问题\"> 补充：双 M 架构循环复制问题</h5>\n<ul>\n<li>设置节点的server-id，必须不同，不然不允许设置为主备结构</li>\n<li>备库在接到binlog后重放时，会记录原记录相同的server-id，即谁产生即为谁的。</li>\n<li>每个节点在接受binlog时，会判断server-id，如果是自己的就丢掉。</li>\n</ul>\n<p>https://www.cnblogs.com/liang24/p/14149412.html</p>\n<h2 id=\"性能相关\"> 性能相关</h2>\n<h4 id=\"_1、短时间提高-mysql-性能的方法\"> 1、短时间提高 MySQL 性能的方法</h4>\n<ul>\n<li>第一种方法：先处理掉那些占着连接但是不工作的线程。或者再考虑断开事务内空闲太久的连接。kill connection + id</li>\n<li>第二种方法：减少连接过程的消耗：慢查询性能问题在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能：索引没有设计好；SQL 语句没写好；MySQL 选错了索引（force index）。</li>\n</ul>\n<h4 id=\"_2、为什么-mysql-自增主键-id-不连续\"> 2、为什么 MySQL 自增主键 ID 不连续？</h4>\n<ul>\n<li>唯一键冲突</li>\n<li>事务回滚</li>\n<li>自增主键的批量申请</li>\n</ul>\n<p>深层次原因是：MySQL 不判断自增主键是否存在，从而减少加锁的时间范围和粒度，这样能保持更高的性能，确保自增主键不能回退，所以才有自增主键不连续。</p>\n<p>自增主键怎么做到唯一性？自增值加1来通过自增锁控制并发。‘</p>\n<h5 id=\"解释\"> 解释：</h5>\n<p>唯一键冲突：\n假设执行 SQL 的时候 user 表 id = 10，此时在内存中的自增 id 为11，此时发生唯一键冲突写库失败，则 user 表没有 id = 10 这条记录，之后 id 从11开始写入，因此 id 是不连续的。</p>\n<p>事务回滚：\n假设同时需要对 user、staff 表进行写库操作，执行 SQL 的时候 user 表 id = 10，此时在内存中的自增 id 为11；staff 表 id = 20，此时内存中的自增 id 为21，一旦事务执行失败，事务回滚，写库失败，则 user 表没有 id = 10 这条记录，staff 表没有 id = 20 这条记录，user 表从11开始写入，staff 表从21开始写入，如此产生 id 不连续的现象。</p>\n<p>批量写库操作：\n对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>\n<ol>\n<li>\n<p>语句执行过程中，第一次申请自增 id，会分配 1 个；</p>\n</li>\n<li>\n<p>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</p>\n</li>\n<li>\n<p>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</p>\n<p>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</p>\n<p>假设批量往 user 表中写入四条记录，则这四条记录将分为三次申请id，</p>\n<p>第一次分配到 id = 1，第二次分配到 id = 2、3 ，第三次分配到 id = 4、5、6、7，当批量写入四条记录之后，id = 1、2、3、4将会入库，但是 id = 5、6、7就被废弃了，下一个 id 从8开始。</p>\n</li>\n</ol>\n<h4 id=\"_3、innodb-为什么要用自增-id-作为主键\"> 3、InnoDB 为什么要用自增 ID 作为主键？</h4>\n<ul>\n<li>自增主键的插入模式，符合递增插入，每次都是追加操作，不涉及挪动记录，也不会触发叶子节点的分裂。</li>\n<li>每次插入新的记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</li>\n<li>而有业务逻辑的字段做主键，不容易保证有序插入，由于每次插入主键的值近似于随机。因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，写数据成本较高。</li>\n</ul>\n<h4 id=\"_4、mysql-有哪些自增id-各自场景是什么\"> 4、MySQL 有哪些自增ID？各自场景是什么？</h4>\n<ul>\n<li>表的自增 ID 达到上限之后，在申请值不会变化，进而导致联系插入数据的时候报主键冲突错误。</li>\n<li>row_id：达到上限之后，归 0 在重新递增，如果出现相同的 row_id 后写的数据会覆盖之前的数据。</li>\n<li>Xid：看下面5。只需要不在同一个 binlog 文件出现重复值即可，理论上会出现重复值，但概率极小可忽略不计。</li>\n<li>max_trx_id：InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。递增值每次 MySQL 重启会保存起来。</li>\n<li>thread_id：系统保存了一个环境变量<strong>thread_id_counter</strong> 每新建一个连接，就将<strong>thread_id_counter</strong>赋值给这个<strong>新连接的线程变量</strong>。使用了insert_unique算法。</li>\n</ul>\n<p>https://blog.csdn.net/u013487071/article/details/123429195</p>\n<h4 id=\"_5、xid-在-mysql-内部是怎么生成的呢-xid-和-trx-id-区别\"> 5、Xid 在 MySQL 内部是怎么生成的呢？xid 和 trx_id 区别？</h4>\n<p>Xid 是由 server 层维护的。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。</p>\n<p>MySQL 内部维护了一个全局变量 global_query_id，每次执行语句（包括select语句）的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。</p>\n<p>而 global_query_id 是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是惟一的。</p>\n<h5 id=\"xid-存在的意义\"> xid 存在的意义：</h5>\n<p>redo log 和 binlog 有一个共同的数据字段，叫 XID，崩溃恢复的时候，会按顺序扫描 redo log：</p>\n<p>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；\n如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p>\n<h5 id=\"trx-id-存在的意义\"> trx_id 存在的意义：</h5>\n<p>每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比</p>\n<h2 id=\"其他\"> 其他</h2>\n<h4 id=\"_1、orderby-排序内部原理\"> 1、orderby 排序内部原理</h4>\n<ul>\n<li>\n<p>MySQL 会为每个线程分配一个内存（sort-buffer）用于排序，该内存大小为 sort_buffer_size；</p>\n</li>\n<li>\n<p>如果排序的数据量小于 sort_buffer_size，排序就会在内存中完成；</p>\n</li>\n</ul>\n<h5 id=\"内部排序分为两种\"> 内部排序分为两种：</h5>\n<ul>\n<li>\n<p>全字段排序：到索引树上找到满足条件的主键ID根据主键ID去取出数据放到 sort_buffer 然后进行快速排序</p>\n</li>\n<li>\n<p>rowid排序：通过控制排序的行数据的长度来让 sort_buffer 中尽可能多的存放数据</p>\n</li>\n</ul>\n<p>如果数据量很大，内存中无法存下这么多，就会使用磁盘临时文件来辅助排序，称为外部排序；外部排序，MySQL会分为好几份单独的临时文件来存放排序后的数据，一般是磁盘文件中进行归并，然后将这些文件合并成一个大文件；</p>\n<h4 id=\"_2、count-实现方式以及各种-count-对比\"> 2、count(*)实现方式以及各种 count 对比</h4>\n<ul>\n<li>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</li>\n<li>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</li>\n<li>对于 count(字段) 来说：如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</li>\n<li>但是 count * 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</li>\n</ul>\n<p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(※)，所以建议尽量使用 count(*)。</p>\n<h2 id=\"文章系列\"> 文章系列</h2>\n<p>biglog：概念、记录格式、写入机制</p>\n<p>bufferPool：缓存页、描述数据、Free 链表、缓存页哈希表、Flush链表、LRU链表、LRU链表优化</p>\n<p>数据页变为索引：页分裂、主键目录、索引页</p>\n<p>https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMDg2OTAxNg==&amp;action=getalbum&amp;album_id=1952926902587834371&amp;scene=173&amp;from_msgid=2652054938&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect</p>\n",
      "date_modified": "2022-04-29T06:23:43.009Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "1、CAP理论",
      "url": "https://fmiles.cn/interview/%E5%88%86%E5%B8%83%E5%BC%8F/",
      "id": "https://fmiles.cn/interview/%E5%88%86%E5%B8%83%E5%BC%8F/",
      "content_html": "<h4 id=\"_1、cap理论\"> 1、CAP理论</h4>\n<p>CAP 定理（CAP theorem）指对于一个分布式系统来说，当设计读写操作时，只能能同时满足以下三点中的两个：</p>\n<ul>\n<li><strong>一致性（Consistence）</strong> : 一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值 (这个无论哪个节点就包含了故障和非故障节点)</li>\n<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>\n<li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>\n</ul>\n<h6 id=\"网络分区\"> 网络分区？</h6>\n<blockquote>\n<p>​\t\t分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p>\n</blockquote>\n<p>​        <strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>\n<h4 id=\"_2、base-理论\"> 2、BASE 理论</h4>\n<p>CA 都要是无法实现的，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而追求最终一致性，所以引入BASE理论，在分布式事务中，BASE最重要是为CAP提出了最终一致性的解决方案，BASE强调牺牲高一致性，从而获取肯用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p>\n<p>1、基本可用：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>\n<p>2、软状态：软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>\n<p>3、最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态</p>\n<p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>\n<p>分布式一致性的 3 种级别：</p>\n<ol>\n<li><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</li>\n<li><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>\n<li><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>\n</ol>\n<h5 id=\"_4、限流-降级-熔断-排队\"> 4、限流，降级，熔断，排队</h5>\n<p>限流：对某个接口限制访问的频率，超过限制的请求放弃处理或者放到队列等待处理。</p>\n<p>限流算法：</p>\n<blockquote>\n<p>固定窗口计数器算法：记录规定时间内处理的请求数量，超出部分拒绝，然后重新计数。无法保证限流速率，无法保证突然激增的流量。</p>\n<p>滑动窗口计数器算法：譬如限流每分钟60个请求，把每分钟分成60个窗口，则每个窗口一秒只能处理 60/60 个请求。</p>\n<p>漏桶算法：请求类似于水注入水桶，这个水从桶中滴下的速率恒定的，多余的丢弃。</p>\n<p>令牌算法：和漏桶算法差不多，只不过是保证令牌处理的速率。</p>\n</blockquote>\n<p>降级：优先保证核心服务。</p>\n<p>熔断：请求失败达到一个阀值的时候，就会触发熔断。降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p>\n<p>排队：相当于现实生活中的排队。</p>\n<h4 id=\"_5、分布式唯一全局-id\"> 5、分布式唯一全局 id</h4>\n<h2 id=\"分布式事务\"> 分布式事务</h2>\n<h4 id=\"_1、两阶段提交-2pc\"> 1、两阶段提交（2pc）</h4>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588a87ee0c96~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image\" loading=\"lazy\"></p>\n<ul>\n<li>每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li>\n<li>每个数据库提交数据，或者回滚数据。</li>\n</ul>\n<p>最大的缺点就是同步阻塞问题，在资源准备就绪之后，资源管理器中的资源就一直处于阻塞，直到提交完成之后，才进行资源释放。</p>\n<h4 id=\"_2、补充事务\"> 2、补充事务</h4>\n<p>TCC是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel三个方法，这三个方式可以对应到SQL事务中Lock，Commit，Rollback。</p>\n<p>一个下订单，生成订单扣库存的例子：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588aa9cf1fed~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image\" loading=\"lazy\"></p>\n<p>接下来看看，我们的下单扣减库存的流程怎么加入TCC</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588ab8cd2a20~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image\" loading=\"lazy\"></p>\n<p>在try的时候，会让库存服务预留n个库存给这个订单使用，让订单服务产生一个“未确认”订单，同时产生这两个预留的资源， 在confirm的时候，会使用在try预留的资源，在TCC事务机制中认为，如果在try阶段能正常预留的资源，那么在confirm一定能完整的提交</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588ab8c51652~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image\" loading=\"lazy\"></p>\n<p>在try的时候，有任务一方为执行失败，则会执行cancel的接口操作，将在try阶段预留的资源进行释放。</p>\n<h4 id=\"_3、本地事务表\"> 3、本地事务表</h4>\n<p>核心思想是将分布式事务拆分成本地事务进行处理。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588acde414a6~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image\" loading=\"lazy\"></p>\n<p>对于本地消息队列来说，核心就是将大事务转变为小事务，还是用上面下订单扣库存的例子说说明</p>\n<ol>\n<li>当我们去创建订单的时候，我们新增一个本地消息表，把创建订单和扣减库存写入到本地消息表，放在同一个事务（依靠数据库本地事务保证一致性）</li>\n<li>配置一个定时任务去轮训这个本地事务表，扫描这个本地事务表，把没有发送出去的消息，发送给库存服务，当库存服务收到消息后，会进行减库存，并写入服务器的事务表，更新事务表的状态。</li>\n<li>库存服务器通过定时任务或直接通知订单服务，订单服务在本地消息表更新状态。</li>\n</ol>\n<p>这里须注意的是，对于一些扫描发送未成功的任务，会进行重新发送，所以必须保证接口的幂等性。</p>\n<p>本地消息队列是BASE理论，是最终一致性模型，适用对一致性要求不高的情况。</p>\n<h4 id=\"_4、mq-事务\"> 4、MQ 事务</h4>\n<p>RocketMq在4.3版本已经正式宣布支持分布式事务。RocketMQ中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了MQ内部。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588ae2844970~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image\" loading=\"lazy\"></p>\n<p>MQ事务是对本地消息表的一层封装，将本地消息表移动到了MQ内部，所以也是基于BASE理论，是最终一致性模式，对强一致性要求不那么高的事务适用，同时MQ事务将整个流程异步化了，也非常适合在高并发情况下使用。</p>\n<p>参考：</p>\n<p>https://juejin.cn/post/6844903936718012430</p>\n<h2 id=\"分布式锁\"> 分布式锁</h2>\n<p>https://www.cnblogs.com/crazymakercircle/p/14504520.html</p>\n",
      "image": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d0588a87ee0c96~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp",
      "date_modified": "2022-04-29T06:23:43.014Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "java3y github（有内推）:",
      "url": "https://fmiles.cn/interview/%E5%8D%9A%E5%AE%A2%E5%90%88%E9%9B%86/",
      "id": "https://fmiles.cn/interview/%E5%8D%9A%E5%AE%A2%E5%90%88%E9%9B%86/",
      "content_html": "<h4 id=\"java3y-github-有内推\"> java3y github（有内推）:</h4>\n<p>https://github.com/AobingJava/JavaFamily\n掘金 redis系列：\nhttps://juejin.cn/user/4406498333825357/posts</p>\n<h4 id=\"javaguide\"> javaguide：</h4>\n<p>https://javaguide.cn/database/redis/redis-questions-01.html</p>\n<h4 id=\"对线面试官系列\"> 对线面试官系列：</h4>\n<p>https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247484431&amp;idx=1&amp;sn=17b9e88233282469481e214a0cd2dc56&amp;chksm=fdf0ec50ca8765460a20af19101855c859a6350a8dfd6680e7f47c2e73f03de48288184a1bf3&amp;token=310857929&amp;lang=zh_CN&amp;scene=21#wechat_redirect</p>\n<h4 id=\"jvm-面试题\"> jvm 面试题：</h4>\n<p>https://www.cnblogs.com/chengxuyuanxiaoyang/p/13692997.html</p>\n<h4 id=\"mysql-面试题\"> Mysql 面试题：</h4>\n<p>https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwMDg2OTAxNg==&amp;action=getalbum&amp;album_id=1952926902587834371&amp;scene=173&amp;from_msgid=2652054938&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect</p>\n<h4 id=\"hashmap\"> HashMap</h4>\n<p>https://wenku.baidu.com/view/79197504ac45b307e87101f69e3143323968f5c7.html</p>\n<h4 id=\"面试和简历\"> 面试和简历：</h4>\n<p>https://juejin.cn/post/6844904034218803214</p>\n<p><a href=\"https://mp.weixin.qq.com/s/T8Xrik_PFszD1QvpGFYgfQ\" target=\"_blank\" rel=\"noopener noreferrer\">简历准备及面试技巧 (qq.com)</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/Pyi-lbocEr_vFeGxUkSl8A\" target=\"_blank\" rel=\"noopener noreferrer\">面试官希望你做怎样的自我介绍？阿丙面试官示范给你看 (qq.com)</a></p>\n<ul>\n<li>\n<p>[x] Java集合比如说 HashMap 和 ConcurrentHashMap 我觉得，你最好在平时能去耐心读一下源码，搜一搜相关的博客，最好能知道每个参数为什么设置成这么大？有什么好处？为什么？你会发现不少东西，网上也有很多视频可以去学。</p>\n</li>\n<li>\n<p>[ ] JUC包，毫无疑问的，你得去学，哪怕你平时编程根本不去用，但是你得会，只得知道有这个东西，你至少得知道aba，cas，aqs，unsafe，volatile，sync，常见的各种lock，死锁，线程池参数和如何合理的去设置，你必须明白自旋，阻塞，死锁和它如何去定位，oom如何定位问题，cpu过高如何定位等基本的操作，你可以没有生产调试经验，但不代表你可以不会top，jps，jstack，jmap这些可能会问的东西。以及可能衍生的jmm模型和mesi协议等。</p>\n</li>\n<li>\n<p>[ ]\nJVM毫无意外，大厂必须问，垃圾回收算法，垃圾收集器，jvm内存模型，每个区域用途，各种oom的种类，jvm调优经验，没有你也要做过，自己去设置启动参数，知道常见参数的含义，类加载过程，双亲委派，什么时候young gc，full gc，各种情况进入老年代的方式，你知道的越多越好，因为吹起来就越自信，举个例子，逃逸分析是什么？markword里面有什么？</p>\n</li>\n<li>\n<p>[ ] Spring，最好能抽空看看源码，最起码bean的生命周期，如何解决循环依赖，父子容器，还有boot的启动流程，事务实现原理，动态代理原理等，你知道越多越好。</p>\n</li>\n</ul>\n<p>Dubbo，因为我用的是dubbo，而且我写了，这个也是高频，写了必须问的，他的设计框架，负载均衡，spi机制，一般顺势会提到zk，选举算法，分布式锁等，一些常见的dubbo问题可以去搜，网上的基本都有。可能会顺带去问cloud的问题，生产没用过不怕，你现在可以自己clone一个项目，最起码，互联娃，你得知道还有这个玩意儿，还有他集成了啥，比如eureka，hystrix，ribbon，feign，zuul这些常规的东西吧，他们做什么的？改为 Nacos</p>\n<ul>\n<li>\n<p>[ ] Redis，必须会的，我这方便还算懂得多点，可以和面试官大战几个回合吧，应该不至于上来被打趴下，单线程模型，aof，rdb，rewrite，主从，cluster，哪些类型，不要再说常规的5个了，多说几个让你区别其他小哥，包含一些缓存常见的问题击穿、穿透、雪崩、数据一致性等，你必须会，不会基本没戏，一致性hash，布隆过滤器的原理，为此我还去了解了geohash的原理以及google s2的原理，底层数据结构sds和跳表等，你多学点，准没错。</p>\n</li>\n<li>\n<p>[x] Mysql，事务，锁，索引，b+树，主从这些你必须会</p>\n</li>\n<li>\n<p>[x] Mq ，我用的rocketmq，你得知道为什么用，重复消费，顺序消息，事务消息，高可用，消息丢失，挤压场景，整个消息发送消费的流程，读过源码更佳，更好吹</p>\n</li>\n<li>\n<p>[x]\n零拷贝，bio，nio，aio</p>\n</li>\n</ul>\n<p>算法，建议去刷题，我运气好，简单的算法让我碰到了，一些快排，堆排，二叉树相关的，链表反转，成环，环节点，跳楼梯等常规的简单算法建议刷刷，双指针，dp，递归这些还是多找找感觉，大数据内存有限的场景的统计，有时间一些middle可以去试试，手写红黑树你要是可以，那我估计算法你稳了。</p>\n<p>网络，http，tcp，https，udp，7层网络协议等，最好结合自己理解，背，你都要背下来。</p>\n<p>还有就是一些分布式事务实现，架构实现，比如抢红包，高并发下单等常规的场景设计，你来设计，你怎么去设计？多找一些大牛或者上网自己查，帮你看看有哪些漏洞，有那些解决方案？业界有哪些好的中间件？</p>\n<p>阿里面试：</p>\n<p>多线程（ThreadLocal（问了父子线程怎么共享数据 interitableThreadLocals）、lock 和 sync 区别（问HashMap1.7、1.8区别时带出）、AQS原理（执行过程源码，入队出队的细节，源码细节）、CountDownLatch和CyclicBarrier的区别是什么源码级别、volatile从指令重排序，内存屏障，聊到总线风暴）所占比重较大</p>\n<p>数据库（mysql索引（聚集索引、非聚集索引、索引结构（顺带会问各种树的特性）、执行计划、count1*区别、举例优化sql、MVCC和事务隔离级别的关系、间隙锁、行锁（和多线程混合问的，乐观锁悲观锁等）、唯一索引和普通索引的区别聊到了changeBuffer，聊了页分裂合页合并）比重较大</p>\n<p>jvm调优（可达性分析算法中根节点有哪些、cms和G1区别、怎样GC调优、怎样排查CPU彪高、内存彪高、逃逸分析）</p>\n<p>redis数据结构、跳跃表、redis qps能上多少，怎么知道的、sentinel和cluster区别和各自适用场景、redis cluster集群同步过程、redis单线程为什么快、多大叫大key、热key产生原因和后果以及怎么解决、本地缓存需要高时效性怎么办.....</p>\n<p>spring的作用、spring循环依赖怎么解决（说出三级缓存源码细节）、spring aop原理（动态代理）、spring bean生命周期（源码细节，以及各个位置的设计思路，有什么可扩展的）</p>\n<p>NIO、BIO区别，NIO解决了什么问题</p>\n<p>限流标准</p>\n<p>阿里蚂蚁：</p>\n<h5 id=\"一面\"> 一面</h5>\n<p>1、匿名类,内部类静态内部类</p>\n<p>2、HashMap 1.7和1.8区别</p>\n<p>3、BlockingQueue 相关知识</p>\n<p>4、线程池的创建形式,使用场景</p>\n<p>5、多线程下实现一个计数器</p>\n<p>6、wait 和 notify</p>\n<p>7、B+树和红黑树</p>\n<p>8、数据库的隔离级别</p>\n<p>9、数据库如何解决幻读</p>\n<p>10、mysql 索引</p>\n<p>11、redis 分布式锁</p>\n<p>12、redis 哨兵集群</p>\n<p>13、rpc 调用过程</p>\n<p>14、zookeeper 是怎么服务发现的</p>\n<p>15、zookeeper 心跳检测</p>\n<p>总体来说，跟上面的面试过程也是大体上面相似，也没有什么难点的。因此也不做详细分析了～</p>\n<h5 id=\"二面\"> 二面</h5>\n<p>二面进行的也是比较快，主要是两个问题吧</p>\n<blockquote>\n<p>项目介绍</p>\n</blockquote>\n<p>也是跟上面的差不多内容</p>\n<blockquote>\n<p>场景题</p>\n</blockquote>\n<p>用户的资源权限数据库设计</p>\n<h5 id=\"三面\"> 三面</h5>\n<p>三面面试官问题主要是跟业务场景和架构方面的， 整体跟腾讯的三面差不多（实际上是因为忘记了问了啥， 主要也是跟项目相关的）</p>\n<h5 id=\"四面\"> 四面</h5>\n<p>整个流程下来大概10分钟左右，当时刚面完头条，有点突然。</p>\n<blockquote>\n<p>项目难点</p>\n</blockquote>\n<blockquote>\n<p>问题处理</p>\n</blockquote>\n<blockquote>\n<p>团队角色</p>\n</blockquote>\n<blockquote>\n<p>学习方法</p>\n</blockquote>\n",
      "date_modified": "2022-04-29T06:23:43.020Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring",
      "url": "https://fmiles.cn/interview/%E6%A1%86%E6%9E%B6/",
      "id": "https://fmiles.cn/interview/%E6%A1%86%E6%9E%B6/",
      "content_html": "<h2 id=\"spring\"> Spring</h2>\n<h4 id=\"spring-循环依赖怎么解决-说出三级缓存源码细节\"> spring 循环依赖怎么解决（说出三级缓存源码细节）</h4>\n<p><strong>循环依赖</strong>：循环依赖就是两个或多个 bean 互相之间的持有对方。</p>\n<h5 id=\"spring-中循环依赖处理分为-3-种情况\"> Spring 中循环依赖处理分为 3 种情况：</h5>\n<p>1、构造器循环依赖；通过构造器注入构成的循环依赖，这种是没办法解决的。</p>\n<p>2、setter 循环依赖：通过 setter 注入方式构成的循环依赖。通过提前暴露刚完成构造器注入但未完成其他步骤的 bean 来完成的，只能解决单例作用域的 bean 循环依赖。</p>\n<p>3、prototype 范围的依赖处理，这种是无法完成依赖注注入的。</p>\n<h5 id=\"解决方法就是三级缓存\"> 解决方法就是三级缓存：</h5>\n<p>singletonFactories 单例对象工厂的缓存。在真正创建 bean 的方法 doCreateBean 中，实例化一个 bean 之前，先把 bean 放入 singletonFactories 让这个 bean 可以提前被获取到。这就是第三级缓存。</p>\n<p>earlySingletonObjects 存放暴露的 bean。第二级缓存。</p>\n<p>singletonObjects  单例对象的缓存。第一级别缓存。</p>\n<p>举例说明流程：当类 A 创建的时候，第一次通过 getSingleton() 获取不到 bean，就会去创建 bean。在 doCreateBean()  方法中，在调用createBeanInstance() 之后，populateBean之前，也就是实例化后属性填充之前，会把类 A 的 bean 提前放入 singletonFactories中。然后属性填充的时候发现依赖的 B 不存在，就会去创建B。创建流程和 A 一致，B 在获取 A的时候，发现A在创建中，尝试一级缓存 singletonObjects 获取 A，但是肯定失败，因为 A还没有初始化完成的；然后接着尝试二级缓存 earlySingletonObjects，也是获取不到的，最后尝试三级缓存 singletonFactories，由于 A 一级提前曝光了，所以能获取到，直接完成加载。</p>\n<h5 id=\"为什么需要第三级缓存-或者说为什么将-singletonfactories-对象去掉加入-earlysingletonobjects中-直接放入不行吗\"> 为什么需要第三级缓存？或者说为什么将 singletonFactories 对象去掉加入 earlySingletonObjects中？直接放入不行吗？</h5>\n<p>有三级缓存的基础上，二级缓存中的对象肯定是已经被代理过的(对象需要代理的情况)，而去掉三级缓存的话，二级缓存中的对象可能是已经被代理了，也可能是对象刚放进去，还没有进行代理，这种时候对于依赖的bean就都需要多加一步判断查看从二级缓存拿到的对象是不是已经被代理了。</p>\n<p>在源码角度分析：doCreateBean 方法中的 addSingletonFactory 之前，会执行 getEarlyBeanReference，这个方法会在 AbstractAutoProxyCreator 类中被改写，主要就是在 earlyProxyReferences （就是个map）中存放一下这个 bean，接着会去调用 wrapIfNecessary方法返回代理的bean，在 bean 初始化之后，也会调用 postProcessAfterInitialization，这时候会把 earlyProxyReferences 中存放的 bean 拿出来，如果相同就不会再创建代理类，即这里返回的是 orgin bean。这时候，如果没有这个三级缓存，那么这时候就会存在两种 bean。</p>\n<h4 id=\"spring-bean-生命周期-源码细节-以及各个位置的设计思路-有什么可扩展的\"> spring bean 生命周期（源码细节，以及各个位置的设计思路，有什么可扩展的）</h4>\n<p>Spring Bean的生命周期分为<code>四个阶段</code>和<code>多个扩展点</code>。\n四个阶段</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>有 8 个后置处理的方法 4 个后置处理器的类。</p>\n<h4 id=\"spring-aop-原理-动态代理\"> spring aop 原理（动态代理）</h4>\n<p>首先在讲 AOP 原理之前，有个类叫 DefaultAdvisorAutoProxyCreator，它能实现自动将所有的 advisor 生效，继承自 BeanPostProcessor。</p>\n<p>bean 在创建过程中，createBean 方法中，有 initializeBean 方法  初始化一个 bean，而在这个方法中，执行每一个 BeanPostProcessor 的 postProcessAfterInitialization 方法。在通常情况下，postProcessAfterInitialization 返回的是创建的 bean 本身，但是如果存在 AOP 的情况下，那么 postProcessAfterInitialization 将会在 DefaultAdvisorAutoProxyCreator 父类 AbstractAutoProxyCreator 这一层被重写。</p>\n<p>重写的逻辑中最主要的就是 createProxy 方法创建代理对象，而 createProxy 方法中最重要的就是生成 ProxyFactory 对象，通过 ProxyFactory的getProxy 方法生成代理对象。getProxy 方法需要创建一个 AOPProxy 实例，而创建 AOPProxy 实例之前，又需要创建 AOPProxyFactory，查看构造方法可以考到，这个 AOPProxyFactory 其实就是 DefaultAdvisorAutoProxyCreator，这样就用上了 DefaultAdvisorAutoProxyCreator类。然后调用createAopProxy(…)   生成 AOPProxy，这里就实现了对于 jdk 动态代理还是 CGLIB 代理的一个区分，即如果被代理类实现一个或者多个自定义接口的话，那么就会被 jdk 动态代理。回到之前，生成的 AOPProxy 调用的 getProxy 会按照不同的代理对象有不同的实现。后面就是动态代理的实现原理。</p>\n<h4 id=\"spring-bean-的作用域\"> Spring Bean  的作用域？</h4>\n<ul>\n<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>\n<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>\n<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>\n<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>\n</ul>\n<h4 id=\"springboot-自动装配原理\"> SpringBoot 自动装配原理</h4>\n<p>从我们日常使用 SprinBoot 来说，就是一个 @SpringBoot 注解，这个注解又主要由三个注解组成：</p>\n<p>@SpringBootConfiguration 本质上就是 一个 @Configuration 。只不过为了区别其他配置类。表明这个类是一个配置类；</p>\n<p>@ComponetScan 默认从添加这个注释的包开始扫描；</p>\n<p>@EnableAutoConfiguration。</p>\n<p>其中自动装配的实现就与这个注解有关，而这个注解定义又有两个比较重要的部分：</p>\n<p>@AutoConfigurationPackage：将添加该注解的类所在的 package 作为自动配置 package 进行管理。\n@Import({AutoConfigurationImportSelector.class})：@Import 注解的作用就是把一个 bean 注入到 Spring 容器中。@Import 可以导入不同类型的 bean，其中实现了 ImportSelector 接口的 Bean，ImportSelector 接口可以根据注解信息导入需要的 Bean。</p>\n<p>AutoConfigurationImportSelector 实现了 ImportSelector 接口，也就实现了这个借口中的 selectImports 方法，这个方法就是获取所有符合条件的类的全限定名，是需要被加载到 IOC 容器中的。这个方法中会调用  getCandidateConfigurations 方法，而这个 getCandidateConfigurations 底层又去调用 SpringFactoriesLoader.loadFactoryNames，里面会有个配置好的路径，FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 而在这个配置类中就是 SpringBoot 写好的自动装配类。</p>\n<p>但是并不是所有的自动装配类都会被一股脑注册到容器中，因为存在 @Conditional 注解，这个注解只有在满足特定条件的情况下才会被注册到容器中。拿 WebMvcAutocConfiguration 配置类举例，这有个类上有 @ConditionClass,所以必须满足要求的类 Servlet，DispatchServlet，WebMvcConfiguer 。而 @Conditionl 注解作用于 Spring 读取 Bean 定义的阶段，并且只有扫描包或者@Configuration注解类中的的Bean会使用@Conditionl注解进行判断。</p>\n<h4 id=\"springboot-热部署\"> SpringBoot 热部署</h4>\n<p>spring-boot实现了热部署的功能，即在不需要对程序进行重启的情况下对程序进行迭代；</p>\n<p>其原理就是监听class文件是否发生改变，如果改变则使用类加载其将字节码重新读入到<a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener noreferrer\">内存</a>中；缺点在于这种方式会占用大量的内存造成程序的卡顿，常用于本地开发中；</p>\n",
      "date_modified": "2022-04-29T06:23:43.020Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "1、你都在什么场景用到了消息队列？",
      "url": "https://fmiles.cn/interview/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",
      "id": "https://fmiles.cn/interview/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",
      "content_html": "<h4 id=\"_1、你都在什么场景用到了消息队列\"> 1、你都在什么场景用到了消息队列？</h4>\n<p><strong>异步、削峰、解耦</strong></p>\n<p>异步：省时间。</p>\n<p>解耦：省代码。</p>\n<h5 id=\"为什么不用线程池去做\"> 为什么不用线程池去做？</h5>\n<p>因为要不断的改业务代码，然后还要重新发版本，麻烦。</p>\n<p>削峰：系统的请求过多，服务器处理能力不够，可能会打挂服务器。解决办法可以是把请求放到队列里面，然后至于每秒消费多少请求，就看自己的服务器处理能力。</p>\n<h4 id=\"_2、如何解决重复消费问题\"> 2、如何解决重复消费问题？</h4>\n<p>问题描述：现在有几个不同的系统监听着同一个系统，当其中一个业务出了异常，会有重试机制，当重发消息之后，其他的系统还是会接收到这个消息。真实情况的重试是很正常的，譬如服务的网络抖动，代码的 bug，还有数据问题等可能需要重发消息。</p>\n<h5 id=\"怎么解决重复消费\"> 怎么解决重复消费？</h5>\n<p>幂等：通俗讲就是一个同样的参数调用这个接口，调用多少次结果都是一样。</p>\n<h5 id=\"怎么保证幂等\"> 怎么保证幂等？</h5>\n<p>一般会分场景去考虑，看是强校验还是弱校验。比如支付相关的场景那很关键，需要强校验，别的不是很重要的就做弱校验。</p>\n<p><strong>强校验</strong>：比如你监听到用户支付成功的消息，你监听到了去加GMV是不是要调用加钱的接口，那加钱接口下面再调用一个加流水的接口，<strong>两个放在一个事务，成功一起成功失败一起失败</strong>。</p>\n<p>每次消息过来都要拿着<strong>订单号+业务场景这样的唯一标识</strong>（比如天猫双十一活动）去流水表查，看看有没有这条流水，有就直接return不要走下面的流程了，没有就执行后面的逻辑。</p>\n<p>之所以用<strong>流水表</strong>，是因为涉及到金钱这样的活动，有啥问题后面也可以去流水表<strong>对账</strong>，还有就是帮助开发人员定位问题。</p>\n<p><strong>弱校验</strong>：这个简单，一些不重要的场景，比如给谁发短信啥的，我就把这个id+场景唯一标识作为<strong>Redis</strong>的key，放到缓存里面。失效时间看你场景，<strong>一定时间内</strong>的这个消息就去Redis判断。用KV就算消息丢了可能这样的场景也没关系，反正丢条<strong>无关痛痒</strong>的通知短信。</p>\n<h4 id=\"_3、如何解决消息的顺序消费问题\"> 3、如何解决消息的顺序消费问题？</h4>\n<p>问题描述：一般都是<strong>同个业务场景下不同几个操作的消息同时过去</strong>，本身顺序是对的，但是你发出去的时候同时发出去了，消费的时候却乱掉了，这样就有问题了。</p>\n<h5 id=\"如何解决\"> 如何解决？</h5>\n<p><strong>RocketMQ</strong>提供了<strong>MessageQueueSelector</strong>队列选择机制，他有三种实现，使用 <strong>Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。<strong>RocketMQ</strong>的topic内的队列机制,可以保证存储满足<strong>FIFO</strong>（First Input First Output 简单说就是指先进先出）,剩下的只需要消费者顺序消费即可。至于怎么保证消费者顺序消费，使用同步发送，只有前面的消费发送成功，再发送后面的。</p>\n<h4 id=\"_4、如何解决分布式事务问题\"> 4、如何解决分布式事务问题？</h4>\n<p>概念：不同是服务要么同时成功或者失败。</p>\n<p>讲一个两阶段提交。</p>\n<p>// seata 分布式事务原理</p>\n<h4 id=\"_5、如何解决消息堆积问题\"> 5、如何解决消息堆积问题</h4>\n<p>产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>\n<p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题</p>\n<h4 id=\"_6、rocketmq-组成\"> 6、RocketMQ 组成</h4>\n<img src=\"images/16ef38687488a5a4.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n<ul>\n<li><code>Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</li>\n</ul>\n<p>这里，我还得普及一下关于 <code>Broker</code> 、<code>Topic</code> 和 队列的关系。上面我讲解了 <code>Topic</code> 和队列的关系——一个 <code>Topic</code> 中存在多个队列，那么这个 <code>Topic</code> 和队列存放在哪呢？</p>\n<p><strong>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。</p>\n<p>如果某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p>\n<ul>\n<li><code>NameServer</code>： 不知道你们有没有接触过 <code>ZooKeeper</code> 和 <code>Spring Cloud</code> 中的 <code>Eureka</code> ，它其实也是一个 <strong>注册中心</strong> ，主要提供两个功能：<strong>Broker管理</strong> 和 <strong>路由信息管理</strong> 。说白了就是 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</li>\n<li><code>Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</li>\n<li><code>Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</li>\n</ul>\n<h4 id=\"_7、rocketmq-的刷盘机制-这部分不是很理解-下次重点看这里。\"> 7、RocketMQ 的刷盘机制 ？？ 这部分不是很理解，下次重点看这里。</h4>\n<h5 id=\"同步刷盘和异步刷盘\"> 同步刷盘和异步刷盘</h5>\n<img src=\"images/16ef387fba311cda.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n<p>如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code>ACK</code> ，同步刷盘对 <code>MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>\n<p>而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>\n<p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h5 id=\"同步复制和异步复制\"> 同步复制和异步复制</h5>\n<p>上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>\n<ul>\n<li>同步复制： 也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从节点上时才返回写入成功</strong> 。</li>\n<li>异步复制： <strong>消息写入主节点之后就直接返回写入成功</strong> 。</li>\n</ul>\n<h4 id=\"_8、存储机制\"> 8、存储机制</h4>\n<p>三大角色——<code>CommitLog</code> 、<code>ConsumeQueue</code> 和 <code>IndexFile</code></p>\n<ul>\n<li><code>CommitLog</code>： <strong>消息主体以及元数据的存储主体</strong>，存储 <code>Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong>顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>\n<li><code>ConsumeQueue</code>： 消息消费队列，<strong>引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code>RocketMQ</code> 是基于主题 <code>Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code>commitlog</code> 文件中根据 <code>Topic</code> 检索消息是非常低效的。<code>Consumer</code> 即可根据 <code>ConsumeQueue</code> 来查找待消费的消息。其中，<code>ConsumeQueue</code>（逻辑消费队列）<strong>作为消费消息的索引</strong>，保存了指定 <code>Topic</code> 下的队列消息在 <code>CommitLog</code> 中的<strong>起始物理偏移量 <code>offset</code> *<em>，消息大小 <code>size</code> 和消息 <code>Tag</code> 的 <code>HashCode</code> 值。*</em><code>consumequeue</code> 文件可以看成是基于 <code>topic</code> 的 <code>commitlog</code> 索引文件</strong>，故 <code>consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code>consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code>commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code>hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code>ConsumeQueue</code>文件大小约5.72M；</li>\n<li><code>IndexFile</code>： <code>IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。、</li>\n</ul>\n<p><img src=\"./images/16ef388763c25c62.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 <strong>把 <code>ConsumerQueue</code> 理解为 <code>Queue</code></strong>。</p>\n<p>在图中最左边说明了红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code> 、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中管你是哪门子消息，他直接 <strong>全部顺序存储到了 CommitLog</strong>。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>\n<h4 id=\"stream-mq\"> Stream-MQ</h4>\n<p>1：配置文件通道命名和@input output一致，否则默认用注解的名字作为交换机名称。\n注意：输入通道和输出通道必须是同一个交换机才可通信</p>\n<p>2：分组。每个消费者实例都会产生一个队列（几个消费者实例就有几个队列），当生产者发出某条消息，多个消费者都会收到，会出现重复消费问题。</p>\n<p>分组可解决重复消费和持久化问题。一般用服务名称分组。\nExl：排他队列。跟随应用的启动停止而产生或消失。但是配置了group下次产生的时候还会收到之前未消费的消息。</p>\n<p>3：分区。通过消费组的设置，虽然能保证同一消息只被一个消费者进行接收和处理，但是对于特殊业务情况，除了要保证单一实例消费之外，还希望那些具备相同特征的消息都能被同一个实例消费。有playload和header两种区分表达式</p>\n<p>4：每个virtualhost 之间是隔离的，exchang不能互通。譬如生产环境和开发环境的，如果virtualhost相同，则两个环境都会收到消息</p>\n<p>坑：\n1、如果只做生产者就不要指定 log input ，因为指定了这个，应用就会认为这个生产者服务也会消费消息，即没有@StreamListener。</p>\n<p>2、注意消费者的配置和生产者的配置，是在各自的配置文件。但是exchang必须相同，不然不同的交换机无法通信。</p>\n<p>3、队列下面会有多个消费者，多个实例分组以后，就会使用同一个队列（不分组就每个实例作为一个消费者产生一个队列，随服务关闭队列消失），但是如果想要这个队列中一类数据给同一个实例消费者，就需要分区。\n注意：分组之后消费者订阅过的都会收到消息</p>\n<p>4、一个消费者在一个地方接受不同的生产者，可以enablebing 多个配置的通道</p>\n<p>记录：\n1、\n输入流必须关闭流，否则数据还在内存，无法操作。譬如删除等。</p>\n",
      "date_modified": "2022-04-29T06:23:43.021Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "1、OSI 与 TCP/IP 各层的结构与功能,都有哪些协议?为什么网络要分层？",
      "url": "https://fmiles.cn/interview/%E7%BD%91%E7%BB%9C/",
      "id": "https://fmiles.cn/interview/%E7%BD%91%E7%BB%9C/",
      "content_html": "<h5 id=\"_1、osi-与-tcp-ip-各层的结构与功能-都有哪些协议-为什么网络要分层\"> 1、OSI 与 TCP/IP 各层的结构与功能,都有哪些协议?为什么网络要分层？</h5>\n<p>OSI 七层：应用层，表示层，会话层，运输层，网络层，数据链路层，物理层。</p>\n<h5 id=\"_2、tcp-和udp-区别\"> 2、TCP 和UDP 区别？</h5>\n<p>TCP 提供面向连接的服务，是可靠传输，传输形式是字节流。</p>\n<p>UDP传输数据不需连接，远地收到UDP报文后，不需要给出任何确认，是不可靠传输。比如：qq，直播等等。</p>\n<h5 id=\"_3、三次握手和四次挥手\"> 3、三次握手和四次挥手？</h5>\n<p>三次握手：</p>\n<blockquote>\n<p>1、SYN = 1，ACK = 0，seq = x</p>\n<p>2、SYN = 1，ACK =1，seq = y，ack = x + 1</p>\n<p>3、ACK = 1，seq = x+ 1，ack = y + 1</p>\n</blockquote>\n<p>，SYN/ACK，ACK。</p>\n<p>四次挥手：SYN，ACK。</p>\n<blockquote>\n<p>FIN,ack,FIN，ack</p>\n</blockquote>\n",
      "date_modified": "2022-04-29T06:23:43.021Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "NIO",
      "url": "https://fmiles.cn/java/basics/IO%E6%A8%A1%E5%9E%8B/",
      "id": "https://fmiles.cn/java/basics/IO%E6%A8%A1%E5%9E%8B/",
      "content_html": "<h1 id=\"bio-nio-aio-总结\"> BIO,NIO,AIO 总结</h1>\n<h2 id=\"io-原理\"> IO 原理</h2>\n<p>无论是 Socket 的读写还是文件的读写，在 Java 层面的应用开发或者是 linux 系统底层开发，都属于输入 input 和输出 output 的处理，简称为 IO 读写。在原理上和处理流程上，都是一致的。区别在于参数的不同。</p>\n<p>用户程序进行 IO 的读写，基本上会用到 read&amp;write 两大系统调用。可能不同操作系统，名称不完全一样，但是功能是一样的。</p>\n<p>先强调一个基础知识：read 系统调用，并不是把数据直接从物理设备，读数据到内存；write 系统调用，也不是直接把数据，写入到物理设备。</p>\n<p>read 系统调用，是把数据从内核缓冲区复制到进程缓冲区；而 write 系统调用，是把数据从进程缓冲区复制到内核缓冲区。这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统 kernel 内核完成的。</p>\n<h3 id=\"java-io读写的底层流程\"> java IO读写的底层流程</h3>\n<p><img src=\"./images/20190105163657587.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>首先看看一个典型Java 服务端处理网络请求的典型过程：</p>\n<p>（1）客户端请求</p>\n<p>Linux 通过网卡，读取客户断的请求数据，将数据读取到内核缓冲区。</p>\n<p>（2）获取请求数据</p>\n<p>服务器从内核缓冲区读取数据到 Java 进程缓冲区。</p>\n<p>（3）服务器端业务处理</p>\n<p>Java 服务端在自己的用户空间中，处理客户端的请求。</p>\n<p>（4）服务器端返回数据</p>\n<p>Java服务端已构建好的响应，从用户缓冲区写入内核缓冲区。</p>\n<p>（5）发送给客户端</p>\n<p>Linux内核通过网络 I/O ，将内核缓冲区中的数据，写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。</p>\n<h4 id=\"有哪些常见的-io-模型\"> 有哪些常见的 IO 模型?</h4>\n<p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>异步 I/O</strong>。</p>\n<h4 id=\"同步异步的区别\"> 同步异步的区别？</h4>\n<blockquote>\n<p>当你同步执行某项任务时，你需要等待其完成才能继续执行其他任务。当你异步执行某些操作时，你可以在完成另一个任务之前继续进行。</p>\n</blockquote>\n<ul>\n<li><strong>同步</strong> ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在<code>A-&gt;B</code>事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</li>\n<li><strong>异步</strong>： 两个异步的任务是完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用中一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</li>\n</ul>\n<p><strong>阻塞和非阻塞</strong></p>\n<ul>\n<li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>\n<li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>\n</ul>\n<p><strong>如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？</strong></p>\n<p>同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。</p>\n<h2 id=\"_1-bio-blocking-i-o\"> 1. BIO (Blocking I/O)</h2>\n<p>在linux中的Java进程中，默认情况下所有的 socket 都是 blocking IO。在阻塞式 I/O 模型中，应用程序在从 IO 系统调用开始，一直到到系统调用返回，这段时间是阻塞的。返回成功后，应用进程开始处理用户空间的缓存数据。</p>\n<p><img src=\"./images/20190105163801795.jpg\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>举个栗子，发起一个blocking socket的read读操作系统调用，流程大概是这样：</p>\n<p>（1）当用户线程调用了read系统调用，内核（kernel）就开始了IO的第一个阶段：准备数据。很多时候，数据在一开始还没有到达（比如，还没有收到一个完整的Socket数据包），这个时候kernel就要等待足够的数据到来。</p>\n<p>（2）当kernel一直等到数据准备好了，它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p>\n<p>（3）从开始IO读的read系统调用开始，用户线程就进入阻塞状态。一直到kernel返回结果后，用户线程才解除block的状态，重新运行起来。</p>\n<p>所以，blocking IO的特点就是在内核进行IO执行的两个阶段，用户线程都被block了。</p>\n<h5 id=\"bio的优点\"> BIO的优点：</h5>\n<p>程序简单，在阻塞等待数据期间，用户线程挂起。用户线程基本不会占用 CPU 资源。</p>\n<h5 id=\"bio的缺点\"> BIO的缺点：</h5>\n<p>一般情况下，会为每个连接配套一条独立的线程，或者说一条线程维护一个连接成功的IO流的读写。在并发量小的情况下，这个没有什么问题。但是，当在高并发的场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上，BIO模型在高并发场景下是不可用的。</p>\n<h2 id=\"_2-nio-none-blocking-io\"> 2. NIO (<strong>None Blocking IO</strong>)</h2>\n<p><em>强调一下，这里所说的NIO（同步非阻塞IO）模型，并非Java的NIO（New IO）库。</em></p>\n<p>在 linux 系统下，可以通过设置 socket 使其变为 non-blocking。NIO 模型中应用程序在一旦开始 IO 系统调用，会出现以下两种情况：</p>\n<p>（1）在内核缓冲区没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。</p>\n<p>（2）在内核缓冲区有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。</p>\n<p><img src=\"./images/20190105163821398.jpg\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>举个栗子。发起一个non-blocking socket的read读操作系统调用，流程是这个样子：</p>\n<p>（1）在内核数据没有准备好的阶段，用户线程发起IO请求时，立即返回。用户线程需要不断地发起IO系统调用。</p>\n<p>（2）内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p>\n<p>（3）用户线程才解除block的状态，重新运行起来。经过多次的尝试，用户线程终于真正读取到数据，继续执行。</p>\n<h5 id=\"nio的特点\"> NIO的特点：</h5>\n<p>应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止。</p>\n<p><strong>NIO的优点</strong>：每次发起的 IO 系统调用，在内核的等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p>\n<p><strong>NIO的缺点</strong>：需要不断的重复发起IO系统调用，这种不断的轮询，将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低。</p>\n<p>总之，NIO模型在高并发场景下，也是不可用的。一般 Web 服务器不使用这种 IO 模型。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。java的实际开发中，也不会涉及这种IO模型。</p>\n<h5 id=\"再次说明-java-nio-new-io-不是io模型中的nio模型-而是另外的一种模型-叫做io多路复用模型-io-multiplexing-。\"> 再次说明，Java NIO（New IO） 不是IO模型中的NIO模型，而是另外的一种模型，叫做IO多路复用模型（ IO multiplexing ）。</h5>\n<h2 id=\"_3-io多路复用模型-i-o-multiplexing\"> <strong>3. IO多路复用模型(I/O multiplexing）</strong></h2>\n<p>如何避免同步非阻塞NIO模型中轮询等待的问题呢？这就是IO多路复用模型。</p>\n<p>IO 多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核kernel 能够通知程序进行相应的 IO 系统调用。</p>\n<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持，具有良好跨平台特性。epoll 是在linux 2.6内核中提出的，是 select 系统调用的linux增强版本。</p>\n<p>IO 多路复用模型的基本原理就是 select/epoll 系统调用，单个线程不断的轮询 select/epoll 系统调用所负责的成百上千的 socket 连接，当某个或者某些 socket 网络连接有数据到达了，就返回这些可以读写的连接。因此，好处也就显而易见了——通过一次 select/epoll 系统调用，就查询到到可以读写的一个甚至是成百上千的网络连接。</p>\n<p><img src=\"./images/20190105163846560.jpg\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>在这种模式中，首先不是进行 read 系统调动，而是进行 select/epoll 系统调用。当然，这里有一个前提，需要将目标网络连接，提前注册到select/epoll 的可查询 socket 列表中。然后，才可以开启整个的IO多路复用模型的读流程。</p>\n<p>举个栗子。发起一个多路复用 IO 的 read 读操作系统调用，流程是这个样子：</p>\n<p>（1）进行select/epoll系统调用，查询可以读的连接。kernel会查询所有select的可查询socket列表，当任何一个socket中的数据准备好了，select就会返回。</p>\n<p>当用户进程调用了select，那么整个线程会被block（阻塞掉）。</p>\n<p>（2）用户线程获得了目标连接后，发起read系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p>\n<p>（3）用户线程才解除block的状态，用户线程终于真正读取到数据，继续执行。</p>\n<h5 id=\"多路复用io的特点\"> 多路复用IO的特点：</h5>\n<p>IO多路复用模型，建立在操作系统kernel内核能够提供的多路分离系统调用select/epoll基础之上的。多路复用IO需要用到两个系统调用（system call）， 一个select/epoll查询调用，一个是IO的读取调用。</p>\n<p>和NIO模型相似，多路复用IO需要轮询。负责select/epoll查询调用的线程，需要不断的进行select/epoll轮询，查找出可以进行IO操作的连接。</p>\n<p>另外，多路复用IO模型与前面的NIO模型，是有关系的。对于每一个可以查询的socket，一般都设置成为non-blocking模型。只是这一点，对于用户程序是透明的（不感知）。</p>\n<h5 id=\"多路复用io的优点\"> 多路复用IO的优点：</h5>\n<p>用select/epoll的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I/O多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。</p>\n<p>Java的NIO（new IO）技术，使用的就是IO多路复用模型。在linux系统上，使用的是epoll系统调用。</p>\n<h5 id=\"多路复用io的缺点\"> 多路复用IO的缺点：</h5>\n<p>本质上，select/epoll系统调用，属于同步IO，也是阻塞IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。</p>\n<p>如何充分的解除线程的阻塞呢？那就是异步IO模型。</p>\n<h2 id=\"异步io模型-asynchronous-io\"> <strong>异步IO模型（asynchronous IO）</strong></h2>\n<p>如何进一步提升效率，解除最后一点阻塞呢？这就是异步 IO 模型，全称 asynchronous I/O ，简称为 AIO。</p>\n<p>AIO 的基本流程是：用户线程通过系统调用，告知 kernel 内核启动某个 IO 操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p>\n<p>kernel的数据准备是将数据从网络物理设备（网卡）读取到内核缓冲区；kernel的数据复制是将数据从内核缓冲区拷贝到用户程序空间的缓冲区。</p>\n<p><img src=\"./images/20190105163914730.jpg\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>（1）当用户线程调用了read系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。</p>\n<p>（2）内核（kernel）就开始了IO的第一个阶段：准备数据。当kernel一直等到数据准备好了，它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存）。</p>\n<p>（3）kernel会给用户线程发送一个信号（signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>\n<p>（4）用户线程读取用户缓冲区的数据，完成后续的业务操作。</p>\n<h5 id=\"异步io模型的特点\"> 异步IO模型的特点：</h5>\n<p>在内核kernel的等待数据和复制数据的两个阶段，用户线程都不是block(阻塞)的。用户线程需要接受kernel的IO操作完成的事件，或者说注册IO操作完成的回调函数，到操作系统的内核。所以说，异步IO有的时候，也叫做信号驱动 IO 。</p>\n<h5 id=\"异步io模型缺点\"> 异步IO模型缺点：</h5>\n<p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p>\n<p>目前来说， Windows 系统下通过 IOCP 实现了真正的异步 I/O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p>\n<p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在 Linux 下，实现高并发网络编程时都是以 IO 复用模型模式为主。</p>\n<h3 id=\"参考\"> 参考：</h3>\n<p>https://www.cnblogs.com/crazymakercircle/p/10225159.html</p>\n",
      "date_modified": "2022-04-29T06:23:43.022Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "动态代理底层原理",
      "url": "https://fmiles.cn/java/basics/Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "id": "https://fmiles.cn/java/basics/Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>java里的class文件加载分为两种情况，一种就是类型是编译器已知的，这种文件的.class文件在编译的时候，编译器会把.class文件打开检查，但是注意不是加载哦，第二种就是我们可能是从别的地方获取到了一个引用，然后动态的把这个未知类型的引用的对象的.class文件加载进jvm虚拟机里。</p>\n<p>那么我们称前者为RTTI,即Run- Time Type Identification 运行时类型识别，有的人把RTTI翻译成 Run - Time Type Information ，我个人认为是不对的，因为我觉得它概括的不够全面，所以我建议大家把I 翻译成Identification更容易理解。称后者为“反射”。</p>\n<p>再简单说如果该类在编译前就已知，也就是该类在classPath路径下，这就是RTTI。如果该类编译器未知，也就是在程序运行时才知道的，这就是反射</p>\n<h2 id=\"原理\"> 原理：</h2>\n<p>被代理对象：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>EchoService</span> <span>{</span>\n     <span>String</span>  <span>echo</span><span>(</span><span>String</span> str<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>被代理对象实例：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DefaultEchoService</span> <span>implements</span> <span>EchoService</span><span>{</span>\n    <span>@Override</span>\n <span>public</span> <span>String</span> <span>echo</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>InvocationHandler 实现：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CostInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n\t<span>private</span> <span>Object</span> target<span>;</span>\n    <span>public</span> <span>CostInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>\n    <span>}</span>\n    \n\t<span>@Override</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>\n        <span>long</span> cost <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> startTime<span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"cost \"</span> <span>+</span> cost<span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>使用：</p>\n<div><pre><code><span>public</span> <span>class</span> test <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ClassLoader</span> classLoader <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>;</span>\n        <span>Object</span> proxy <span>=</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>classLoader<span>,</span>\n                <span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span><span>EchoService</span><span>.</span><span>class</span><span>}</span><span>,</span>\n                <span>new</span> <span>CostInvocationHandler</span><span>(</span><span>new</span> <span>DefaultEchoService</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>EchoService</span> echoService <span>=</span> <span>(</span><span>EchoService</span><span>)</span> proxy<span>;</span>\n         <span>// cost 0</span>\n \t\t <span>// hello world</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>echoService<span>.</span><span>echo</span><span>(</span><span>\"hello world\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><br>\n</br>\n<h3 id=\"invocationhandler\"> InvocationHandler</h3>\n<p>这个类必须有一个实现类，如上面的<code>CostInvocationHandler</code>。这个类里面只包含有一个 invoke 方法。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>\n\t\t<span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>文档注释中，每一个代理对象必须有一个与之关联的<code>invocation handler</code>，当在代理实例上调用方法时，方法调用将被编码并发送到其调用实例的<code>invoke</code>方法。</p>\n<p>拿上面例子解释：在执行 echo 方法的时候，就会调用 <code>CostInvocationHandler</code>中的<code>invke</code>方法,从而达到代理的目的。</p>\n<h3 id=\"proxy-newproxyinstance\"> Proxy.newProxyInstance</h3>\n<p>这个方法中，最重要的就是生成代理对象。因为是动态生成的，所以需要利用<a href=\"https://editor.csdn.net/md/?articleId=121402490\" target=\"_blank\" rel=\"noopener noreferrer\">HSDB</a>去探究生成的字节码文件。下面就反编译后的文件：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> $<span>Proxy0</span> <span>extends</span> <span>Proxy</span> <span>implements</span> <span>EchoService</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Method</span> m1<span>;</span>\n  \t<span>private</span> <span>static</span> <span>Method</span> m3<span>;</span>\n    <span>private</span> <span>static</span> <span>Method</span> m2<span>;</span>\n    <span>private</span> <span>static</span> <span>Method</span> m0<span>;</span>\n    \n\t<span>public</span> $<span>Proxy0</span><span>(</span><span>InvocationHandler</span> var1<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>var1<span>)</span><span>;</span>\n    <span>}</span>\n    \n\t<span>static</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            m1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"equals\"</span><span>,</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>)</span><span>;</span>\n            m3 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"com.aop.EchoService\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"echo\"</span><span>,</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.String\"</span><span>)</span><span>)</span><span>;</span>\n            m2 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"toString\"</span><span>)</span><span>;</span>\n  \t\t\tm0 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"hashCode\"</span><span>)</span><span>;</span>\n  \t\t <span>}</span> <span>catch</span> <span>(</span><span>NoSuchMethodException</span> var2<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NoSuchMethodError</span><span>(</span>var2<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n         <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> var3<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NoClassDefFoundError</span><span>(</span>var3<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n         <span>}</span>\n     <span>}</span>\n     \n\t <span>public</span> <span>final</span> <span>String</span> <span>echo</span><span>(</span><span>String</span> var1<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> <span>(</span><span>String</span><span>)</span><span>super</span><span>.</span>h<span>.</span><span>invoke</span><span>(</span><span>this</span><span>,</span> m3<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span>var1<span>}</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> <span>|</span> <span>Error</span> var3<span>)</span> <span>{</span>\n            <span>throw</span> var3<span>;</span>\n        <span>}</span>  <span>catch</span> <span>(</span><span>Throwable</span> var4<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>UndeclaredThrowableException</span><span>(</span>var4<span>)</span><span>;</span>\n        <span>}</span>\n   <span>}</span>\n<span>}</span>\n\n <span>//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>1、在 Proxy.newInstance 动态生成了 $Proxy0，并且这时候传给了构造函数 <code>CostInvocationHandler</code>；\n2、<code>$Proxy0</code>的构造函数中，调用了 <code>super()</code>；这时候把 <code>CostInvocationHandler</code>传给父类，并且赋值给 <code>h</code>;</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Proxy</span><span>{</span>\n \t<span>protected</span> <span>Proxy</span><span>(</span><span>InvocationHandler</span> h<span>)</span> <span>{</span>\n        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>h<span>)</span><span>;</span>\n        <span>this</span><span>.</span>h <span>=</span> h<span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>3、调用 echo方法的时候，就会调用<code>super.h.invoke()</code>，即Proxy 类的h，也就是调用<code>CostInvocationHandler</code>的<code>invke</code>方法。</p>\n<p>这里invoke 方法又是 Method 的invke。<a href=\"https://blog.csdn.net/weixin_43652284/article/details/121224639\" target=\"_blank\" rel=\"noopener noreferrer\">反射的底层原理</a></p>\n<h2 id=\"总结\"> 总结</h2>\n<p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。</p>\n<p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。</p>\n<p>参考：\n<a href=\"https://www.cnblogs.com/gonjan-blog/p/6685611.html\" target=\"_blank\" rel=\"noopener noreferrer\">java动态代理实现与原理详细分析</a></p>\n",
      "date_modified": "2022-04-29T06:23:43.023Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "NIO",
      "url": "https://fmiles.cn/java/basics/NIO%E5%BA%93/",
      "id": "https://fmiles.cn/java/basics/NIO%E5%BA%93/",
      "content_html": "<h2 id=\"nio-new-bloking-io-简介\"> NIO（New Bloking IO） 简介</h2>\n<p>在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。</p>\n<h2 id=\"nio-核心组件简单介绍\"> NIO 核心组件简单介绍</h2>\n<p>NIO 包含下面几个核心的组件：</p>\n<ul>\n<li>Channel(通道)</li>\n<li>Buffer(缓冲区)</li>\n<li>Selector(选择器)</li>\n</ul>\n<p>整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。</p>\n<h3 id=\"buffer-缓冲区\"> Buffer(缓冲区)</h3>\n<p>Buffer 是一个对象，它包含一些要写入或者要读出的数据。在 NIO 类库中加入 Buffer 对象，NIO 将流却是直接读到 Buffer 中进行操作。</p>\n<p>在 NIO 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问 NIO 中的数据，都是通过缓冲区进行操作。</p>\n<p>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p>\n<h3 id=\"channel-通道\"> Channel (通道)</h3>\n<p>NIO 通过Channel（通道） 进行读写。</p>\n<p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p>\n<h3 id=\"selector-选择器\"> Selector (选择器)</h3>\n<p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p>\n<p><img src=\"./images/Slector.png\" alt=\"一个单线程中Selector维护3个Channel的示意图\" loading=\"lazy\"></p>\n<h2 id=\"nio-读数据和写数据方式\"> NIO 读数据和写数据方式</h2>\n<p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p>\n<ul>\n<li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li>\n<li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li>\n</ul>\n<p>数据读取和写入操作图示：</p>\n<p><img src=\"./images/NIO读写数据的方式.png\" alt=\"NIO读写数据的方式\" loading=\"lazy\"></p>\n<h4 id=\"代码示例\"> 代码示例</h4>\n<p>代码示例出自闪电侠的博客，原地址如下：</p>\n<p>客户端 IOClient.java 的代码不变，我们对服务端使用 NIO 进行改造。以下代码较多而且逻辑比较复杂，大家看看就好。</p>\n<div><pre><code><span>/**\n * \n * @author 闪电侠\n * @date 2019年2月21日\n * @Description: NIO 改造后的服务端\n */</span>\n<span>public</span> <span>class</span> <span>NIOServer</span> <span>{</span>\n  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n    <span>// 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，</span>\n    <span>// 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等</span>\n    <span>Selector</span> serverSelector <span>=</span> <span>Selector</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n    <span>// 2. clientSelector负责轮询连接是否有数据可读</span>\n    <span>Selector</span> clientSelector <span>=</span> <span>Selector</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n\n    <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n      <span>try</span> <span>{</span>\n        <span>// 对应IO编程中服务端启动</span>\n        <span>ServerSocketChannel</span> listenerChannel <span>=</span> <span>ServerSocketChannel</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>\n        listenerChannel<span>.</span><span>socket</span><span>(</span><span>)</span><span>.</span><span>bind</span><span>(</span><span>new</span> <span>InetSocketAddress</span><span>(</span><span>3333</span><span>)</span><span>)</span><span>;</span>\n        listenerChannel<span>.</span><span>configureBlocking</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        listenerChannel<span>.</span><span>register</span><span>(</span>serverSelector<span>,</span> <span>SelectionKey</span><span>.</span>OP_ACCEPT<span>)</span><span>;</span>\n\n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n          <span>// 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms</span>\n          <span>if</span> <span>(</span>serverSelector<span>.</span><span>select</span><span>(</span><span>1</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>Set</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> set <span>=</span> serverSelector<span>.</span><span>selectedKeys</span><span>(</span><span>)</span><span>;</span>\n            <span>Iterator</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keyIterator <span>=</span> set<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n\n            <span>while</span> <span>(</span>keyIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n              <span>SelectionKey</span> key <span>=</span> keyIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n\n              <span>if</span> <span>(</span>key<span>.</span><span>isAcceptable</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                  <span>// (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span>\n                  <span>SocketChannel</span> clientChannel <span>=</span> <span>(</span><span>(</span><span>ServerSocketChannel</span><span>)</span> key<span>.</span><span>channel</span><span>(</span><span>)</span><span>)</span><span>.</span><span>accept</span><span>(</span><span>)</span><span>;</span>\n                  clientChannel<span>.</span><span>configureBlocking</span><span>(</span><span>false</span><span>)</span><span>;</span>\n                  clientChannel<span>.</span><span>register</span><span>(</span>clientSelector<span>,</span> <span>SelectionKey</span><span>.</span>OP_READ<span>)</span><span>;</span>\n                <span>}</span> <span>finally</span> <span>{</span>\n                  keyIterator<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n              <span>}</span>\n\n            <span>}</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> ignored<span>)</span> <span>{</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n      <span>try</span> <span>{</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n          <span>// (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms</span>\n          <span>if</span> <span>(</span>clientSelector<span>.</span><span>select</span><span>(</span><span>1</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>Set</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> set <span>=</span> clientSelector<span>.</span><span>selectedKeys</span><span>(</span><span>)</span><span>;</span>\n            <span>Iterator</span><span><span>&lt;</span><span>SelectionKey</span><span>></span></span> keyIterator <span>=</span> set<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n\n            <span>while</span> <span>(</span>keyIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n              <span>SelectionKey</span> key <span>=</span> keyIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n\n              <span>if</span> <span>(</span>key<span>.</span><span>isReadable</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                  <span>SocketChannel</span> clientChannel <span>=</span> <span>(</span><span>SocketChannel</span><span>)</span> key<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n                  <span>ByteBuffer</span> byteBuffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocate</span><span>(</span><span>1024</span><span>)</span><span>;</span>\n                  <span>// (3) 面向 Buffer</span>\n                  clientChannel<span>.</span><span>read</span><span>(</span>byteBuffer<span>)</span><span>;</span>\n                  byteBuffer<span>.</span><span>flip</span><span>(</span><span>)</span><span>;</span>\n                  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>\n                      <span>Charset</span><span>.</span><span>defaultCharset</span><span>(</span><span>)</span><span>.</span><span>newDecoder</span><span>(</span><span>)</span><span>.</span><span>decode</span><span>(</span>byteBuffer<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>}</span> <span>finally</span> <span>{</span>\n                  keyIterator<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n                  key<span>.</span><span>interestOps</span><span>(</span><span>SelectionKey</span><span>.</span>OP_READ<span>)</span><span>;</span>\n                <span>}</span>\n              <span>}</span>\n\n            <span>}</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> ignored<span>)</span> <span>{</span>\n      <span>}</span>\n    <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br></div></div><p>为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：</p>\n<ul>\n<li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</li>\n<li>项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug</li>\n</ul>\n<p>Netty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。</p>\n",
      "date_modified": "2022-04-29T06:23:43.025Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "finally执行时机",
      "url": "https://fmiles.cn/java/basics/throwable/finally%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/",
      "id": "https://fmiles.cn/java/basics/throwable/finally%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/",
      "content_html": "<h3 id=\"java-finally语句到底是在return之前还是之后执行\"> Java finally语句到底是在return之前还是之后执行？</h3>\n<p>​\t\tJava中异常捕获机制try...catch...finally块中的finally语句是不是一定会被执行？很多人都说不是，当然他们的回答是正确的，经过我试验，<strong>至少有两种情况下finally语句是不会被执行的：</strong></p>\n<blockquote>\n<p><strong>（1）try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。</strong></p>\n<p><strong>（2）在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到</strong></p>\n</blockquote>\n<h5 id=\"finally-会执行的情况\"> finally 会执行的情况：</h5>\n<blockquote>\n<p>当try之中出现异常时，会执行catch语句，然后是finally；当try中有return时，会将结果返回给finally，然后看finally中是否还有返回语句，如果有则将finally中的结果返回，finally中没有返回语句则将try中的返回语句返回。</p>\n</blockquote>\n<p>Finally语句的执行与return的关系：</p>\n<blockquote>\n<p>一、 finally语句是在try的return语句执行之后，return返回之前执行。</p>\n</blockquote>\n<div><pre><code><span>package</span> <span>com<span>.</span>it<span>.</span>dao</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>Test</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>test1</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>test1</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> b <span>=</span> <span>20</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"try block\"</span><span>)</span><span>;</span>\n            <span>return</span> b <span>+=</span> <span>80</span><span>;</span>\n        <span>}</span>\n        <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"catch block\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>finally</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"finally block\"</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>b <span>></span> <span>25</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b>25, b = \"</span> <span>+</span> b<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> b<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>结果：</p>\n<div><pre><code><span>try</span> block\n<span>finally</span> block\nb<span>></span><span>25</span><span>,</span> b <span>=</span> <span>100</span>\n<span>100</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>​\t\t结果说明return语句已经执行了再去执行finally语句，不过并没有直接返回，而是等finally语句执行完了再返回结果。</p>\n<p>如果觉得这个例子还不足以说明这个情况的话，下面再加个例子加强证明结论：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>FinallyTest1</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>test11</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>String</span> <span>test11</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"try block\"</span><span>)</span><span>;</span>\n           <span>return</span> <span>test12</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span> <span>finally</span> <span>{</span>\n           <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"finally block\"</span><span>)</span><span>;</span>\n       <span>}</span>\n  <span>}</span>\n\n  <span>public</span> <span>static</span> <span>String</span> <span>test12</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"return statement\"</span><span>)</span><span>;</span>\n\n       <span>return</span> <span>\"after return\"</span><span>;</span>\n   <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>结果：</p>\n<div><pre><code><span>try</span> block\n<span>return</span> statement\n<span>finally</span> block\nafter <span>return</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>二、<strong>finally块中的return语句会覆盖try块中的return返回。</strong></p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>FinallyTest2</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>test2</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>int</span> <span>test2</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> b <span>=</span> <span>20</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"try block\"</span><span>)</span><span>;</span>\n            <span>return</span> b <span>+=</span> <span>80</span><span>;</span>\n            \n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"catch block\"</span><span>)</span><span>;</span>\n            \n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"finally block\"</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>b <span>></span> <span>25</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b>25, b = \"</span> <span>+</span> b<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>return</span> <span>200</span><span>;</span>\n        <span>}</span>\n\n        <span>// return b;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>结果：</p>\n<div><pre><code><span>try</span> block\n<span>finally</span> block\nb<span>></span><span>25</span><span>,</span> b <span>=</span> <span>100</span>\n<span>200</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>​\t\t这说明finally里的return直接返回了，就不管try中是否还有返回语句，这里还有个小细节需要注意，finally里加上return过后，finally外面的return b就变成不可到达语句了，也就是永远不能被执行到，所以需要注释掉否则编译器报错。</p>\n<blockquote>\n<h5 id=\"三、-如果finally语句中没有return语句覆盖返回值-那么原来的返回值可能因为finally里的修改而改变也可能不变。\"> <strong>三、 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。</strong></h5>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>FinallyTest3</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>test3</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>int</span> <span>test3</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> b <span>=</span> <span>20</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"try block\"</span><span>)</span><span>;</span>\n            <span>return</span> b <span>+=</span> <span>80</span><span>;</span>\n            \n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"catch block\"</span><span>)</span><span>;</span>\n            \n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"finally block\"</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>b <span>></span> <span>25</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b>25, b = \"</span> <span>+</span> b<span>)</span><span>;</span>\n            <span>}</span>\n\n            b <span>=</span> <span>150</span><span>;</span>    <span>//这行代码未执行</span>\n        <span>}</span>\n\n        <span>return</span> <span>2000</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>结果：</p>\n<div><pre><code><span>try</span> block\n<span>finally</span> block\nb<span>></span><span>25</span><span>,</span> b <span>=</span> <span>100</span>\n<span>100</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>*</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>FinallyTest6</span>\n<span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getMap</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"KEY\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n     \n    <span>public</span> <span>static</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> <span>getMap</span><span>(</span><span>)</span> <span>{</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"INIT\"</span><span>)</span><span>;</span>\n         \n        <span>try</span> <span>{</span>\n            map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"TRY\"</span><span>)</span><span>;</span>\n            <span>return</span> map<span>;</span>\n        <span>}</span>\n        <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"CATCH\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>finally</span> <span>{</span>\n            map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"FINALLY\"</span><span>)</span><span>;</span>\n            map <span>=</span> <span>null</span><span>;</span>\n        <span>}</span>\n         \n        <span>return</span> map<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>结果：</p>\n<div><pre><code>FINALLY\n</code></pre>\n<div><span>1</span><br></div></div><p>​\t\t为什么测试用例1中finally里的b = 150并没有起到作用而测试用例2中finally的map.put(&quot;KEY&quot;, &quot;FINALLY&quot;)起了作用而map = null;却没起作用呢？</p>\n<p>首先明确：看类的class字节码文件就知道了。 return的时候是<code>复制</code>了一个变量然后返回，所以之后finally操作的变量如果是基本类型的话不会影响返回值。 但是如果返回值是引用类型的话，因为指向同一个对象所以还是有影响的。</p>\n<p>在map = null 的代码块中，\n上面的 return 已经确定的要返回对象的地址(第一个地址)\n后面将map 置为null，修改了 map 的地址（第二个地址），\n但是并不能影响 要 return  的那个地址（返回的还是第一个地址），\n返回的还是第一个map引用 指向的那个 hashMap 对象。\n所以打印出来的是 finally.</p>\n<h5 id=\"复制的含义\"> 复制的含义：</h5>\n<p>在return 操作之前，暂且认定局部变量表中有一个reference0指向堆内存中map对象。                     return map的时候：首先会将reference0指向的map对象压栈，然后弹出栈到局部变量表中reference1中，即现在两个引用指向堆中的map对象，而 return 会返回是经过操作数栈得到的 referebce1， 也就是所谓的&quot;复制&quot;。</p>\n<p>接着finally代码块会继续执行代码，但是这时候的操作都是针对reference0引用，（注意map.put()操作不属于本方法，它应该是在map 的put方法栈帧中去改变），对于map=null，它会把reference0的引用入栈，然后修改了它的地址，但是并不影响返回的 referebce1</p>\n<p>（这里注意了，所有的方法内部的操作，一定是经过操作数栈的，即使是返回一个值这么简单的操作，都会先从变量表拿出引用，经操作以后再返回）</p>\n<p>为了验证，这里对之前的代码做修改：</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>it<span>.</span>dao</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>Test</span>\n<span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getMap</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"KEY\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> <span>getMap</span><span>(</span><span>)</span> <span>{</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"INIT\"</span><span>)</span><span>;</span>\n\n        <span>try</span> <span>{</span>\n            map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"TRY\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"CATCH\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>finally</span> <span>{</span>\n            map<span>.</span><span>put</span><span>(</span><span>\"KEY\"</span><span>,</span> <span>\"FINALLY\"</span><span>)</span><span>;</span>\n            map <span>=</span> <span>null</span><span>;</span>\n        <span>}</span>\n        <span>return</span> map<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>结果：</p>\n<div><pre><code><span>Exception</span> in thread <span>\"main\"</span> <span><span>java<span>.</span>lang<span>.</span></span>NullPointerException</span>\n\tat <span><span>com<span>.</span>it<span>.</span>dao<span>.</span></span>Test</span><span>.</span><span>main</span><span>(</span><span>Test</span><span>.</span>java<span>:</span><span>9</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>原因就是它这里的map在最后给变为空，因此不管怎么做都是null。</p>\n<blockquote>\n<h5 id=\"四、-try块里的return语句在异常的情况下不会被执行-这样具体返回哪个看情况。\"> 四、 <strong>try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。</strong></h5>\n</blockquote>\n<div><pre><code><span>package</span> <span>com<span>.</span>it<span>.</span>dao</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>test4</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>int</span> <span>test4</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> b <span>=</span> <span>20</span><span>;</span>\n\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"try block\"</span><span>)</span><span>;</span>\n            b <span>=</span> b <span>/</span> <span>0</span><span>;</span>\n            <span>return</span> b <span>+=</span> <span>80</span><span>;</span>\n            \n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            b <span>+=</span> <span>15</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"catch block\"</span><span>)</span><span>;</span>\n            \n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"finally block\"</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>b <span>></span> <span>25</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b>25, b = \"</span> <span>+</span> b<span>)</span><span>;</span>\n            <span>}</span>\n            b <span>+=</span> <span>50</span><span>;</span>\n        <span>}</span>\n\n        <span>return</span> b<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>结果：</p>\n<div><pre><code><span>catch</span> block\n<span>finally</span> block\nb<span>></span><span>25</span><span>,</span> b <span>=</span> <span>35</span>\n<span>85</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<h5 id=\"五、-当发生异常后-catch中的return执行情况与未发生异常时try中return的执行情况完全一样。\"> 五、 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。</h5>\n</blockquote>\n",
      "date_modified": "2022-04-29T06:23:43.030Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "反射底层原理",
      "url": "https://fmiles.cn/java/basics/%E5%8F%8D%E5%B0%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "id": "https://fmiles.cn/java/basics/%E5%8F%8D%E5%B0%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<blockquote>\n<p>反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为 Java 的反射机制。</p>\n</blockquote>\n<h2 id=\"原理\"> 原理</h2>\n<p>通常情况下我们是这么使用反射的：</p>\n<div><pre><code><span>Method</span> method <span>=</span> XXX<span>.</span><span>class</span><span>.</span><span>getDeclaredMethod</span><span>(</span>xx<span>,</span>xx<span>)</span><span>;</span>\nmethod<span>.</span><span>invoke</span><span>(</span>target<span>,</span>params<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"method-获取\"> Method 获取</h3>\n<p>要调用首先要获取<code>Method</code>，而获取<code>Method</code>的逻辑是通过<code>Class</code>这个类来的，而关键的几个方法和属性如下：</p>\n<div><pre><code><span>class</span> <span>Class</span><span>{</span>\n\t<span>SoftReference</span><span><span>&lt;</span><span>ReflectionData</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> reflectionData<span>;</span>\n\t\t\n\t<span>public</span> <span>Method</span> <span>getDeclaredMethod</span><span>(</span><span>String</span> name<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>.</span><span>.</span><span>.</span> parameterTypes<span>)</span><span>;</span>\n\t<span>private</span> <span>static</span> <span>Method</span> <span>searchMethods</span><span>(</span><span>Method</span><span>[</span><span>]</span> methods<span>,</span><span>String</span> name<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> parameterTypes<span>)</span><span>;</span>   \n\t<span>private</span> <span>Method</span><span>[</span><span>]</span> <span>privateGetDeclaredMethods</span><span>(</span><span>boolean</span> publicOnly<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其中<code>privateGetDeclaredMethods</code>方法从缓存或JVM中获取该<code>Class</code>中申明的方法列表，<code>searchMethods</code>方法将从返回的方法列表里找到一个匹配名称和参数的方法对象。<code>privateGetDeclaredMethods</code>中获取方法列表主要就是靠<code>reflectionData</code>。</p>\n<h3 id=\"reflectiondata\"> reflectionData</h3>\n<p>这里主要存的是每次从jvm里获取到的一些类属性，比如方法，字段等。</p>\n<p><img src=\"./images/2265eefd7d6b489ba261bd0e309d32ae.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>这个属性主要是<code>SoftReference</code>的，也就是在某些内存比较苛刻的情况下是可能被回收的，不过正常情况下可以通过-XX:SoftRefLRUPolicyMSPerMB这个参数来控制回收的时机，一旦时机到了，只要GC发生就会将其回收，那回收之后意味着再有需求的时候要重新创建一个这样的对象，同时也需要从JVM里重新拿一份数据，那这个数据结构关联的Method，Field字段等都是重新生成的对象。</p>\n<h3 id=\"copy-方法\"> copy()方法</h3>\n<p>在获取到<code>Method</code>对象之后，并不是直接返回，而是<code>copy</code>一份对象。</p>\n<p><img src=\"./images/f21e9050c8ba4087981148a62d08b3ec.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>这里的<code>root</code>可看作是每一个方法唯一对应的<code>Method</code>，以后产生的每个<code>Method</code>都是从这里复制出去的。同所有的<code>Method</code>的<code>methodAccessor</code>都指向同一个。</p>\n<h3 id=\"method-使用\"> Method 使用</h3>\n<p>有了<code>Method</code>之后，那就可以调用其<code>invoke</code>方法了，那先看看<code>Method</code>的几个关键信息</p>\n<div><pre><code><span>class</span> <span>Method</span><span>{</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> obj<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>;</span>\n    <span>private</span> <span>Method</span>\troot<span>;</span>\n    <span>private</span> <span>volatile</span> <span>MethodAccessor</span> methodAccessor<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>root</code>属性其实上面已经说了，主要指向缓存里的<code>Method</code>对象，也就是当前这个Method对象其实是根据<code>root</code>这个Method构建出来的，因此存在一个<code>root Method</code>派生出多个<code>Method</code>的情况。</p>\n<p><code>methodAccessor</code>这个很关键了，其实<code>Method.invoke</code>方法就是调用<code>methodAccessor</code>的<code>invoke</code>方法，<code>methodAccessor</code>这个属性如果<code>root</code>本身已经有了，那就直接用<code>root</code>的<code>methodAccessor</code>赋值过来，否则的话就创建一个</p>\n<h3 id=\"methodaccessor\"> MethodAccessor</h3>\n<p><code>methodAccessor</code>本身只是一个接口</p>\n<p><img src=\"./images/0056ca36e1bb4cc88ffef7c3f2a01813.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>其实现主要有三种：</p>\n<ul>\n<li>DelegatingMethodAccessorImpl</li>\n<li>NativeMethodAccessorImpl</li>\n<li>GeneratedMethodAccessorXXX</li>\n</ul>\n<p>其中<code>DelegatingMethodAccessorImpl</code>是最终注入给<code>Method</code>的<code>methodAccessor</code>的，也就是某个<code>Method</code>的所有的<code>invoke</code>方法都会调用到这个<code>DelegatingMethodAccessorImpl.invoke</code>，正如其名一样的，是做代理的，就是为了下面切换不同调用类使用的。所以最终生成的<code>MethodAccessor</code>就两种。</p>\n<p><img src=\"./images/48a55f77235d44a6861b9285fda13aae.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>如果是<code>NativeMethodAccessorImpl</code>，那顾名思义，该实现主要是native实现的，而<code>GeneratedMethodAccessorXXX</code>是为每个需要反射调用的<code>Method</code>动态生成的类，后的XXX是一个数字，不断递增的</p>\n<p>并且所有的方法反射都是先走<code>NativeMethodAccessorImpl</code>，默认调了15次之后，才生成一个<code>GeneratedMethodAccessorXXX</code>类，生成好之后就会走这个生成的类的invoke方法了。那么怎么定义是15次？到了15次又是怎么切换类的呢？为什么又需要切换调用的invoke类呢？\n<br></p>\n<p>在生成<code>methodAccessor</code>的类<code>ReflectionFactory</code>中定义了阈值15</p>\n<div><pre><code><span>class</span> <span>ReflectionFactory</span><span>{</span>\n\t<span>private</span> <span>static</span> <span>int</span>     inflationThreshold <span>=</span> <span>15</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个15当然也不是一尘不变的，我们可以通过<code>-Dsun.reflect.inflationThreshold=xxx</code>来指定，我们还可以通过<code>-Dsun.reflect.noInflation=true</code>来直接绕过上面的15次<code>NativeMethodAccessorImpl</code>调用，和<code>-Dsun.reflect.inflationThreshold=0</code>的效果一样的</p>\n<p><img src=\"./images/f8be8d0a96cc40db99ec77ef4dd41b66.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>这个值在<code>NativeMethodAccessorImpl</code>调用<code>invoke</code>方法时候会判断是否大于15，超过以后会生成<code>GeneratedMethodAccessorXXX</code>，其实就是直接调用目标对象的具体方法了，和正常的方法调用没什么区别。这样下次<code>Method.invoke</code>就会调到这个新创建的MethodAccessor里了。</p>\n<p>至于为什么必须走 <code>NativeMethodAccessorImp.invoke</code>，源码给的解释是通过加载字节码以实现<code>Method.invoke()</code>和<code>Constructor.newInstance()</code>成本是第一次通过本机代码调用(本机代码应该是native方法)的成本的3-4倍。这会增加某些密集使用反射的应用程序的启动时间（但每个类仅一次）为了避免这种情况，我们在方法和构造函数的最初几次调用中重用了现有的JVM入口点，然后才是基于字节码的实现。</p>\n<p>参考：\n<a href=\"https://www.jianshu.com/p/3ea4a6b57f87\" target=\"_blank\" rel=\"noopener noreferrer\">1、深入分析Java方法反射的实现原理</a>\n<a href=\"https://mp.weixin.qq.com/s/5H6UHcP6kvR2X5hTj_SBjA?\" target=\"_blank\" rel=\"noopener noreferrer\">2、假笨说-从一起GC血案谈到反射原理</a></p>\n",
      "date_modified": "2022-04-29T06:23:43.031Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "代理模式",
      "url": "https://fmiles.cn/java/basics/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/",
      "id": "https://fmiles.cn/java/basics/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/",
      "content_html": "<blockquote>\n<p>本文首更于<a href=\"https://t.zsxq.com/iIUv7Mn\" target=\"_blank\" rel=\"noopener noreferrer\">《从零开始手把手教你实现一个简单的RPC框架》</a>  。</p>\n</blockquote>\n\n\n<ul>\n<li></li>\n<li></li>\n<li>\n<ul>\n<li>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li></li>\n</ul>\n</li>\n<li></li>\n<li></li>\n</ul>\n\n<h2 id=\"_1-代理模式\"> 1. 代理模式</h2>\n<p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>\n<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>\n<p>举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png\" alt=\"Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium\" loading=\"lazy\"></p>\n<p style=\"text-align:right;font-size:13px;color:gray\">https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a</p>\n<p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p>\n<h2 id=\"_2-静态代理\"> 2. 静态代理</h2>\n<p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码</em>），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(<em>需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>\n<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>\n<p>静态代理实现步骤:</p>\n<ol>\n<li>定义一个接口及其实现类；</li>\n<li>创建一个代理类同样实现这个接口</li>\n<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>\n</ol>\n<p>下面通过代码展示！</p>\n<p><strong>1.定义发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>\n    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"send message:\"</span> <span>+</span> message<span>)</span><span>;</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>SmsProxy</span> <span>implements</span> <span>SmsService</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>SmsService</span> smsService<span>;</span>\n\n    <span>public</span> <span>SmsProxy</span><span>(</span><span>SmsService</span> smsService<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>smsService <span>=</span> smsService<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>//调用方法之前，我们可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method send()\"</span><span>)</span><span>;</span>\n        smsService<span>.</span><span>send</span><span>(</span>message<span>)</span><span>;</span>\n        <span>//调用方法之后，我们同样可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method send()\"</span><span>)</span><span>;</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>4.实际使用</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SmsService</span> smsService <span>=</span> <span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>;</span>\n        <span>SmsProxy</span> smsProxy <span>=</span> <span>new</span> <span>SmsProxy</span><span>(</span>smsService<span>)</span><span>;</span>\n        smsProxy<span>.</span><span>send</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>\n<div><pre><code>before method send<span>(</span><span>)</span>\nsend message:java\nafter method send<span>(</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>\n<h2 id=\"_3-动态代理\"> 3. 动态代理</h2>\n<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>\n<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>\n<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>\n<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>\n<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>\n<p><a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a> 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>\n<p>另外，虽然 <a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a> 没有用到 <strong>CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和</strong>JDK 动态代理的对比。</p>\n<h3 id=\"_3-1-jdk-动态代理机制\"> 3.1. JDK 动态代理机制</h3>\n<h4 id=\"_3-1-1-介绍\"> 3.1.1. 介绍</h4>\n<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>\n<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>Object</span> <span>newProxyInstance</span><span>(</span><span>ClassLoader</span> loader<span>,</span>\n                                          <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces<span>,</span>\n                                          <span>InvocationHandler</span> h<span>)</span>\n        <span>throws</span> <span>IllegalArgumentException</span>\n    <span>{</span>\n        <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个方法一共有 3 个参数：</p>\n<ol>\n<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>\n<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>\n<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>\n</ol>\n<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>\n\n    <span>/**\n     * 当你使用代理对象调用方法的时候实际会调用到这个方法\n     */</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>\n        <span>throws</span> <span>Throwable</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>invoke()</code> 方法有下面三个参数：</p>\n<ol>\n<li><strong>proxy</strong> :动态生成的代理类</li>\n<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>\n<li><strong>args</strong> : 当前 method 方法的参数</li>\n</ol>\n<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>\n<h4 id=\"_3-1-2-jdk-动态代理类使用步骤\"> 3.1.2. JDK 动态代理类使用步骤</h4>\n<ol>\n<li>定义一个接口及其实现类；</li>\n<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>\n<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>\n</ol>\n<h4 id=\"_3-1-3-代码示例\"> 3.1.3. 代码示例</h4>\n<p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>\n<p><strong>1.定义发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>\n    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"send message:\"</span> <span>+</span> message<span>)</span><span>;</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.定义一个 JDK 动态代理类</strong></p>\n<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationHandler</span><span>;</span>\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>\n\n<span>/**\n * @author shuang.kou\n * @createTime 2020年05月11日 11:23:00\n */</span>\n<span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n    <span>/**\n     * 代理类中的真实对象\n     */</span>\n    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>\n\n    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>\n        <span>//调用方法之前，我们可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>\n        <span>//调用方法之后，我们同样可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>\n<p><strong>4.获取代理对象的工厂类</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>JdkProxyFactory</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>\n                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>// 目标类的类加载</span>\n                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>  <span>// 代理需要实现的接口，可指定多个</span>\n                <span>new</span> <span>DebugInvocationHandler</span><span>(</span>target<span>)</span>   <span>// 代理对象对应的自定义 InvocationHandler</span>\n        <span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>\n<p><strong>5.实际使用</strong></p>\n<div><pre><code><span>SmsService</span> smsService <span>=</span> <span>(</span><span>SmsService</span><span>)</span> <span>JdkProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>)</span><span>;</span>\nsmsService<span>.</span><span>send</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>\n<div><pre><code>before method send\nsend message:java\nafter method send\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-2-cglib-动态代理机制\"> 3.2. CGLIB 动态代理机制</h3>\n<h4 id=\"_3-2-1-介绍\"> 3.2.1. 介绍</h4>\n<p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>\n<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>\n<p><a href=\"https://github.com/cglib/cglib\" target=\"_blank\" rel=\"noopener noreferrer\">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href=\"http://www.baeldung.com/java-asm\" target=\"_blank\" rel=\"noopener noreferrer\">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href=\"https://github.com/cglib/cglib\" target=\"_blank\" rel=\"noopener noreferrer\">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>\n<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>\n<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>MethodInterceptor</span>\n<span>extends</span> <span>Callback</span><span>{</span>\n    <span>// 拦截被代理类中的方法</span>\n    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> obj<span>,</span> <span><span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span>\n                               <span>MethodProxy</span> proxy<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol>\n<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>\n<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>\n<li><strong>args</strong> :方法入参</li>\n<li><strong>methodProxy</strong> :用于调用原始方法</li>\n</ol>\n<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>\n<h4 id=\"_3-2-2-cglib-动态代理类使用步骤\"> 3.2.2. CGLIB 动态代理类使用步骤</h4>\n<ol>\n<li>定义一个类；</li>\n<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>\n<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>\n</ol>\n<h4 id=\"_3-2-3-代码示例\"> 3.2.3. 代码示例</h4>\n<p>不同于 JDK 动态代理不需要额外的依赖。<a href=\"https://github.com/cglib/cglib\" target=\"_blank\" rel=\"noopener noreferrer\">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n  <span><span><span>&lt;</span>groupId</span><span>></span></span>cglib<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n  <span><span><span>&lt;</span>artifactId</span><span>></span></span>cglib<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n  <span><span><span>&lt;</span>version</span><span>></span></span>3.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>1.实现一个使用阿里云发送短信的类</strong></p>\n<div><pre><code><span>package</span> <span>github<span>.</span>javaguide<span>.</span>dynamicProxy<span>.</span>cglibDynamicProxy</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>AliSmsService</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"send message:\"</span> <span>+</span> message<span>)</span><span>;</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>\n<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodInterceptor</span><span>;</span>\n<span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodProxy</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>\n\n<span>/**\n * 自定义MethodInterceptor\n */</span>\n<span>public</span> <span>class</span> <span>DebugMethodInterceptor</span> <span>implements</span> <span>MethodInterceptor</span> <span>{</span>\n\n\n    <span>/**\n     * @param o           被代理的对象（需要增强的对象）\n     * @param method      被拦截的方法（需要增强的方法）\n     * @param args        方法入参\n     * @param methodProxy 用于调用原始方法\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> o<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>MethodProxy</span> methodProxy<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>//调用方法之前，我们可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Object</span> object <span>=</span> methodProxy<span>.</span><span>invokeSuper</span><span>(</span>o<span>,</span> args<span>)</span><span>;</span>\n        <span>//调用方法之后，我们同样可以添加自己的操作</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after method \"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> object<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>3.获取代理类</strong></p>\n<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>Enhancer</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>CglibProxyFactory</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz<span>)</span> <span>{</span>\n        <span>// 创建动态代理增强类</span>\n        <span>Enhancer</span> enhancer <span>=</span> <span>new</span> <span>Enhancer</span><span>(</span><span>)</span><span>;</span>\n        <span>// 设置类加载器</span>\n        enhancer<span>.</span><span>setClassLoader</span><span>(</span>clazz<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 设置被代理类</span>\n        enhancer<span>.</span><span>setSuperclass</span><span>(</span>clazz<span>)</span><span>;</span>\n        <span>// 设置方法拦截器</span>\n        enhancer<span>.</span><span>setCallback</span><span>(</span><span>new</span> <span>DebugMethodInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 创建代理类</span>\n        <span>return</span> enhancer<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>4.实际使用</strong></p>\n<div><pre><code><span>AliSmsService</span> aliSmsService <span>=</span> <span>(</span><span>AliSmsService</span><span>)</span> <span>CglibProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>AliSmsService</span><span>.</span><span>class</span><span>)</span><span>;</span>\naliSmsService<span>.</span><span>send</span><span>(</span><span>\"java\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>\n<div><pre><code>before method send\nsend message:java\nafter method send\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-3-jdk-动态代理和-cglib-动态代理对比\"> 3.3. JDK 动态代理和 CGLIB 动态代理对比</h3>\n<ol>\n<li><strong>JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>\n<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>\n</ol>\n<h2 id=\"_4-静态代理和动态代理的对比\"> 4. 静态代理和动态代理的对比</h2>\n<ol>\n<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>\n<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>\n</ol>\n<h2 id=\"_5-总结\"> 5. 总结</h2>\n<p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>\n<p>文中涉及到的所有源码，你可以在这里找到：<a href=\"https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy</a> 。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png",
      "date_modified": "2022-04-29T06:23:43.042Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "枚举",
      "url": "https://fmiles.cn/java/basics/%E7%94%A8%E5%A5%BDJava%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/",
      "id": "https://fmiles.cn/java/basics/%E7%94%A8%E5%A5%BDJava%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/",
      "content_html": "<h2 id=\"_1-概览\"> 1.概览</h2>\n<p>在本文中，我们将看到什么是 Java 枚举，它们解决了哪些问题以及如何在实践中使用  Java 枚举实现一些设计模式。</p>\n<p>enum关键字在 java5 中引入，表示一种特殊类型的类，其总是继承java.lang.Enum类，更多内容可以自行查看其<a href=\"https://docs.oracle.com/javase/6/docs/api/java/lang/Enum.html\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a>。</p>\n<p>枚举在很多时候会和常量拿来对比，可能因为本身我们大量实际使用枚举的地方就是为了替代常量。那么这种方式由什么优势呢？</p>\n<p><strong>以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p>\n<p>下面示例定义一个简单的枚举类型 pizza 订单的状态，共有三种 ORDERED, READY, DELIVERED状态:</p>\n<div><pre><code><span>package</span> <span>shuang<span>.</span>kou<span>.</span>enumdemo<span>.</span>enumtest</span><span>;</span>\n\n<span>public</span> <span>enum</span> <span>PizzaStatus</span> <span>{</span>\n    ORDERED<span>,</span>\n    READY<span>,</span> \n    DELIVERED<span>;</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>简单来说，我们通过上面的代码避免了定义常量，我们将所有和 pizza 订单的状态的常量都统一放到了一个枚举类型里面。</strong></p>\n<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PizzaStatus</span><span>.</span>ORDERED<span>.</span><span>name</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//ORDERED</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PizzaStatus</span><span>.</span>ORDERED<span>)</span><span>;</span><span>//ORDERED</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PizzaStatus</span><span>.</span>ORDERED<span>.</span><span>name</span><span>(</span><span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//class java.lang.String</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PizzaStatus</span><span>.</span>ORDERED<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//class shuang.kou.enumdemo.enumtest.PizzaStatus</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_2-自定义枚举方法\"> 2.自定义枚举方法</h2>\n<p>现在我们对枚举是什么以及如何使用它们有了基本的了解，让我们通过在枚举上定义一些额外的API方法，将上一个示例提升到一个新的水平：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Pizza</span> <span>{</span>\n    <span>private</span> <span>PizzaStatus</span> status<span>;</span>\n    <span>public</span> <span>enum</span> <span>PizzaStatus</span> <span>{</span>\n        ORDERED<span>,</span>\n        READY<span>,</span>\n        DELIVERED<span>;</span>\n    <span>}</span>\n \n    <span>public</span> <span>boolean</span> <span>isDeliverable</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>getStatus</span><span>(</span><span>)</span> <span>==</span> <span>PizzaStatus</span><span>.</span>READY<span>;</span>\n    <span>}</span>\n     \n    <span>// Methods that set and get the status variable.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"_3-使用-比较枚举类型\"> 3.使用 == 比较枚举类型</h2>\n<p>由于枚举类型确保JVM中仅存在一个常量实例，因此我们可以安全地使用 <code>==</code> 运算符比较两个变量，如上例所示；此外，<code>==</code> 运算符可提供编译时和运行时的安全性。</p>\n<p>首先，让我们看一下以下代码段中的运行时安全性，其中 <code>==</code> 运算符用于比较状态，并且如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p>\n<div><pre><code><span>Pizza<span>.</span>PizzaStatus</span> pizza <span>=</span> <span>null</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>pizza<span>.</span><span>equals</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>)</span><span>;</span><span>//空指针异常</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>pizza <span>==</span> <span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>;</span><span>//正常运行</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较：</p>\n<div><pre><code><span>if</span> <span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED<span>.</span><span>equals</span><span>(</span><span>TestColor</span><span>.</span>GREEN<span>)</span><span>)</span><span>;</span> <span>// 编译正常</span>\n<span>if</span> <span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED <span>==</span> <span>TestColor</span><span>.</span>GREEN<span>)</span><span>;</span>      <span>// 编译失败，类型不匹配</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"_4-在-switch-语句中使用枚举类型\"> 4.在 switch 语句中使用枚举类型</h2>\n<div><pre><code><span>public</span> <span>int</span> <span>getDeliveryTimeInDays</span><span>(</span><span>)</span> <span>{</span>\n    <span>switch</span> <span>(</span>status<span>)</span> <span>{</span>\n        <span>case</span> ORDERED<span>:</span>\n            <span>return</span> <span>5</span><span>;</span>\n        <span>case</span> READY<span>:</span>\n            <span>return</span> <span>2</span><span>;</span>\n        <span>case</span> DELIVERED<span>:</span>\n            <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>0</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_5-枚举类型的属性-方法和构造函数\"> 5.枚举类型的属性,方法和构造函数</h2>\n<blockquote>\n<p>文末有我(JavaGuide)的补充。</p>\n</blockquote>\n<p>你可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p>\n<p>下面，让我们扩展上面的示例，实现从比萨的一个阶段到另一个阶段的过渡，并了解如何摆脱之前使用的if语句和switch语句：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Pizza</span> <span>{</span>\n \n    <span>private</span> <span>PizzaStatus</span> status<span>;</span>\n    <span>public</span> <span>enum</span> <span>PizzaStatus</span> <span>{</span>\n        ORDERED <span>(</span><span>5</span><span>)</span><span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>boolean</span> <span>isOrdered</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span>\n        READY <span>(</span><span>2</span><span>)</span><span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>boolean</span> <span>isReady</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span>\n        DELIVERED <span>(</span><span>0</span><span>)</span><span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>boolean</span> <span>isDelivered</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>true</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n \n        <span>private</span> <span>int</span> timeToDelivery<span>;</span>\n \n        <span>public</span> <span>boolean</span> <span>isOrdered</span><span>(</span><span>)</span> <span>{</span><span>return</span> <span>false</span><span>;</span><span>}</span>\n \n        <span>public</span> <span>boolean</span> <span>isReady</span><span>(</span><span>)</span> <span>{</span><span>return</span> <span>false</span><span>;</span><span>}</span>\n \n        <span>public</span> <span>boolean</span> <span>isDelivered</span><span>(</span><span>)</span><span>{</span><span>return</span> <span>false</span><span>;</span><span>}</span>\n \n        <span>public</span> <span>int</span> <span>getTimeToDelivery</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> timeToDelivery<span>;</span>\n        <span>}</span>\n \n        <span>PizzaStatus</span> <span>(</span><span>int</span> timeToDelivery<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>timeToDelivery <span>=</span> timeToDelivery<span>;</span>\n        <span>}</span>\n    <span>}</span>\n \n    <span>public</span> <span>boolean</span> <span>isDeliverable</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>status<span>.</span><span>isReady</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n \n    <span>public</span> <span>void</span> <span>printTimeToDeliver</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Time to delivery is \"</span> <span>+</span> \n          <span>this</span><span>.</span><span>getStatus</span><span>(</span><span>)</span><span>.</span><span>getTimeToDelivery</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n     \n    <span>// Methods that set and get the status variable.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>下面这段代码展示它是如何 work 的：</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>givenPizaOrder_whenReady_thenDeliverable</span><span>(</span><span>)</span> <span>{</span>\n    <span>Pizza</span> testPz <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    testPz<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>READY<span>)</span><span>;</span>\n    <span>assertTrue</span><span>(</span>testPz<span>.</span><span>isDeliverable</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"_6-enumset-and-enummap\"> 6.EnumSet and EnumMap</h2>\n<h3 id=\"_6-1-enumset\"> 6.1. EnumSet</h3>\n<p><code>EnumSet</code> 是一种专门为枚举类型所设计的 <code>Set</code> 类型。</p>\n<p>与<code>HashSet</code>相比，由于使用了内部位向量表示，因此它是特定 <code>Enum</code> 常量集的非常有效且紧凑的表示形式。</p>\n<p>它提供了类型安全的替代方法，以替代传统的基于int的“位标志”，使我们能够编写更易读和易于维护的简洁代码。</p>\n<p><code>EnumSet</code> 是抽象类，其有两个实现：<code>RegularEnumSet</code> 、<code>JumboEnumSet</code>，选择哪一个取决于实例化时枚举中常量的数量。</p>\n<p>在很多场景中的枚举常量集合操作（如：取子集、增加、删除、<code>containsAll</code>和<code>removeAll</code>批操作）使用<code>EnumSet</code>非常合适；如果需要迭代所有可能的常量则使用<code>Enum.values()</code>。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Pizza</span> <span>{</span>\n \n    <span>private</span> <span>static</span> <span>EnumSet</span><span><span>&lt;</span><span>PizzaStatus</span><span>></span></span> undeliveredPizzaStatuses <span>=</span>\n      <span>EnumSet</span><span>.</span><span>of</span><span>(</span><span>PizzaStatus</span><span>.</span>ORDERED<span>,</span> <span>PizzaStatus</span><span>.</span>READY<span>)</span><span>;</span>\n \n    <span>private</span> <span>PizzaStatus</span> status<span>;</span>\n \n    <span>public</span> <span>enum</span> <span>PizzaStatus</span> <span>{</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n \n    <span>public</span> <span>boolean</span> <span>isDeliverable</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>status<span>.</span><span>isReady</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n \n    <span>public</span> <span>void</span> <span>printTimeToDeliver</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Time to delivery is \"</span> <span>+</span> \n          <span>this</span><span>.</span><span>getStatus</span><span>(</span><span>)</span><span>.</span><span>getTimeToDelivery</span><span>(</span><span>)</span> <span>+</span> <span>\" days\"</span><span>)</span><span>;</span>\n    <span>}</span>\n \n    <span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> <span>getAllUndeliveredPizzas</span><span>(</span><span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> input<span>)</span> <span>{</span>\n        <span>return</span> input<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span>\n          <span>(</span>s<span>)</span> <span>-></span> undeliveredPizzaStatuses<span>.</span><span>contains</span><span>(</span>s<span>.</span><span>getStatus</span><span>(</span><span>)</span><span>)</span><span>)</span>\n            <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n \n    <span>public</span> <span>void</span> <span>deliver</span><span>(</span><span>)</span> <span>{</span> \n        <span>if</span> <span>(</span><span>isDeliverable</span><span>(</span><span>)</span><span>)</span> <span>{</span> \n            <span>PizzaDeliverySystemConfiguration</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getDeliveryStrategy</span><span>(</span><span>)</span>\n              <span>.</span><span>deliver</span><span>(</span><span>this</span><span>)</span><span>;</span> \n            <span>this</span><span>.</span><span>setStatus</span><span>(</span><span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>;</span> \n        <span>}</span> \n    <span>}</span>\n     \n    <span>// Methods that set and get the status variable.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>下面的测试演示了展示了 <code>EnumSet</code> 在某些场景下的强大功能：</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>givenPizaOrders_whenRetrievingUnDeliveredPzs_thenCorrectlyRetrieved</span><span>(</span><span>)</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> pzList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>Pizza</span> pz1 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz1<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>;</span>\n \n    <span>Pizza</span> pz2 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz2<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>ORDERED<span>)</span><span>;</span>\n \n    <span>Pizza</span> pz3 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz3<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>ORDERED<span>)</span><span>;</span>\n \n    <span>Pizza</span> pz4 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz4<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>READY<span>)</span><span>;</span>\n \n    pzList<span>.</span><span>add</span><span>(</span>pz1<span>)</span><span>;</span>\n    pzList<span>.</span><span>add</span><span>(</span>pz2<span>)</span><span>;</span>\n    pzList<span>.</span><span>add</span><span>(</span>pz3<span>)</span><span>;</span>\n    pzList<span>.</span><span>add</span><span>(</span>pz4<span>)</span><span>;</span>\n \n    <span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> undeliveredPzs <span>=</span> <span>Pizza</span><span>.</span><span>getAllUndeliveredPizzas</span><span>(</span>pzList<span>)</span><span>;</span> \n    <span>assertTrue</span><span>(</span>undeliveredPzs<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> <span>3</span><span>)</span><span>;</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"_6-2-enummap\"> 6.2. EnumMap</h3>\n<p><code>EnumMap</code>是一个专门化的映射实现，用于将枚举常量用作键。与对应的 <code>HashMap</code> 相比，它是一个高效紧凑的实现，并且在内部表示为一个数组:</p>\n<div><pre><code><span>EnumMap</span><span><span>&lt;</span><span>Pizza<span>.</span>PizzaStatus</span><span>,</span> <span>Pizza</span><span>></span></span> map<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>让我们快速看一个真实的示例，该示例演示如何在实践中使用它：</p>\n<div><pre><code><span>Iterator</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> iterator <span>=</span> pizzaList<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n<span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n    <span>Pizza</span> pz <span>=</span> iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n    <span>PizzaStatus</span> status <span>=</span> pz<span>.</span><span>getStatus</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>pzByStatus<span>.</span><span>containsKey</span><span>(</span>status<span>)</span><span>)</span> <span>{</span>\n      pzByStatus<span>.</span><span>get</span><span>(</span>status<span>)</span><span>.</span><span>add</span><span>(</span>pz<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> newPzList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n      newPzList<span>.</span><span>add</span><span>(</span>pz<span>)</span><span>;</span>\n      pzByStatus<span>.</span><span>put</span><span>(</span>status<span>,</span> newPzList<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>下面的测试演示了展示了 <code>EnumMap</code> 在某些场景下的强大功能：</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>givenPizaOrders_whenGroupByStatusCalled_thenCorrectlyGrouped</span><span>(</span><span>)</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> pzList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>Pizza</span> pz1 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz1<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>;</span>\n \n    <span>Pizza</span> pz2 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz2<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>ORDERED<span>)</span><span>;</span>\n \n    <span>Pizza</span> pz3 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz3<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>ORDERED<span>)</span><span>;</span>\n \n    <span>Pizza</span> pz4 <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz4<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>READY<span>)</span><span>;</span>\n \n    pzList<span>.</span><span>add</span><span>(</span>pz1<span>)</span><span>;</span>\n    pzList<span>.</span><span>add</span><span>(</span>pz2<span>)</span><span>;</span>\n    pzList<span>.</span><span>add</span><span>(</span>pz3<span>)</span><span>;</span>\n    pzList<span>.</span><span>add</span><span>(</span>pz4<span>)</span><span>;</span>\n \n    <span>EnumMap</span><span><span>&lt;</span><span>Pizza<span>.</span>PizzaStatus</span><span>,</span><span>List</span><span>&lt;</span><span>Pizza</span><span>></span><span>></span></span> map <span>=</span> <span>Pizza</span><span>.</span><span>groupPizzaByStatus</span><span>(</span>pzList<span>)</span><span>;</span>\n    <span>assertTrue</span><span>(</span>map<span>.</span><span>get</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> <span>1</span><span>)</span><span>;</span>\n    <span>assertTrue</span><span>(</span>map<span>.</span><span>get</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>ORDERED<span>)</span><span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> <span>2</span><span>)</span><span>;</span>\n    <span>assertTrue</span><span>(</span>map<span>.</span><span>get</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>READY<span>)</span><span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> <span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id=\"_7-通过枚举实现一些设计模式\"> 7. 通过枚举实现一些设计模式</h2>\n<h3 id=\"_7-1-单例模式\"> 7.1 单例模式</h3>\n<p>通常，使用类实现 Singleton 模式并非易事，枚举提供了一种实现单例的简便方法。</p>\n<p>《Effective Java 》和《Java与模式》都非常推荐这种方式，使用这种方式方式实现枚举可以有什么好处呢？</p>\n<p>《Effective Java》</p>\n<blockquote>\n<p>这种方法在功能上与公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现 Singleton的最佳方法。 —-《Effective Java 中文版 第二版》</p>\n</blockquote>\n<p>《Java与模式》</p>\n<blockquote>\n<p>《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>\n</blockquote>\n<p>下面的代码段显示了如何使用枚举实现单例模式：</p>\n<div><pre><code><span>public</span> <span>enum</span> <span>PizzaDeliverySystemConfiguration</span> <span>{</span>\n    INSTANCE<span>;</span>\n    <span>PizzaDeliverySystemConfiguration</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Initialization configuration which involves</span>\n        <span>// overriding defaults like delivery strategy</span>\n    <span>}</span>\n \n    <span>private</span> <span>PizzaDeliveryStrategy</span> deliveryStrategy <span>=</span> <span>PizzaDeliveryStrategy</span><span>.</span>NORMAL<span>;</span>\n \n    <span>public</span> <span>static</span> <span>PizzaDeliverySystemConfiguration</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> INSTANCE<span>;</span>\n    <span>}</span>\n \n    <span>public</span> <span>PizzaDeliveryStrategy</span> <span>getDeliveryStrategy</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> deliveryStrategy<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如何使用呢？请看下面的代码：</p>\n<div><pre><code><span>PizzaDeliveryStrategy</span> deliveryStrategy <span>=</span> <span>PizzaDeliverySystemConfiguration</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getDeliveryStrategy</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>通过 <code>PizzaDeliverySystemConfiguration.getInstance()</code> 获取的就是单例的 <code>PizzaDeliverySystemConfiguration</code></p>\n<h3 id=\"_7-2-策略模式\"> 7.2 策略模式</h3>\n<p>通常，策略模式由不同类实现同一个接口来实现的。</p>\n<p>这也就意味着添加新策略意味着添加新的实现类。使用枚举，可以轻松完成此任务，添加新的实现意味着只定义具有某个实现的另一个实例。</p>\n<p>下面的代码段显示了如何使用枚举实现策略模式：</p>\n<div><pre><code><span>public</span> <span>enum</span> <span>PizzaDeliveryStrategy</span> <span>{</span>\n    EXPRESS <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>deliver</span><span>(</span><span>Pizza</span> pz<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Pizza will be delivered in express mode\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>,</span>\n    NORMAL <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>deliver</span><span>(</span><span>Pizza</span> pz<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Pizza will be delivered in normal mode\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n \n    <span>public</span> <span>abstract</span> <span>void</span> <span>deliver</span><span>(</span><span>Pizza</span> pz<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>给 <code>Pizza</code>增加下面的方法：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>deliver</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>isDeliverable</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>PizzaDeliverySystemConfiguration</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>.</span><span>getDeliveryStrategy</span><span>(</span><span>)</span>\n          <span>.</span><span>deliver</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>setStatus</span><span>(</span><span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如何使用呢？请看下面的代码：</p>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>givenPizaOrder_whenDelivered_thenPizzaGetsDeliveredAndStatusChanges</span><span>(</span><span>)</span> <span>{</span>\n    <span>Pizza</span> pz <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\n    pz<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>READY<span>)</span><span>;</span>\n    pz<span>.</span><span>deliver</span><span>(</span><span>)</span><span>;</span>\n    <span>assertTrue</span><span>(</span>pz<span>.</span><span>getStatus</span><span>(</span><span>)</span> <span>==</span> <span>Pizza<span>.</span>PizzaStatus</span><span>.</span>DELIVERED<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_8-java-8-与枚举\"> 8. Java 8 与枚举</h2>\n<p>Pizza 类可以用Java 8重写，您可以看到方法 lambda 和Stream API如何使 <code>getAllUndeliveredPizzas（）</code>和<code>groupPizzaByStatus（）</code>方法变得如此简洁：</p>\n<p><code>getAllUndeliveredPizzas（）</code>:</p>\n<div><pre><code><span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> <span>getAllUndeliveredPizzas</span><span>(</span><span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> input<span>)</span> <span>{</span>\n    <span>return</span> input<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>filter</span><span>(</span>\n      <span>(</span>s<span>)</span> <span>-></span> <span>!</span>deliveredPizzaStatuses<span>.</span><span>contains</span><span>(</span>s<span>.</span><span>getStatus</span><span>(</span><span>)</span><span>)</span><span>)</span>\n        <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>groupPizzaByStatus（）</code> :</p>\n<div><pre><code><span>public</span> <span>static</span> <span>EnumMap</span><span><span>&lt;</span><span>PizzaStatus</span><span>,</span> <span>List</span><span>&lt;</span><span>Pizza</span><span>></span><span>></span></span> \n  <span>groupPizzaByStatus</span><span>(</span><span>List</span><span><span>&lt;</span><span>Pizza</span><span>></span></span> pzList<span>)</span> <span>{</span>\n    <span>EnumMap</span><span><span>&lt;</span><span>PizzaStatus</span><span>,</span> <span>List</span><span>&lt;</span><span>Pizza</span><span>></span><span>></span></span> map <span>=</span> pzList<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span>\n      <span>Collectors</span><span>.</span><span>groupingBy</span><span>(</span><span>Pizza</span><span>::</span><span>getStatus</span><span>,</span>\n      <span>(</span><span>)</span> <span>-></span> <span>new</span> <span>EnumMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>PizzaStatus</span><span>.</span><span>class</span><span>)</span><span>,</span> <span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>return</span> map<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_9-enum-类型的-json-表现形式\"> 9. Enum 类型的 JSON 表现形式</h2>\n<p>使用Jackson库，可以将枚举类型的JSON表示为POJO。下面的代码段显示了可以用于同一目的的Jackson批注：</p>\n<div><pre><code><span>@JsonFormat</span><span>(</span>shape <span>=</span> <span>JsonFormat<span>.</span>Shape</span><span>.</span>OBJECT<span>)</span>\n<span>public</span> <span>enum</span> <span>PizzaStatus</span> <span>{</span>\n    ORDERED <span>(</span><span>5</span><span>)</span><span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>boolean</span> <span>isOrdered</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>,</span>\n    READY <span>(</span><span>2</span><span>)</span><span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>boolean</span> <span>isReady</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>,</span>\n    DELIVERED <span>(</span><span>0</span><span>)</span><span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>boolean</span> <span>isDelivered</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n \n    <span>private</span> <span>int</span> timeToDelivery<span>;</span>\n \n    <span>public</span> <span>boolean</span> <span>isOrdered</span><span>(</span><span>)</span> <span>{</span><span>return</span> <span>false</span><span>;</span><span>}</span>\n \n    <span>public</span> <span>boolean</span> <span>isReady</span><span>(</span><span>)</span> <span>{</span><span>return</span> <span>false</span><span>;</span><span>}</span>\n \n    <span>public</span> <span>boolean</span> <span>isDelivered</span><span>(</span><span>)</span><span>{</span><span>return</span> <span>false</span><span>;</span><span>}</span>\n \n    <span>@JsonProperty</span><span>(</span><span>\"timeToDelivery\"</span><span>)</span>\n    <span>public</span> <span>int</span> <span>getTimeToDelivery</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> timeToDelivery<span>;</span>\n    <span>}</span>\n \n    <span>private</span> <span>PizzaStatus</span> <span>(</span><span>int</span> timeToDelivery<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>timeToDelivery <span>=</span> timeToDelivery<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>我们可以按如下方式使用 <code>Pizza</code> 和 <code>PizzaStatus</code>：</p>\n<div><pre><code><span>Pizza</span> pz <span>=</span> <span>new</span> <span>Pizza</span><span>(</span><span>)</span><span>;</span>\npz<span>.</span><span>setStatus</span><span>(</span><span>Pizza<span>.</span>PizzaStatus</span><span>.</span>READY<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Pizza</span><span>.</span><span>getJsonString</span><span>(</span>pz<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>生成 Pizza 状态以以下JSON展示：</p>\n<div><pre><code><span>{</span>\n  <span>\"status\"</span> <span>:</span> <span>{</span>\n    <span>\"timeToDelivery\"</span> <span>:</span> <span>2</span><span>,</span>\n    <span>\"ready\"</span> <span>:</span> <span>true</span><span>,</span>\n    <span>\"ordered\"</span> <span>:</span> <span>false</span><span>,</span>\n    <span>\"delivered\"</span> <span>:</span> <span>false</span>\n  <span>}</span><span>,</span>\n  <span>\"deliverable\"</span> <span>:</span> <span>true</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>有关枚举类型的JSON序列化/反序列化（包括自定义）的更多信息，请参阅<a href=\"https://www.baeldung.com/jackson-serialize-enums\" target=\"_blank\" rel=\"noopener noreferrer\">Jackson-将枚举序列化为JSON对象。</a></p>\n<h2 id=\"_10-总结\"> 10.总结</h2>\n<p>本文我们讨论了Java枚举类型，从基础知识到高级应用以及实际应用场景，让我们感受到枚举的强大功能。</p>\n<h2 id=\"_11-补充\"> 11. 补充</h2>\n<p>我们在上面讲到了，我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p>\n<p>下面我通过一个实际的例子展示一下，当我们调用短信验证码的时候可能有几种不同的用途，我们在下面这样定义：</p>\n<div><pre><code>\n<span>public</span> <span>enum</span> <span>PinType</span> <span>{</span>\n\n    <span>REGISTER</span><span>(</span><span>100000</span><span>,</span> <span>\"注册使用\"</span><span>)</span><span>,</span>\n    <span>FORGET_PASSWORD</span><span>(</span><span>100001</span><span>,</span> <span>\"忘记密码使用\"</span><span>)</span><span>,</span>\n    <span>UPDATE_PHONE_NUMBER</span><span>(</span><span>100002</span><span>,</span> <span>\"更新手机号码使用\"</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>final</span> <span>int</span> code<span>;</span>\n    <span>private</span> <span>final</span> <span>String</span> message<span>;</span>\n\n    <span>PinType</span><span>(</span><span>int</span> code<span>,</span> <span>String</span> message<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>code <span>=</span> code<span>;</span>\n        <span>this</span><span>.</span>message <span>=</span> message<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> code<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getMessage</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"PinType{\"</span> <span>+</span>\n                <span>\"code=\"</span> <span>+</span> code <span>+</span>\n                <span>\", message='\"</span> <span>+</span> message <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>实际使用：</p>\n<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PinType</span><span>.</span>FORGET_PASSWORD<span>.</span><span>getCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PinType</span><span>.</span>FORGET_PASSWORD<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PinType</span><span>.</span>FORGET_PASSWORD<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Output:</p>\n<div><pre><code><span>100001</span>\n忘记密码使用\n<span>PinType</span><span>{</span>code<span>=</span><span>100001</span><span>,</span> message<span>=</span><span>'忘记密码使用'</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这样的话，在实际使用起来就会非常灵活方便！</p>\n",
      "date_modified": "2022-04-29T06:23:43.048Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "基础"
      ]
    },
    {
      "title": "1. ArrayList 简介",
      "url": "https://fmiles.cn/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/",
      "id": "https://fmiles.cn/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/",
      "content_html": "<h2 id=\"_1-arraylist-简介\"> 1. ArrayList 简介</h2>\n<p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>\n<p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>\n        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>{</span>\n\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li>\n<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>\n</ul>\n<h3 id=\"_1-1-arraylist-和-vector-的区别\"> 1.1. Arraylist 和 Vector 的区别?</h3>\n<ol>\n<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>\n<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li>\n</ol>\n<h3 id=\"_1-2-arraylist-与-linkedlist-区别\"> 1.2. Arraylist 与 LinkedList 区别?</h3>\n<ol>\n<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>\n<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>\n<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>\n</ol>\n<h2 id=\"_2-arraylist-核心源码解读\"> 2. ArrayList 核心源码解读</h2>\n<div><pre><code><span>package</span> <span>java<span>.</span>util</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Consumer</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Predicate</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>UnaryOperator</span><span>;</span>\n\n\n<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>\n        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>\n<span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>8683452581122892189L</span><span>;</span>\n\n    <span>/**\n     * 默认初始容量大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>\n\n    <span>/**\n     * 空数组（用于空实例）。\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n     <span>//用于默认大小空实例的共享空数组实例。</span>\n      <span>//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n    <span>/**\n     * 保存ArrayList数据的数组\n     */</span>\n    <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span> <span>// non-private to simplify nested class access</span>\n\n    <span>/**\n     * ArrayList 所包含的元素个数\n     */</span>\n    <span>private</span> <span>int</span> size<span>;</span>\n\n    <span>/**\n     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>//如果传入的参数大于0，创建initialCapacity大小的数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>//如果传入的参数等于0，创建空数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>//其他情况，抛出异常</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal Capacity: \"</span><span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     *默认无参构造函数\n     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>//将指定集合转换为数组</span>\n        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>//如果elementData数组的长度不为0</span>\n        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span>\n            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>\n                <span>//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span>\n                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// 其他情况，用空数组代替</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。\n     */</span>\n    <span>public</span> <span>void</span> <span>trimToSize</span><span>(</span><span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n        <span>if</span> <span>(</span>size <span>&lt;</span> elementData<span>.</span>length<span>)</span> <span>{</span>\n            elementData <span>=</span> <span>(</span>size <span>==</span> <span>0</span><span>)</span>\n              <span>?</span> EMPTY_ELEMENTDATA\n              <span>:</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>//下面是ArrayList的扩容机制</span>\n<span>//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span>\n<span>//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>\n    <span>/**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */</span>\n    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span>\n        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>\n            <span>// any size if not default element table</span>\n            <span>?</span> <span>0</span>\n            <span>// larger than default for default empty table. It's already</span>\n            <span>// supposed to be at default size.</span>\n            <span>:</span> DEFAULT_CAPACITY<span>;</span>\n        <span>//如果最小容量大于已有的最大容量</span>\n        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>\n            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n   <span>//得到最小扩容量</span>\n    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>\n              <span>// 获取“默认的容量”和“传入参数”两者之间的最大值</span>\n            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n  <span>//判断是否需要扩容</span>\n    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n\n        <span>// overflow-conscious code</span>\n        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>\n            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>\n            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 要分配的最大数组大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>\n\n    <span>/**\n     * ArrayList扩容的核心方法。\n     */</span>\n    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>// oldCapacity为旧容量，newCapacity为新容量</span>\n        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>\n        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>\n        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>\n        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>\n        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> minCapacity<span>;</span>\n        <span>//再检查新容量是否超出了ArrayList所定义的最大容量，</span>\n        <span>//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>\n        <span>//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>// minCapacity is usually close to size, so this is a win:</span>\n        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//比较minCapacity和 MAX_ARRAY_SIZE</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>\n            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>\n            MAX_ARRAY_SIZE<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *返回此列表中的元素数。\n     */</span>\n    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> size<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 如果此列表不包含元素，则返回 true 。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>\n        <span>//注意=和==的区别</span>\n        <span>return</span> size <span>==</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 如果此列表包含指定的元素，则返回true 。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span>\n        <span>return</span> <span>indexOf</span><span>(</span>o<span>)</span> <span>>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n     */</span>\n    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n                <span>//equals()方法比较</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */</span>\n    <span>public</span> <span>int</span> <span>lastIndexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>\n                    <span>return</span> i<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>-</span><span>1</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）\n     */</span>\n    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span> v <span>=</span> <span>(</span><span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n            <span>//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>\n            v<span>.</span>elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n            v<span>.</span>modCount <span>=</span> <span>0</span><span>;</span>\n            <span>return</span> v<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>\n            <span>// 这不应该发生，因为我们是可以克隆的</span>\n            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */</span>\n    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;\n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。\n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。\n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）\n     */</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>a<span>.</span>length <span>&lt;</span> size<span>)</span>\n            <span>// 新建一个运行时类型的数组，但是ArrayList数组的内容</span>\n            <span>return</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> a<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>//调用System提供的arraycopy()方法实现数组之间的复制</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> <span>0</span><span>,</span> a<span>,</span> <span>0</span><span>,</span> size<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>a<span>.</span>length <span>></span> size<span>)</span>\n            a<span>[</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span>\n        <span>return</span> a<span>;</span>\n    <span>}</span>\n\n    <span>// Positional Access Operations</span>\n\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>E</span> <span>elementData</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>E</span><span>)</span> elementData<span>[</span>index<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回此列表中指定位置的元素。\n     */</span>\n    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>return</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 用指定的元素替换此列表中指定位置的元素。\n     */</span>\n    <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>//对index进行界限检查</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        <span>//返回原来在这个位置的元素</span>\n        <span>return</span> oldValue<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 将指定的元素追加到此列表的末尾。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>\n        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */</span>\n    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span>\n                         size <span>-</span> index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        size<span>++</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。\n     */</span>\n    <span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>\n\n        modCount<span>++</span><span>;</span>\n        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>\n                             numMoved<span>)</span><span>;</span>\n        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>\n      <span>//从列表中删除的元素</span>\n        <span>return</span> oldValue<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */</span>\n    <span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>elementData<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>\n                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>index<span>]</span><span>)</span><span>)</span> <span>{</span>\n                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>/*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */</span>\n    <span>private</span> <span>void</span> <span>fastRemove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>\n                             numMoved<span>)</span><span>;</span>\n        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>\n    <span>}</span>\n\n    <span>/**\n     * 从列表中删除所有元素。\n     */</span>\n    <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n\n        <span>// 把数组中所有的元素的值设为null</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>\n            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>\n\n        size <span>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> size<span>,</span> numNew<span>)</span><span>;</span>\n        size <span>+=</span> numNew<span>;</span>\n        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>int</span> index<span>,</span> <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>\n\n        <span>int</span> numMoved <span>=</span> size <span>-</span> index<span>;</span>\n        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>\n            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> numNew<span>,</span>\n                             numMoved<span>)</span><span>;</span>\n\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> index<span>,</span> numNew<span>)</span><span>;</span>\n        size <span>+=</span> numNew<span>;</span>\n        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */</span>\n    <span>protected</span> <span>void</span> <span>removeRange</span><span>(</span><span>int</span> fromIndex<span>,</span> <span>int</span> toIndex<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n        <span>int</span> numMoved <span>=</span> size <span>-</span> toIndex<span>;</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> toIndex<span>,</span> elementData<span>,</span> fromIndex<span>,</span>\n                         numMoved<span>)</span><span>;</span>\n\n        <span>// clear to let GC do its work</span>\n        <span>int</span> newSize <span>=</span> size <span>-</span> <span>(</span>toIndex<span>-</span>fromIndex<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> newSize<span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>\n        <span>}</span>\n        size <span>=</span> newSize<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 检查给定的索引是否在范围内。\n     */</span>\n    <span>private</span> <span>void</span> <span>rangeCheck</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>index <span>>=</span> size<span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * add和addAll使用的rangeCheck的一个版本\n     */</span>\n    <span>private</span> <span>void</span> <span>rangeCheckForAdd</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>index <span>></span> size <span>||</span> index <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 返回IndexOutOfBoundsException细节信息\n     */</span>\n    <span>private</span> <span>String</span> <span>outOfBoundsMsg</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>return</span> <span>\"Index: \"</span><span>+</span>index<span>+</span><span>\", Size: \"</span><span>+</span>size<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 从此列表中删除指定集合中包含的所有元素。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>removeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>\n        <span>//如果此列表被修改则返回true</span>\n        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>false</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>retainAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>\n        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>\n        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。\n     *返回的列表迭代器是fail-fast 。\n     */</span>\n    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>></span> size<span>)</span>\n            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>\"Index: \"</span><span>+</span>index<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span>index<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *返回列表中的列表迭代器（按适当的顺序）。\n     *返回的列表迭代器是fail-fast 。\n     */</span>\n    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     *以正确的顺序返回该列表中的元素的迭代器。\n     *返回的迭代器是fail-fast 。\n     */</span>\n    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Itr</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br><span>375</span><br><span>376</span><br><span>377</span><br><span>378</span><br><span>379</span><br><span>380</span><br><span>381</span><br><span>382</span><br><span>383</span><br><span>384</span><br><span>385</span><br><span>386</span><br><span>387</span><br><span>388</span><br><span>389</span><br><span>390</span><br><span>391</span><br><span>392</span><br><span>393</span><br><span>394</span><br><span>395</span><br><span>396</span><br><span>397</span><br><span>398</span><br><span>399</span><br><span>400</span><br><span>401</span><br><span>402</span><br><span>403</span><br><span>404</span><br><span>405</span><br><span>406</span><br><span>407</span><br><span>408</span><br><span>409</span><br><span>410</span><br><span>411</span><br><span>412</span><br><span>413</span><br><span>414</span><br><span>415</span><br><span>416</span><br><span>417</span><br><span>418</span><br><span>419</span><br><span>420</span><br><span>421</span><br><span>422</span><br><span>423</span><br><span>424</span><br><span>425</span><br><span>426</span><br><span>427</span><br><span>428</span><br><span>429</span><br><span>430</span><br><span>431</span><br><span>432</span><br><span>433</span><br><span>434</span><br><span>435</span><br><span>436</span><br><span>437</span><br><span>438</span><br><span>439</span><br><span>440</span><br><span>441</span><br><span>442</span><br><span>443</span><br><span>444</span><br><span>445</span><br><span>446</span><br><span>447</span><br><span>448</span><br><span>449</span><br><span>450</span><br><span>451</span><br><span>452</span><br><span>453</span><br><span>454</span><br><span>455</span><br><span>456</span><br><span>457</span><br><span>458</span><br><span>459</span><br><span>460</span><br><span>461</span><br><span>462</span><br><span>463</span><br><span>464</span><br><span>465</span><br><span>466</span><br><span>467</span><br><span>468</span><br><span>469</span><br><span>470</span><br><span>471</span><br><span>472</span><br><span>473</span><br><span>474</span><br><span>475</span><br><span>476</span><br><span>477</span><br><span>478</span><br><span>479</span><br><span>480</span><br><span>481</span><br><span>482</span><br><span>483</span><br><span>484</span><br><span>485</span><br><span>486</span><br><span>487</span><br><span>488</span><br><span>489</span><br><span>490</span><br><span>491</span><br><span>492</span><br><span>493</span><br><span>494</span><br><span>495</span><br><span>496</span><br><span>497</span><br><span>498</span><br><span>499</span><br><span>500</span><br><span>501</span><br><span>502</span><br><span>503</span><br></div></div><h2 id=\"_3-arraylist-扩容机制分析\"> 3. ArrayList 扩容机制分析</h2>\n<h3 id=\"_3-1-先从-arraylist-的构造函数说起\"> 3.1. 先从 ArrayList 的构造函数说起</h3>\n<p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>\n<div><pre><code>   <span>/**\n     * 默认初始容量大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>\n\n\n    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>\n\n    <span>/**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */</span>\n    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span><span>//初始容量大于0</span>\n            <span>//创建initialCapacity大小的数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span><span>//初始容量等于0</span>\n            <span>//创建空数组</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span><span>//初始容量小于0，抛出异常</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Illegal Capacity: \"</span><span>+</span>\n                                               initialCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n\n   <span>/**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。\n    */</span>\n     <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>\n        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>\n            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>\n                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// replace with empty array.</span>\n            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>\n<blockquote>\n<p>补充：JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建<strong>类似于单例的饿汉式</strong>，而jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。JDK8的内存优化也值得我们在平时开发中学习。</p>\n</blockquote>\n<h3 id=\"_3-2-一步一步分析-arraylist-扩容机制\"> 3.2. 一步一步分析 ArrayList 扩容机制</h3>\n<p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h4 id=\"_3-2-1-先来看-add-方法\"> 3.2.1. 先来看 <code>add</code> 方法</h4>\n<div><pre><code>    <span>/**\n     * 将指定的元素追加到此列表的末尾。\n     */</span>\n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n   <span>//添加元素之前，先调用ensureCapacityInternal方法</span>\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>\n        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>\n<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>\n</blockquote>\n<h4 id=\"_3-2-2-再来看看-ensurecapacityinternal-方法\"> 3.2.2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h4>\n<p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<div><pre><code>   <span>//得到最小扩容量</span>\n    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>\n              <span>// 获取默认的容量和传入参数的较大值</span>\n            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>\n<blockquote>\n<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>\n</blockquote>\n<h4 id=\"_3-2-3-ensureexplicitcapacity-方法\"> 3.2.3. <code>ensureExplicitCapacity()</code> 方法</h4>\n<p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p>\n<div><pre><code>  <span>//判断是否需要扩容</span>\n    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        modCount<span>++</span><span>;</span>\n\n        <span>// overflow-conscious code</span>\n        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>\n            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>\n            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>\n<h4 id=\"_3-2-4-grow-方法\"> 3.2.4. <code>grow()</code> 方法</h4>\n<div><pre><code>    <span>/**\n     * 要分配的最大数组大小\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>\n\n    <span>/**\n     * ArrayList扩容的核心方法。\n     */</span>\n    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>// oldCapacity为旧容量，newCapacity为新容量</span>\n        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>\n        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>\n        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>\n        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>\n        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> minCapacity<span>;</span>\n       <span>// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>\n       <span>//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>\n        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>\n            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>// minCapacity is usually close to size, so this is a win:</span>\n        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>\n<blockquote>\n<p>&quot;&gt;&gt;&quot;（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>\n<ul>\n<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>\n<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h4 id=\"_3-2-5-hugecapacity-方法。\"> 3.2.5. <code>hugeCapacity()</code> 方法。</h4>\n<p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<div><pre><code>    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>\n        <span>//对minCapacity和MAX_ARRAY_SIZE进行比较</span>\n        <span>//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>\n        <span>//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>\n        <span>//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>\n        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>\n            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>\n            MAX_ARRAY_SIZE<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-3-system-arraycopy-和-arrays-copyof-方法\"> 3.3. <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h3>\n<p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h4 id=\"_3-3-1-system-arraycopy-方法\"> 3.3.1. <code>System.arraycopy()</code> 方法</h4>\n<div><pre><code>    <span>/**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */</span>\n    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>\n        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>\n\n        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>\n        <span>//arraycopy()方法实现数组自己复制自己</span>\n        <span>//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>\n        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>\n        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n        size<span>++</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们写一个简单的方法测试以下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ArraycopyTest</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>// TODO Auto-generated method stub</span>\n\t\t<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>\n\t\ta<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n\t\ta<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>\n\t\ta<span>[</span><span>3</span><span>]</span> <span>=</span> <span>3</span><span>;</span>\n\t\t<span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>2</span><span>,</span> a<span>,</span> <span>3</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span><span>=</span><span>99</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>a<span>[</span>i<span>]</span> <span>+</span> <span>\" \"</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>\n<div><pre><code>0 1 99 2 3 0 0 0 0 0\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_3-3-2-arrays-copyof-方法\"> 3.3.2. <code>Arrays.copyOf()</code>方法</h4>\n<div><pre><code>   <span>/**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n     */</span>\n    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>\n    <span>//elementData：要复制的数组；size：要复制的长度</span>\n        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ArrayscopyOfTest</span> <span>{</span>\n\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>3</span><span>]</span><span>;</span>\n\t\ta<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n\t\ta<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n\t\ta<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>\n\t\t<span>int</span><span>[</span><span>]</span> b <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> <span>10</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b.length\"</span><span>+</span>b<span>.</span>length<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>结果：</p>\n<div><pre><code>10\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_3-3-3-两者联系和区别\"> 3.3.3. 两者联系和区别</h4>\n<p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h3 id=\"_3-4-ensurecapacity方法\"> 3.4. <code>ensureCapacity</code>方法</h3>\n<p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<div><pre><code>    <span>/**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */</span>\n    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>\n        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>\n            <span>// any size if not default element table</span>\n            <span>?</span> <span>0</span>\n            <span>// larger than default for default empty table. It's already</span>\n            <span>// supposed to be at default size.</span>\n            <span>:</span> DEFAULT_CAPACITY<span>;</span>\n\n        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>\n            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t\t<span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t\t<span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n\t\t<span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n\t\t\tlist<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法前：\"</span><span>+</span><span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>\n\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>运行结果：</p>\n<div><pre><code>使用ensureCapacity方法前：2158\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>\n        list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>long</span> startTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        list<span>.</span><span>ensureCapacity</span><span>(</span><span>N</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>long</span> endTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"使用ensureCapacity方法后：\"</span><span>+</span><span>(</span>endTime1 <span>-</span> startTime1<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>运行结果：</p>\n<div><pre><code>使用ensureCapacity方法前：1773\n</code></pre>\n<div><span>1</span><br></div></div><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>\n",
      "date_published": "2022-03-03T13:05:45.000Z",
      "date_modified": "2022-03-03T13:05:45.000Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "1、简介",
      "url": "https://fmiles.cn/java/collection/map/TreeMap/",
      "id": "https://fmiles.cn/java/collection/map/TreeMap/",
      "content_html": "<h4 id=\"_1、简介\"> 1、简介</h4>\n<blockquote>\n<ul>\n<li>\n<p>TreeMap实现了NavigableMap接⼝，⽽NavigableMap接⼝继承着SortedMap接⼝，致使我们的<strong>TreeMap</strong>是有序的！</p>\n</li>\n<li>\n<p>TreeMap底层是红⿊树，它⽅法的时间复杂度都不会太⾼:log(n)~</p>\n</li>\n<li>\n<p>⾮同步</p>\n</li>\n<li>\n<p>使⽤Comparator或者Comparable来⽐较key是否相等与排序的问题~</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h4 id=\"_2、概览\"> 2、概览</h4>\n<p>NavigableMap 接口声明了一些列具有导航功能的方法.</p>\n<div><pre><code><span>/**\n * 返回红黑树中最小键所对应的 Entry\n */</span>\n<span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>firstEntry</span><span>(</span><span>)</span><span>;</span>\n\n<span>/**\n * 返回最大的键 maxKey，且 maxKey 仅小于参数 key\n */</span>\n<span>K</span> <span>lowerKey</span><span>(</span><span>K</span> key<span>)</span><span>;</span>\n\n<span>/**\n * 返回最小的键 minKey，且 minKey 仅大于参数 key\n */</span>\n<span>K</span> <span>higherKey</span><span>(</span><span>K</span> key<span>)</span><span>;</span>\n\n<span>// 其他略</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>通过这些导航方法，我们可以快速定位到目标的 key 或 Entry。至于 SortedMap 接口，这个接口提供了一些基于有序键的操作，比如</p>\n<div><pre><code><span>/**\n * 返回包含键值在 [minKey, toKey) 范围内的 Map\n */</span>\n<span>SortedMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>headMap</span><span>(</span><span>K</span> toKey<span>)</span><span>;</span><span>(</span><span>)</span><span>;</span>\n\n<span>/**\n * 返回包含键值在 [fromKey, toKey) 范围内的 Map\n */</span>\n<span>SortedMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>subMap</span><span>(</span><span>K</span> fromKey<span>,</span> <span>K</span> toKey<span>)</span><span>;</span>\n\n<span>// 其他略</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>红-黑树的主要规则如下：</p>\n<p>​    <strong>1.每个节点不是红色就是黑色的；</strong></p>\n<p>​    <strong>2.根节点总是黑色的；</strong></p>\n<p>​    <strong>3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</strong></p>\n<p>​    <strong>4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</strong></p>\n<hr>\n<h4 id=\"_3、源码分析\"> 3、源码分析</h4>\n<p>每个元素就是树节点</p>\n<p><img src=\"./image-20210121174445346.png\" alt=\"image-20210121174445346\" loading=\"lazy\"></p>\n<h5 id=\"_3、1-构造方法\"> 3、1 构造方法</h5>\n<div><pre><code><span>public</span> <span>TreeMap</span><span>(</span><span>)</span> <span>{</span>\n    comparator <span>=</span> <span>null</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>TreeMap</span><span>(</span><span>Comparator</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>K</span><span>></span></span> comparator<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>comparator <span>=</span> comparator<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>TreeMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>\n    comparator <span>=</span> <span>null</span><span>;</span>\n    <span>// 将 map 转为 treeMap，底层调用到还是 buildFromSorted()</span>\n    <span>putAll</span><span>(</span>m<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>TreeMap</span><span>(</span><span>SortedMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>\n    comparator <span>=</span> m<span>.</span><span>comparator</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>// 将 sortMap 转为 treeMap</span>\n        <span>buildFromSorted</span><span>(</span>m<span>.</span><span>size</span><span>(</span><span>)</span><span>,</span> m<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span><span>java<span>.</span>io<span>.</span></span>IOException</span> cannotHappen<span>)</span> <span>{</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> cannotHappen<span>)</span> <span>{</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>​\t\t可见，TreeMap的构造⽅法⼤多数与comparator有关。也就是说TreeMap有序是通过Comparator来进⾏⽐较的，如果<strong>comparator</strong>为<strong>null</strong>，那么就使⽤⾃然顺序。</p>\n<h5 id=\"_3、1-插入\"> 3、1 插入</h5>\n<p>​\t\t如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；但是遇到如下三种情况时，我们就要开始变色和旋转了：</p>\n<p>​    1. 插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的；</p>\n<p>​    2. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点；</p>\n<p>​    3. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。</p>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> t <span>=</span> root<span>;</span>\n    <span>/*根节点为空，创建树*/</span>\n    <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>compare</span><span>(</span>key<span>,</span> key<span>)</span><span>;</span> <span>// type (and possibly null) check</span>\n\n        root <span>=</span> <span>new</span> <span>Entry</span><span><span>&lt;</span><span>></span></span><span>(</span>key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n        size <span>=</span> <span>1</span><span>;</span>\n        modCount<span>++</span><span>;</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n    <span>int</span> cmp<span>;</span>\n    <span>// 用来向下搜索的</span>\n    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> parent<span>;</span>\n    <span>Comparator</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>K</span><span>></span></span> cpr <span>=</span> comparator<span>;</span>\n    <span>/*找到插入的位置*/</span>\n    <span>if</span> <span>(</span>cpr <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>do</span> <span>{</span>\n            parent <span>=</span> t<span>;</span>\n            cmp <span>=</span> cpr<span>.</span><span>compare</span><span>(</span>key<span>,</span> t<span>.</span>key<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>\n                t <span>=</span> t<span>.</span>left<span>;</span>\n            <span>else</span> <span>if</span> <span>(</span>cmp <span>></span> <span>0</span><span>)</span>\n                t <span>=</span> t<span>.</span>right<span>;</span>\n            <span>else</span>\n                <span>return</span> t<span>.</span><span>setValue</span><span>(</span>value<span>)</span><span>;</span>\n        <span>}</span> <span>while</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>else</span> <span>{</span>\n        <span>if</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>\n        <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n        <span>Comparable</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>K</span><span>></span></span> k <span>=</span> <span>(</span><span>Comparable</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>K</span><span>></span></span><span>)</span> key<span>;</span>\n        <span>do</span> <span>{</span>\n            parent <span>=</span> t<span>;</span>\n            cmp <span>=</span> k<span>.</span><span>compareTo</span><span>(</span>t<span>.</span>key<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>\n                t <span>=</span> t<span>.</span>left<span>;</span>\n            <span>else</span> <span>if</span> <span>(</span>cmp <span>></span> <span>0</span><span>)</span>\n                t <span>=</span> t<span>.</span>right<span>;</span>\n            <span>else</span>\n                <span>return</span> t<span>.</span><span>setValue</span><span>(</span>value<span>)</span><span>;</span>\n        <span>}</span> <span>while</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> <span>new</span> <span>Entry</span><span><span>&lt;</span><span>></span></span><span>(</span>key<span>,</span> value<span>,</span> parent<span>)</span><span>;</span>\n    <span>/*插入左节点或者右节点*/</span>\n    <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span>\n        parent<span>.</span>left <span>=</span> e<span>;</span>\n    <span>else</span>\n        parent<span>.</span>right <span>=</span> e<span>;</span>\n    <span>/*插入后修整二叉树*/</span>\n    <span>fixAfterInsertion</span><span>(</span>e<span>)</span><span>;</span>\n    size<span>++</span><span>;</span>\n    modCount<span>++</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\t\n\n<span>/** From CLR */</span>\n<span>private</span> <span>void</span> <span>fixAfterInsertion</span><span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> x<span>)</span> <span>{</span>\n    <span>// 默认插入节点都是红色</span>\n    x<span>.</span>color <span>=</span> RED<span>;</span>\n\t<span>// 父节点不为空且为红色才需要修整，黑色父节点不违反红黑树规则</span>\n    <span>while</span> <span>(</span>x <span>!=</span> <span>null</span> <span>&amp;&amp;</span> x <span>!=</span> root <span>&amp;&amp;</span> x<span>.</span>parent<span>.</span>color <span>==</span> RED<span>)</span> <span>{</span>\n        <span>// 当前节点的父节点为祖父节点的左节点</span>\n        <span>if</span> <span>(</span><span>parentOf</span><span>(</span>x<span>)</span> <span>==</span> <span>leftOf</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> y <span>=</span> <span>rightOf</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>/*1、叔叔节点是红色，即父亲叔叔节点都为红色*/</span>\n            <span>if</span> <span>(</span><span>colorOf</span><span>(</span>y<span>)</span> <span>==</span> RED<span>)</span> <span>{</span>\n                <span>// 父亲，叔叔节点颜色变黑，祖父变红</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span>y<span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>,</span> RED<span>)</span><span>;</span>\n                <span>// 当前节点调整为祖父节点，循环向上</span>\n                x <span>=</span> <span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>/*2、插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右节点*/</span>\n                <span>// 当前插入节点是父节点的右节点</span>\n                <span>if</span> <span>(</span>x <span>==</span> <span>rightOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span> <span>{</span>\n                    <span>// 当前节点设置为父节点</span>\n                    x <span>=</span> <span>parentOf</span><span>(</span>x<span>)</span><span>;</span>\n                    <span>// 左旋（左旋完后，当前节点的位置同时左旋了）</span>\n                    <span>rotateLeft</span><span>(</span>x<span>)</span><span>;</span>\n                <span>}</span>\n\t\t\t   <span>/*3、插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点*/</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>,</span> RED<span>)</span><span>;</span>\n                <span>// 右旋</span>\n                <span>rotateRight</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> y <span>=</span> <span>leftOf</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>colorOf</span><span>(</span>y<span>)</span> <span>==</span> RED<span>)</span> <span>{</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span>y<span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>,</span> RED<span>)</span><span>;</span>\n                x <span>=</span> <span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>if</span> <span>(</span>x <span>==</span> <span>leftOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span> <span>{</span>\n                    x <span>=</span> <span>parentOf</span><span>(</span>x<span>)</span><span>;</span>\n                    <span>rotateRight</span><span>(</span>x<span>)</span><span>;</span>\n                <span>}</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>,</span> RED<span>)</span><span>;</span>\n                <span>rotateLeft</span><span>(</span><span>parentOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    root<span>.</span>color <span>=</span> BLACK<span>;</span>\n<span>}</span>\n\n<span>/** From CLR */</span>\n<span>private</span> <span>void</span> <span>rotateLeft</span><span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>p <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> r <span>=</span> p<span>.</span>right<span>;</span>\n        <span>// 当前节点右节点的左节点，旋转为当前节点的右节点</span>\n        p<span>.</span>right <span>=</span> r<span>.</span>left<span>;</span>\n        <span>if</span> <span>(</span>r<span>.</span>left <span>!=</span> <span>null</span><span>)</span>\n            <span>// 当前节点右节点的左节点父节点变为当前节点</span>\n            r<span>.</span>left<span>.</span>parent <span>=</span> p<span>;</span>\n        <span>//当前节点右节点的父节点变为当前节点的父节点</span>\n        r<span>.</span>parent <span>=</span> p<span>.</span>parent<span>;</span>\n        <span>if</span> <span>(</span>p<span>.</span>parent <span>==</span> <span>null</span><span>)</span>\n            root <span>=</span> r<span>;</span>\n        <span>// 把当前节点的右节点作为父节点的左子节点或右子节点</span>\n        <span>else</span> <span>if</span> <span>(</span>p<span>.</span>parent<span>.</span>left <span>==</span> p<span>)</span>\n            p<span>.</span>parent<span>.</span>left <span>=</span> r<span>;</span>\n        <span>else</span>\n            p<span>.</span>parent<span>.</span>right <span>=</span> r<span>;</span>\n        <span>// 当前节点变为当前节点右节点的左节点</span>\n        r<span>.</span>left <span>=</span> p<span>;</span>\n        <span>// 当前节点右节点变为当前节点的父节点</span>\n        p<span>.</span>parent <span>=</span> r<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>/** From CLR */</span>\n<span>private</span> <span>void</span> <span>rotateRight</span><span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>p <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> l <span>=</span> p<span>.</span>left<span>;</span>\n        p<span>.</span>left <span>=</span> l<span>.</span>right<span>;</span>\n        <span>if</span> <span>(</span>l<span>.</span>right <span>!=</span> <span>null</span><span>)</span> l<span>.</span>right<span>.</span>parent <span>=</span> p<span>;</span>\n        l<span>.</span>parent <span>=</span> p<span>.</span>parent<span>;</span>\n        <span>if</span> <span>(</span>p<span>.</span>parent <span>==</span> <span>null</span><span>)</span>\n            root <span>=</span> l<span>;</span>\n        <span>else</span> <span>if</span> <span>(</span>p<span>.</span>parent<span>.</span>right <span>==</span> p<span>)</span>\n            p<span>.</span>parent<span>.</span>right <span>=</span> l<span>;</span>\n        <span>else</span> p<span>.</span>parent<span>.</span>left <span>=</span> l<span>;</span>\n        l<span>.</span>right <span>=</span> p<span>;</span>\n        p<span>.</span>parent <span>=</span> l<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br></div></div><h5 id=\"_3、2-删除\"> 3、2 删除</h5>\n<div><pre><code><span>// 删除方法本身只会替换原有的值</span>\n<span>public</span> <span>V</span> <span>remove</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>// 获取要删除的节点</span>\n    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p <span>=</span> <span>getEntry</span><span>(</span>key<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>p <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>null</span><span>;</span>\n\n    <span>V</span> oldValue <span>=</span> p<span>.</span>value<span>;</span>\n    <span>deleteEntry</span><span>(</span>p<span>)</span><span>;</span>\n    <span>return</span> oldValue<span>;</span>\n<span>}</span>\n\n\n<span>/**\n真正的删除方法\n*/</span>\n<span>private</span> <span>void</span> <span>deleteEntry</span><span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>)</span> <span>{</span>\n    modCount<span>++</span><span>;</span>\n    size<span>--</span><span>;</span>\n\n    <span>if</span> <span>(</span>p<span>.</span>left <span>!=</span> <span>null</span> <span>&amp;&amp;</span> p<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> s <span>=</span> <span>successor</span><span>(</span>p<span>)</span><span>;</span>\n        <span>// 用最小节点去替换掉要删除的当前节点。</span>\n        p<span>.</span>key <span>=</span> s<span>.</span>key<span>;</span>\n        p<span>.</span>value <span>=</span> s<span>.</span>value<span>;</span>\n        p <span>=</span> s<span>;</span>\n    <span>}</span>\n\n\t<span>/*\n\t1、在左右节点都不为空的情况下，p节点是当前节点的右节点的最左节点，这里 replacement=p.right\n\t2、在左右节点中某个节点为空或者是叶子节点的时候，\n\t*/</span>\n    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> replacement <span>=</span> <span>(</span>p<span>.</span>left <span>!=</span> <span>null</span> <span>?</span> p<span>.</span>left <span>:</span> p<span>.</span>right<span>)</span><span>;</span>\n\n    <span>// 情况1：replacement 为最左节点的右节点。此时 p == p.parent.left，因为只会是左节点</span>\n    <span>if</span> <span>(</span>replacement <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        replacement<span>.</span>parent <span>=</span> p<span>.</span>parent<span>;</span>\n        <span>if</span> <span>(</span>p<span>.</span>parent <span>==</span> <span>null</span><span>)</span>\n            <span>// p 就是root节点</span>\n            root <span>=</span> replacement<span>;</span>\n        <span>else</span> <span>if</span> <span>(</span>p <span>==</span> p<span>.</span>parent<span>.</span>left<span>)</span>\n            <span>// p节点的右子节点挂在其父节点的左子节点</span>\n            p<span>.</span>parent<span>.</span>left  <span>=</span> replacement<span>;</span>\n        <span>else</span>\n            p<span>.</span>parent<span>.</span>right <span>=</span> replacement<span>;</span>\n\n\t\t<span>// 删除节点</span>\n        p<span>.</span>left <span>=</span> p<span>.</span>right <span>=</span> p<span>.</span>parent <span>=</span> <span>null</span><span>;</span>\n\n        <span>// Fix replacement</span>\n        <span>if</span> <span>(</span>p<span>.</span>color <span>==</span> BLACK<span>)</span>\n            <span>fixAfterDeletion</span><span>(</span>replacement<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>p<span>.</span>parent <span>==</span> <span>null</span><span>)</span> <span>{</span>\n       \t<span>// 删除的是根节点</span>\n        root <span>=</span> <span>null</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span> \n        <span>/*删除的是叶子节点*/</span>\n        <span>// 删除节点是黑色的</span>\n        <span>if</span> <span>(</span>p<span>.</span>color <span>==</span> BLACK<span>)</span>\n            <span>fixAfterDeletion</span><span>(</span>p<span>)</span><span>;</span>\n\t\t<span>// 删除父节点的左或者右子节点</span>\n        <span>if</span> <span>(</span>p<span>.</span>parent <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>p <span>==</span> p<span>.</span>parent<span>.</span>left<span>)</span>\n                p<span>.</span>parent<span>.</span>left <span>=</span> <span>null</span><span>;</span>\n            <span>else</span> <span>if</span> <span>(</span>p <span>==</span> p<span>.</span>parent<span>.</span>right<span>)</span>\n                p<span>.</span>parent<span>.</span>right <span>=</span> <span>null</span><span>;</span>\n            p<span>.</span>parent <span>=</span> <span>null</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n\n<span>/**\n获取后续节点。和删除搜索树的节点一样，从右节点开始，寻找到当前节点的右节点的最左节点\n*/</span>\n<span>static</span> <span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>TreeMap<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>successor</span><span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> t<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>else</span> <span>if</span> <span>(</span>t<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 寻找指定节点的右子节点的最左节点</span>\n        <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p <span>=</span> t<span>.</span>right<span>;</span>\n        <span>while</span> <span>(</span>p<span>.</span>left <span>!=</span> <span>null</span><span>)</span>\n            p <span>=</span> p<span>.</span>left<span>;</span>\n        <span>return</span> p<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>// 这里应该是传入的是叶子节点，找到右节点的最高的父节点</span>\n        <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p <span>=</span> t<span>.</span>parent<span>;</span>\n        <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> ch <span>=</span> t<span>;</span>\n        <span>while</span> <span>(</span>p <span>!=</span> <span>null</span> <span>&amp;&amp;</span> ch <span>==</span> p<span>.</span>right<span>)</span> <span>{</span>\n            ch <span>=</span> p<span>;</span>\n            p <span>=</span> p<span>.</span>parent<span>;</span>\n        <span>}</span>\n        <span>return</span> p<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n\n<span>/**\n删除后修整\n*/</span>\n<span>private</span> <span>void</span> <span>fixAfterDeletion</span><span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> x<span>)</span> <span>{</span>\n    <span>// 删除的节点不是根节点且是黑色的才需要调整</span>\n    <span>while</span> <span>(</span>x <span>!=</span> root <span>&amp;&amp;</span> <span>colorOf</span><span>(</span>x<span>)</span> <span>==</span> BLACK<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>x <span>==</span> <span>leftOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> sib <span>=</span> <span>rightOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n\n            <span>if</span> <span>(</span><span>colorOf</span><span>(</span>sib<span>)</span> <span>==</span> RED<span>)</span> <span>{</span>\n                <span>setColor</span><span>(</span>sib<span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> RED<span>)</span><span>;</span>\n                <span>rotateLeft</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n                sib <span>=</span> <span>rightOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>if</span> <span>(</span><span>colorOf</span><span>(</span><span>leftOf</span><span>(</span>sib<span>)</span><span>)</span>  <span>==</span> BLACK <span>&amp;&amp;</span>\n                <span>colorOf</span><span>(</span><span>rightOf</span><span>(</span>sib<span>)</span><span>)</span> <span>==</span> BLACK<span>)</span> <span>{</span>\n                <span>setColor</span><span>(</span>sib<span>,</span> RED<span>)</span><span>;</span>\n                x <span>=</span> <span>parentOf</span><span>(</span>x<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>if</span> <span>(</span><span>colorOf</span><span>(</span><span>rightOf</span><span>(</span>sib<span>)</span><span>)</span> <span>==</span> BLACK<span>)</span> <span>{</span>\n                    <span>setColor</span><span>(</span><span>leftOf</span><span>(</span>sib<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                    <span>setColor</span><span>(</span>sib<span>,</span> RED<span>)</span><span>;</span>\n                    <span>rotateRight</span><span>(</span>sib<span>)</span><span>;</span>\n                    sib <span>=</span> <span>rightOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>setColor</span><span>(</span>sib<span>,</span> <span>colorOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>rightOf</span><span>(</span>sib<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>rotateLeft</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n                x <span>=</span> root<span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span> <span>// symmetric</span>\n            <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> sib <span>=</span> <span>leftOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n\n            <span>if</span> <span>(</span><span>colorOf</span><span>(</span>sib<span>)</span> <span>==</span> RED<span>)</span> <span>{</span>\n                <span>setColor</span><span>(</span>sib<span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> RED<span>)</span><span>;</span>\n                <span>rotateRight</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n                sib <span>=</span> <span>leftOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>if</span> <span>(</span><span>colorOf</span><span>(</span><span>rightOf</span><span>(</span>sib<span>)</span><span>)</span> <span>==</span> BLACK <span>&amp;&amp;</span>\n                <span>colorOf</span><span>(</span><span>leftOf</span><span>(</span>sib<span>)</span><span>)</span> <span>==</span> BLACK<span>)</span> <span>{</span>\n                <span>setColor</span><span>(</span>sib<span>,</span> RED<span>)</span><span>;</span>\n                x <span>=</span> <span>parentOf</span><span>(</span>x<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>if</span> <span>(</span><span>colorOf</span><span>(</span><span>leftOf</span><span>(</span>sib<span>)</span><span>)</span> <span>==</span> BLACK<span>)</span> <span>{</span>\n                    <span>setColor</span><span>(</span><span>rightOf</span><span>(</span>sib<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                    <span>setColor</span><span>(</span>sib<span>,</span> RED<span>)</span><span>;</span>\n                    <span>rotateLeft</span><span>(</span>sib<span>)</span><span>;</span>\n                    sib <span>=</span> <span>leftOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>setColor</span><span>(</span>sib<span>,</span> <span>colorOf</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>setColor</span><span>(</span><span>leftOf</span><span>(</span>sib<span>)</span><span>,</span> BLACK<span>)</span><span>;</span>\n                <span>rotateRight</span><span>(</span><span>parentOf</span><span>(</span>x<span>)</span><span>)</span><span>;</span>\n                x <span>=</span> root<span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\t<span>// 否则的话，直接把此节点变黑即可</span>\n    <span>setColor</span><span>(</span>x<span>,</span> BLACK<span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br></div></div><div><pre><code>\t删除操作后，如果当前节点是黑色的根节点，那么不用任何操作，因为并没有破坏树的平衡性，即没有违背红-黑树的规则。如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。但是如果遇到以下四种情况，我们就需要通过变色或旋转来恢复红-黑树的平衡了。\n</code></pre>\n</div><p>​    1. 当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</p>\n<p>​    2. 当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</p>\n<p>​    3. 当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</p>\n<p>​    4. 当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。</p>\n",
      "date_modified": "2022-04-29T06:23:43.088Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "LinkedHashMap",
      "url": "https://fmiles.cn/java/collection/map/readeMe/",
      "id": "https://fmiles.cn/java/collection/map/readeMe/",
      "content_html": "<h5 id=\"linkedhashmap\"> LinkedHashMap</h5>\n<p><img src=\"./image-20210119154934255.png\" alt=\"image-20210119154934255\" loading=\"lazy\"></p>\n<h5 id=\"treemap\"> TreeMap</h5>\n<p><img src=\"./image-20210121161343287.png\" alt=\"image-20210121161343287\" loading=\"lazy\"></p>\n",
      "date_modified": "2022-04-29T06:23:43.088Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "核心思想",
      "url": "https://fmiles.cn/java/concurrent/CAS/",
      "id": "https://fmiles.cn/java/concurrent/CAS/",
      "content_html": "<h2 id=\"核心思想\"> 核心思想</h2>\n<p>CAS(A,V,B)。当前值 A，内存值 V，要修改的新值 B。如果当前值 A = V，那么就将内存值 V 改成 B。</p>\n<p>CAS 操作总是抱着乐观的态度的，它总是认为自己可以成功完成操作。当多个线程同时操作一个变量时，只有一个会胜出并成功更新，其余均会失败，失败的线程不会挂起，仅是被告知失败，并且云允许再次尝试。</p>\n<h2 id=\"原子操作\"> 原子操作</h2>\n<p>为了能让 CAS 操作被 Java 应用程序充分使用，在 JDK 的 java.util.concurrent.atomic 包下，有一组使用无锁算法实现的原子操作类。</p>\n<img src=\"images/image-20220404195924674.png\" alt=\"image-20220404195924674\" style=\"zoom:80%;\" />\n<p>利用CPU的 CAS 指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而<strong>整个J.U.C都是建立在CAS之上的</strong>，因此相比synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p>\n<p>以 AtomicInteger 为 getAndSet() 方法为例，看下 CAS 算法如何工作的：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>getAndSet</span><span>(</span><span>int</span> newValue<span>)</span> <span>{</span>\n    <span>return</span> unsafe<span>.</span><span>getAndSetInt</span><span>(</span><span>this</span><span>,</span> valueOffset<span>,</span> newValue<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>调用的是 unsafe 类的 getAndSetInt() 方法</p>\n<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>getAndSetInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span> <span>int</span> newValue<span>)</span> <span>{</span>\n    <span>int</span> v<span>;</span>\n    <span>do</span> <span>{</span>\n        v <span>=</span> <span>getIntVolatile</span><span>(</span>o<span>,</span> offset<span>)</span><span>;</span>\n    <span>}</span> <span>while</span> <span>(</span><span>!</span><span>compareAndSwapInt</span><span>(</span>o<span>,</span> offset<span>,</span> v<span>,</span> newValue<span>)</span><span>)</span><span>;</span>\n    <span>return</span> v<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>UnSafe 类是 CAS 的核心类由于 Java 方法无法直接访问底层，需要通过本地(native)方法来访问，基于该类可以直接操作特额定的内存数据.UnSafe类在于 sun.misc 包中，其内部方法操作可以向 C 的指针一样直接操作内存,因为 Java 中 CAS 操作的助兴依赖于 UNSafe 类的方法。</p>\n<h2 id=\"cas-存在的问题\"> CAS 存在的问题</h2>\n<h3 id=\"_1、aba-问题\"> 1、ABA 问题</h3>\n<ul>\n<li>描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。</li>\n<li>例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！</li>\n</ul>\n<h5 id=\"解决办法\"> 解决办法：</h5>\n<p>JDK1.5 可以利用 AtomicStampedReference 类来解决这个问题，AtomicStampedReference 内部不仅维护了对象值，还维护了一个时间戳。当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳，对象值和时间戳都必须满足期望值，写入才会成功</p>\n<h3 id=\"_2、循环时间长开销大-这里应该是自旋锁的问题-自旋锁和-cas-是两种东西\"> <strong>2、循环时间长开销大</strong>（这里应该是自旋锁的问题？自旋锁和 CAS 是两种东西）</h3>\n<p>因为CAS 经常和自旋锁一起使用。看上面的 getAndSetInt() 法方法可知，自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>\n<p>解决办法：JVM支持处理器提供的pause指令，使得效率会有一定的提升，pause指令有两个作用：</p>\n<p>第一它可以延迟流水线执行指令,使CPU不会消耗过多的执行资源，\n第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>\n<h3 id=\"_3、不能保证多个共享变量的原子操作\"> 3、不能保证多个共享变量的原子操作</h3>\n<p>问题描述：当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>\n<p>解决办法：从Java1.5 开始JDK提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p>\n<h2 id=\"concurrent-包的实现\"> concurrent 包的实现</h2>\n<p>由于 java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面四种方式：</p>\n<ul>\n<li>A线程写 volatile 变量，随后 B 线程读这个 volatile 变量。</li>\n<li>A线程写 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li>\n<li>A线程用 CAS 更新一个 volatile 变量，随后 B 线程读这个 volatile 变量。</li>\n<li>A线程用 CAS 更新一个 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li>\n</ul>\n<p>Java 的 CAS 会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile 变量的读/写和 CAS 可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent 包得以实现的基石。如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p>\n<ul>\n<li>首先，声明共享变量为 volatile；</li>\n<li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li>\n<li>同时，配合以 volatile 的读/写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。</li>\n</ul>\n<p><strong>AQS</strong>，<strong>非阻塞数据结构</strong>和<strong>原子变量类</strong>（java.util.concurrent.atomic包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p>\n<p><img src=\"./images/2019063014391960.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>注：AQS（AbstractQueuedSynchronizer抽象队列同步器），提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架。</p>\n<p>https://blog.csdn.net/lixinkuan328/article/details/94319775</p>\n",
      "date_modified": "2022-04-29T06:23:43.089Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "JAVA内存模型",
      "url": "https://fmiles.cn/java/concurrent/JMM/",
      "id": "https://fmiles.cn/java/concurrent/JMM/",
      "content_html": "<p>https://www.jianshu.com/p/8a58d8335270</p>\n<h2 id=\"java内存模型是什么\"> JAVA内存模型是什么</h2>\n<p>与单行程序相比，并发程序还必须额外处理一个问题，那就是多线程数据的访问一致性。一旦出现多个线程访问某个变量的值不一致的情况，系统就可能发生一些莫名其妙的问题，因此，在进行多线程程序设计时，必须考徐这种情况。Java 内存模型(JMM) 就是用来解释并规范这种情况的，将这种看似随机的状态变为可控，从而屏蔽多线程间可能引发的种种问题。</p>\n<h5 id=\"大致示例图\"> 大致示例图：</h5>\n<p><img src=\"./images/v2-3d312429710bd6a11eca171858f67751_720w.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<h4 id=\"jvm-对-java-内存模型的实现\"> JVM 对 Java 内存模型的实现</h4>\n<p>在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区。</p>\n<p><img src=\"./images/4222138-1cc1cd7e5e09232c.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>![1577451710876](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\底层原理\\1577451710876.png?lastModify=1649170185)</p>\n<p>volatile 保证立即刷新属性到内存中，但是他不能保证线程安全，只是让所有的线程接收到某个共同的值的变化</p>\n<p><img src=\"./images/{FB5F063F-CE53-F064-1C8B-626B8C12F9CA}.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<h2 id=\"内存模型的基本原则\"> 内存模型的基本原则</h2>\n<h3 id=\"一、原子性\"> 一、原子性</h3>\n<h4 id=\"问题描述\"> 问题描述：</h4>\n<p>原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。譬如，对 int 和 byte 等数据的赋值操作就具备基本的原子特性。在32 位操作系统中，对于 long 和 double 的赋值操作，由于这两长度为 64 位，无法一次操作，因此对于它们的操作都不是原子的。</p>\n<h4 id=\"解决方案\"> 解决方案：</h4>\n<ul>\n<li><strong>volatile + 加锁</strong></li>\n<li><strong>使用原子类</strong></li>\n</ul>\n<h3 id=\"二、有序性\"> 二、有序性</h3>\n<h4 id=\"问题描述-2\"> 问题描述：</h4>\n<p>现代 CPU 都支持指令流水执行。为了保证流水线的顺畅执行，在指令执行时，有可能会对目标指令进行重排。重排不会导致单线程中的语义修改，但会导致多线程中的语义出现不一致。即，在一个线程中观察另外一个线程的操作，会发现被观察的指令顺序和预期情况不符。</p>\n<h4 id=\"解决方案-2\"> 解决方案：</h4>\n<ul>\n<li>解决有序性的一个简单方法就是 synchronized ，从代码执行的角度来说，一个线程 A 进行了指令重排，但是执行以后，线程 B 无法进入只有线程 A 释放锁，线程 B 才得以进入，因此无论线程 A 的指令执行顺序如何，线程 B 都会看到相同的最终结果。</li>\n<li><strong>volatile</strong></li>\n</ul>\n<p>内存屏障，禁止指令重排。（具体原理看 volatitle）</p>\n<h3 id=\"三、可见性\"> 三、可见性</h3>\n<h4 id=\"_1、问题描述\"> 1、问题描述：</h4>\n<p>指的是当一个线程修改了一个变量的值，在另外一个线程中可以马上得知这个修改。另外，由于系统编译器优化，部分变量的值可能会被寄存器或告诉缓冲 (Cache)缓存，而每个 CPU 都有独立的寄存器和 Cache，从而导致其他线程无法立即发现这个修改。</p>\n<h5 id=\"示例代码\"> 示例代码：</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>VolatileExample</span> <span>{</span>\n    <span>/**\n     * main 方法作为一个主线程\n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>MyThread</span> myThread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>\n        <span>// 开启线程</span>\n        myThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>// 主线程执行</span>\n        <span>for</span> <span>(</span><span>;</span> <span>;</span> <span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>myThread<span>.</span><span>isFlag</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"主线程访问到 flag 变量\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n\n<span>/**\n * 子线程类\n */</span>\n<span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>\n\n    <span>private</span> <span>boolean</span> flag <span>=</span> <span>false</span><span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 修改变量值</span>\n        flag <span>=</span> <span>true</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"flag = \"</span> <span>+</span> flag<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>boolean</span> <span>isFlag</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> flag<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>执行上面的程序，你会发现，控制台永远都不会输出 <strong>“主线程访问到 flag 变量”</strong> 这句话。我们可以看到，子线程执行时已经将 flag 设置成 true，但主线程执行时没有读到 flag 的最新值，导致控制台没有输出上面的句子。</p>\n<h4 id=\"_2、解决方案\"> 2、解决方案：</h4>\n<ul>\n<li><strong>加锁</strong></li>\n</ul>\n<p>因为当一个线程进入 synchronized 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。</p>\n<p>这里除了 synchronized 外，其它锁也能保证变量的内存可见性。</p>\n<ul>\n<li><strong>volatile</strong>   （具体原理看 volatitle）</li>\n</ul>\n<p>使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 <strong>CPU 总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。</p>\n<h4 id=\"四、happens-before-原则\"> 四、Happens-Before 原则</h4>\n<p>虽然虚拟机和执行系统会指令进行一定的重排，但是指令重排是有原则的，并非所有的指令都可以随意更改执行位置。</p>\n<p>happens-before 规则如下：</p>\n<ul>\n<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>\n<li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li>\n<li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li>\n<li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li>\n<li>start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。</li>\n<li>join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。</li>\n</ul>\n",
      "date_modified": "2022-04-29T06:23:43.089Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "基础",
      "url": "https://fmiles.cn/java/concurrent/JMM02/",
      "id": "https://fmiles.cn/java/concurrent/JMM02/",
      "content_html": "<h2 id=\"基础\"> 基础</h2>\n<h3 id=\"内存模型\"> 内存模型</h3>\n<p>在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（就是可见性和有序性）。</p>\n<p>在 java 中，所有实例域、静态域和数组元素存储在堆内存张中，堆内存在线程之间共享（这里使用“共享变量”这个词代表实例域、静态域和数组元素）。局部变量，方法定义参数和异常处理参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型影响。</p>\n<p><img src=\"./images/image-20220405214102872.png\" alt=\"image-20220405214102872\" loading=\"lazy\"></p>\n<p>注意：本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>\n<h3 id=\"重排序\"> 重排序</h3>\n<p>一般重排序可以分为如下三种类型：</p>\n<ul>\n<li>编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>\n<li>指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n<li>内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\n</ul>\n<blockquote>\n<p>数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>\n</blockquote>\n<p>从 Java 源代码到最终执行的指令序列，会分别经历下面三种重排序：</p>\n<p><img src=\"./images/v2-8655d85c8a9df1bc2262485248b07d4d_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"内存屏障\"> 内存屏障</h3>\n<p>为了保证内存的可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排。JMM 把内存屏障指令分为下列四类：</p>\n<p>![preview](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\concurrent\\images\\v2-a992d2e50fc353edb9027683bf62ee2b_r.jpg?lastModify=1649166928)</p>\n<h3 id=\"happens-before\"> happens-before</h3>\n<p>从 JDK 5 开始，java使用新的 JSR-133 内存模型，JSR-133 中使用 happens-before 的概念阐述操作之间的内存可见性。</p>\n<p>happens-before 规则如下：</p>\n<ul>\n<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>\n<li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li>\n<li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li>\n<li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li>\n<li>start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。</li>\n<li>join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。</li>\n</ul>\n<p>这里特别说明一下，happens-before 规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则。</p>\n<h2 id=\"重排序-2\"> 重排序</h2>\n<h3 id=\"数据依赖性\"> 数据依赖性</h3>\n<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就有数据依赖性。</p>\n<p><img src=\"./images/image-20220405220044994.png\" alt=\"image-20220405220044994\" loading=\"lazy\"></p>\n<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>\n<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>\n<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>\n<h3 id=\"as-if-serial-语义\"> as-if-serial 语义</h3>\n<p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>\n<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>\n<h2 id=\"顺序一致性\"> 顺序一致性</h2>\n<h3 id=\"顺序一致性内存模型\"> 顺序一致性内存模型</h3>\n<p>顺序一致性内存模型为程序员提供的视图如下：</p>\n<img src=\"images/4987a0c005023fbbab06293aa2c36da5.png\" alt=\"img\" style=\"zoom:80%;\" />\n<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读 / 写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 / 写操作串行化。</p>\n<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>\n<p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B 线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p>\n<p>假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：</p>\n<p><img src=\"https://static001.infoq.cn/resource/image/a2/df/a2be3cbfb19fa8854510e708a65e31df.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p>\n<p><img src=\"https://static001.infoq.cn/resource/image/4f/13/4f5afaac60fff83522424ed5486f0d13.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"同步程序的顺序一致性效果\"> 同步程序的顺序一致性效果</h3>\n<p>下面我们对前面的示例程序 ReorderExample 用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>\n<p>请看下面的示例代码：</p>\n<p><img src=\"https://static001.infoq.cn/resource/image/08/10/08b2577f293533447511fe3724ecbd10.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>\n<h2 id=\"volatile\"> VOLATILE</h2>\n<p>当我们声明共享变量为 volatile 后，对这个变量的读 / 写将会很特别。理解 volatile 特性的一个好方法是：把对 volatile 变量的单个读 / 写，看成是使用同一个监视器锁对这些单个读 / 写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p>\n<div><pre><code><span>class</span> <span>VolatileFeaturesExample</span> <span>{</span>\n    <span>volatile</span> <span>long</span> vl <span>=</span> <span>0L</span><span>;</span>  <span>// 使用 volatile 声明 64 位的 long 型变量</span>\n\n    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>long</span> l<span>)</span> <span>{</span>\n        vl <span>=</span> l<span>;</span>   <span>// 单个 volatile 变量的写</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> getAndIncrement <span>(</span><span>)</span> <span>{</span>\n        vl<span>++</span><span>;</span>    <span>// 复合（多个）volatile 变量的读 / 写</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>long</span> <span>get</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> vl<span>;</span>   <span>// 单个 volatile 变量的读</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>\n<div><pre><code><span>class</span> <span>VolatileFeaturesExample</span> <span>{</span>\n    <span>long</span> vl <span>=</span> <span>0L</span><span>;</span>               <span>// 64 位的 long 型普通变量</span>\n\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>set</span><span>(</span><span>long</span> l<span>)</span> <span>{</span>     <span>// 对单个的普通 变量的写用同一个监视器同步</span>\n        vl <span>=</span> l<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> getAndIncrement <span>(</span><span>)</span> <span>{</span> <span>// 普通方法调用</span>\n        <span>long</span> temp <span>=</span> <span>get</span><span>(</span><span>)</span><span>;</span>           <span>// 调用已同步的读方法</span>\n        temp <span>+=</span> <span>1L</span><span>;</span>                  <span>// 普通写操作</span>\n        <span>set</span><span>(</span>temp<span>)</span><span>;</span>                   <span>// 调用已同步的写方法</span>\n    <span>}</span>\n    <span>public</span> <span>synchronized</span> <span>long</span> <span>get</span><span>(</span><span>)</span> <span>{</span> \n        <span>// 对单个的普通变量的读用同一个监视器同步</span>\n        <span>return</span> vl<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如上面示例程序所示，对一个 volatile 变量的单个读 / 写操作，与对一个普通变量的读 / 写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>\n<p>监视器锁的 happens-before 规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</p>\n<p>监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。</p>\n<p>简而言之，volatile 变量自身具有下列特性：</p>\n<ul>\n<li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li>\n<li>原子性：对任意单个 volatile 变量的读 / 写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li>\n</ul>\n<h3 id=\"volatile-写-读建立的-happens-before-关系\"> volatile 写 - 读建立的 happens before 关系</h3>\n<p>从 JSR-133 开始，volatile 变量的写 - 读可以实现线程之间的通信。</p>\n<p>从内存语义的角度来说，volatile 与监视器锁有相同的效果：volatile 写和监视器的释放有相同的内存语义；volatile 读与监视器的获取有相同的内存语义。锁？？</p>\n<p>请看下面使用 volatile 变量的示例代码：</p>\n<div><pre><code><span>class</span> <span>VolatileExample</span> <span>{</span>\n    <span>int</span> a <span>=</span> <span>0</span><span>;</span>\n    <span>volatile</span> <span>boolean</span> flag <span>=</span> <span>false</span><span>;</span>\n\n    <span>public</span> <span>void</span> <span>writer</span><span>(</span><span>)</span> <span>{</span>\n        a <span>=</span> <span>1</span><span>;</span>                   <span>//1</span>\n        flag <span>=</span> <span>true</span><span>;</span>               <span>//2</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>reader</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>flag<span>)</span> <span>{</span>                <span>//3</span>\n            <span>int</span> i <span>=</span>  a<span>;</span>           <span>//4</span>\n            ……\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>假设线程 A 执行 writer() 方法之后，线程 B 执行 reader() 方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：</p>\n<ol>\n<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>\n<li>根据 volatile 规则，2 happens before 3。</li>\n<li>根据 happens before 的传递性规则，1 happens before 4。</li>\n</ol>\n<p>上述 happens before 关系的图形化表现形式如下：</p>\n<p><img src=\"https://static001.infoq.cn/resource/image/31/5a/3104638509c2c1b898c5e249cb30065a.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。</p>\n<p>这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写 volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。</p>\n<h3 id=\"volatile-写-读的内存语义\"> volatile 写 - 读的内存语义</h3>\n<p>volatile 写的内存语义如下：</p>\n<ul>\n<li>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。</li>\n</ul>\n<p>以上面示例程序 VolatileExample 为例，假设线程 A 首先执行 writer() 方法，随后线程 B 执行 reader() 方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：</p>\n<p><img src=\"https://static001.infoq.cn/resource/image/43/ea/43e1cc4e89fdfd06eaa1c74d54f538ea.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。</p>\n<p>volatile 读的内存语义如下：</p>\n<ul>\n<li>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>\n</ul>\n<p>下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：</p>\n<p><img src=\"https://static001.infoq.cn/resource/image/08/32/0804d2efc97e45360eab1f76f9962c32.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>如上图所示，在读 flag 变量后，本地内存 B 已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。</p>\n<p>如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。</p>\n<p>下面对 volatile 写和 volatile 读的内存语义做个总结：</p>\n<ul>\n<li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。</li>\n<li>线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。</li>\n<li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li>\n</ul>\n<h3 id=\"volatile-内存语义的实现\"> volatile 内存语义的实现</h3>\n<p>下面，让我们来看看 JMM 如何实现 volatile 写 / 读的内存语义。</p>\n<p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现 volatile 内存语义，JMM 会分别限制这两种类型的重排序类型。下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XAJq0GoNog70w9POicKfKJYRWOUyiaGicmHb2djKeIfUNOHOnWic7v3iaxrnKV8QlDCC9cQN9Jqt6q1f6g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\" loading=\"lazy\"></p>\n<ul>\n<li>第二个操作是volatile写时，第一个操作不管是什么，都不能重排序</li>\n<li>第一个操作是volatile读时，第二个操作不管是什么，都不能重排序</li>\n<li>第一个操作是volatile是写，第二个操作是volatile是读，不能重排序</li>\n</ul>\n<p>JMM内存屏障插入策略：（Load：加载（读）、Store：保存（写），屏障名称就可以看出读写的先后顺序）</p>\n<ul>\n<li>在每个volatile写操作前插入StroreStore屏障</li>\n<li>在每个volatile写操作前插入StroreLoad屏障</li>\n<li>在每个volatile读操作前插入LoadLoad屏障</li>\n<li>在每个volatile读操作前插入LoadStore屏障</li>\n</ul>\n<h2 id=\"锁\"> 锁</h2>\n<h2 id=\"final\"> FINAL</h2>\n",
      "date_modified": "2022-04-29T06:23:43.091Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "LongAddr 是什么",
      "url": "https://fmiles.cn/java/concurrent/LongAddr/",
      "id": "https://fmiles.cn/java/concurrent/LongAddr/",
      "content_html": "<h2 id=\"longaddr-是什么\"> LongAddr 是什么</h2>\n<p>无锁的原子操作使用系统的 CAS 指令，有着远超锁的性能，那能否在性能上更上一层楼？可以，在 JDK 1.8 中引入的 LongAddr 类。LongAdder在高并发的场景下会比它的前辈————AtomicLong 具有更好的性能，代价是消耗更多的内存空间。</p>\n<h2 id=\"longaddr-能做什么\"> LongAddr 能做什么</h2>\n<p>在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时 AtomicLong 的自旋会成为瓶颈。</p>\n<p>这就是LongAdder引入的初衷——解决高并发环境下 AtomicLong 的自旋瓶颈问题。</p>\n<h2 id=\"核心思想\"> 核心思想</h2>\n<p>对传统 AtomicInteger 等原子类的改进思路，仿照 ConcurrentHashMap，将热点数据分离。比如可以将 AtomicInteger 的内部核心数据 value 分离成一个数组，每个线程访问时，通过 hash 等算法映射到其中一个数字进行计算，而最终的计算结果，则为这个数组的求和累加，如下图，现实了这种优化思路，</p>\n<p><img src=\"./images/image-20220404211502473.png\" alt=\"image-20220404211502473\" loading=\"lazy\"></p>\n<p>其中，热点数据 value 被分离成多个单元 cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样就进行了有效的分离，提高了并行度。LongAddr 正是使用了这种思想。</p>\n<h2 id=\"原理\"> 原理</h2>\n<p>LongAdder 的原理是，在最初无竞争时，只更新 base 的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的 LongAdder 存储的值。</p>\n<img src=\"images/912032-20200519161720575-1114918493.png\" alt=\"img\" style=\"zoom:80%;\" />\n<p>AtomicLong的如图：</p>\n<img src=\"images/912032-20200519164010859-570667642.png\" alt=\"img\" style=\"zoom:50%;\" />\n<p>LongAdder的如图：</p>\n<img src=\"images/912032-20200519164027703-34034425.png\" alt=\"img\" style=\"zoom: 67%;\" />\n<p>AtomicLong是多个线程针对单个热点值value进行原子操作。而LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作。</p>\n<p>LongAdder继承自Striped64抽象类，Striped64中定义了Cell内部类和各重要属性。</p>\n<h4 id=\"代码示例\"> 代码示例：</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>LongAdderVSAtomicLongTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>testAtomicLongVSLongAdder</span><span>(</span><span>1</span><span>,</span> <span>10000000</span><span>)</span><span>;</span>\n        <span>testAtomicLongVSLongAdder</span><span>(</span><span>10</span><span>,</span> <span>10000000</span><span>)</span><span>;</span>\n        <span>testAtomicLongVSLongAdder</span><span>(</span><span>20</span><span>,</span> <span>10000000</span><span>)</span><span>;</span>\n        <span>testAtomicLongVSLongAdder</span><span>(</span><span>40</span><span>,</span> <span>10000000</span><span>)</span><span>;</span>\n        <span>testAtomicLongVSLongAdder</span><span>(</span><span>80</span><span>,</span> <span>10000000</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>static</span> <span>void</span> <span>testAtomicLongVSLongAdder</span><span>(</span><span>final</span> <span>int</span> threadCount<span>,</span> <span>final</span> <span>int</span> times<span>)</span><span>{</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"threadCount：\"</span> <span>+</span> threadCount <span>+</span> <span>\", times：\"</span> <span>+</span> times<span>)</span><span>;</span>\n            <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n            <span>testLongAdder</span><span>(</span>threadCount<span>,</span> times<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"LongAdder elapse：\"</span> <span>+</span> <span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> start<span>)</span> <span>+</span> <span>\"ms\"</span><span>)</span><span>;</span>\n\n            <span>long</span> start2 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n            <span>testAtomicLong</span><span>(</span>threadCount<span>,</span> times<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AtomicLong elapse：\"</span> <span>+</span> <span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> start2<span>)</span> <span>+</span> <span>\"ms\"</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>void</span> <span>testAtomicLong</span><span>(</span><span>final</span> <span>int</span> threadCount<span>,</span> <span>final</span> <span>int</span> times<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>AtomicLong</span> atomicLong <span>=</span> <span>new</span> <span>AtomicLong</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>Thread</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>threadCount<span>;</span>i<span>++</span><span>)</span><span>{</span>\n            list<span>.</span><span>add</span><span>(</span><span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j<span>&lt;</span>times<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                    atomicLong<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>for</span> <span>(</span><span>Thread</span> thread <span>:</span> list<span>)</span><span>{</span>\n            thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>for</span> <span>(</span><span>Thread</span> thread <span>:</span> list<span>)</span><span>{</span>\n            thread<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>void</span> <span>testLongAdder</span><span>(</span><span>final</span> <span>int</span> threadCount<span>,</span> <span>final</span> <span>int</span> times<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>LongAdder</span> longAdder <span>=</span> <span>new</span> <span>LongAdder</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>Thread</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>threadCount<span>;</span>i<span>++</span><span>)</span><span>{</span>\n            list<span>.</span><span>add</span><span>(</span><span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j<span>&lt;</span>times<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                    longAdder<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>for</span> <span>(</span><span>Thread</span> thread <span>:</span> list<span>)</span><span>{</span>\n            thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>for</span> <span>(</span><span>Thread</span> thread <span>:</span> list<span>)</span><span>{</span>\n            thread<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h3 id=\"总结\"> 总结：</h3>\n<p>（1）LongAdder通过base和cells数组来存储值；</p>\n<p>（2）不同的线程会hash到不同的cell上去更新，减少了竞争；</p>\n<p>（3）LongAdder的性能非常高，最终会达到一种无竞争的状态；</p>\n",
      "date_modified": "2022-04-29T06:23:43.091Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍",
      "url": "https://fmiles.cn/java/concurrent/ThreadLocal/",
      "id": "https://fmiles.cn/java/concurrent/ThreadLocal/",
      "content_html": "<h2 id=\"介绍\"> 介绍</h2>\n<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>\n<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p>\n<p>再举个简单的例子：</p>\n<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>\n<h5 id=\"示例\"> 示例：</h5>\n<div><pre><code><span>package</span> <span>test</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>ThreadLocalTest</span> <span>{</span>\n\n    <span>static</span> <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> localVar <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>static</span> <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> localVar2 <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>static</span> <span>void</span> <span>print</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>\n        <span>//打印当前线程中本地内存中本地变量的值</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>+</span> <span>\" :\"</span> <span>+</span> localVar<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>+</span> <span>\" :\"</span> <span>+</span> localVar2<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//清除本地内存中的本地变量</span>\n        localVar<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Thread</span> t1  <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>//设置线程1中本地变量的值</span>\n                localVar<span>.</span><span>set</span><span>(</span><span>\"thread1-localVar1\"</span><span>)</span><span>;</span>\n                localVar2<span>.</span><span>set</span><span>(</span><span>\"thread1-localVar2\"</span><span>)</span><span>;</span>\n                <span>//调用打印方法</span>\n                <span>print</span><span>(</span><span>\"thread1\"</span><span>)</span><span>;</span>\n                <span>//打印本地变量</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after remove : \"</span> <span>+</span> localVar<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        <span>Thread</span> t2  <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>//设置线程1中本地变量的值</span>\n                localVar<span>.</span><span>set</span><span>(</span><span>\"thread2-localVar1\"</span><span>)</span><span>;</span>\n                localVar2<span>.</span><span>set</span><span>(</span><span>\"thread2-localVar2\"</span><span>)</span><span>;</span>\n                <span>//调用打印方法</span>\n                <span>print</span><span>(</span><span>\"thread2\"</span><span>)</span><span>;</span>\n                <span>//打印本地变量</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after remove : \"</span> <span>+</span> localVar<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>结果：</p>\n<div><pre><code>thread1 <span>:</span>thread1<span>-</span>localVar1\nthread1 <span>:</span>thread1<span>-</span>localVar2\nthread2 <span>:</span>thread2<span>-</span>localVar1\nthread2 <span>:</span>thread2<span>-</span>localVar2\nafter remove <span>:</span> <span>null</span>\nafter remove <span>:</span> <span>null</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"原理\"> 原理</h2>\n<p>从 <code>Thread</code>类源代码入手</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Thread</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>//......</span>\n    <span>//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span>\n    <span>ThreadLocal<span>.</span>ThreadLocalMap</span> threadLocals <span>=</span> <span>null</span><span>;</span>\n\n    <span>//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span>\n    <span>ThreadLocal<span>.</span>ThreadLocalMap</span> inheritableThreadLocals <span>=</span> <span>null</span><span>;</span>\n    <span>//......</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它。</p>\n<h4 id=\"threadlocalmap\"> ThreadLocalMap</h4>\n<p>查看源码可知，ThreadLocalMap 是 ThreadLocal 的内部类。但是在 ThreadLocal 中，并没实现Map接口。</p>\n<p>在 ThreadLoalMap 中，也是初始化一个大小 16 的 Entry 数组，Entry 对象用来保存每一个 key-value 键值对，只不过这里的 key 永远都是ThreadLocal 对象，是不是很神奇，通过 ThreadLocal 对象的 set 方法，结果把 <em>ThreadLocal 对象自己当做 key</em>，放进了 ThreadLoalMap 中（注意这里，ThreadLocal 拿到的是线程本身的 ThreadLoalMap，但是 key 值是 ThreadLoalMap 自己）</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadLocal</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>// ThreadLocalMap</span>\n    <span>static</span> <span>class</span> <span>ThreadLocalMap</span> <span>{</span>\n\n        <span>private</span> <span>Entry</span><span>[</span><span>]</span> table<span>;</span>\n\n        <span>// 这里 Entry 没有next 指针，不是链表</span>\n        <span>static</span> <span>class</span> <span>Entry</span> <span>extends</span> <span>WeakReference</span><span><span>&lt;</span><span>ThreadLocal</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>{</span>\n            <span>/** The value associated with this ThreadLocal. */</span>\n            <span>Object</span> value<span>;</span>\n\n            <span>Entry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k<span>,</span> <span>Object</span> v<span>)</span> <span>{</span>\n                <span>super</span><span>(</span>k<span>)</span><span>;</span>\n                value <span>=</span> v<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n\n    <span>// ThreadLocal get 方法</span>\n    <span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>\n        <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n        <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span> <span>// 这里 getMap 就是拿当前线程的 ThreadLocalMap</span>\n        <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>ThreadLocalMap<span>.</span>Entry</span> e <span>=</span> map<span>.</span><span>getEntry</span><span>(</span><span>this</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n                <span>T</span> result <span>=</span> <span>(</span><span>T</span><span>)</span>e<span>.</span>value<span>;</span>\n                <span>return</span> result<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>setInitialValue</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>\n        <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n        <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span>\n            map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>\n        <span>else</span>\n            <span>createMap</span><span>(</span>t<span>,</span> value<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 获取 Thread 类的 threadLocals。</span>\n    <span>ThreadLocalMap</span> <span>getMap</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>\n        <span>return</span> t<span>.</span>threadLocals<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>这里需要注意的是，ThreadLoalMap的Entry是继承WeakReference，和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况了。</p>\n<h5 id=\"结构如下\"> 结构如下：</h5>\n<img src=\"https://javaguide.cn/assets/threadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom:80%;\" />\n<p>ThreadLocal1，ThreadLocal2 表示这些线程都有两个 ThreadLocal。</p>\n<p>1、threadLocalMap 和 Thread 是一一对应的，即每个线程内有一个 threadLocalMap。</p>\n<p>2、一个 ThreadLocal 只能维护一个线程的一个 Entry，线程可创建多个 ThreadLocal。</p>\n<p>3、多个线程共用一个 thredlocal，thredlocal 里面为每一个线程创建了一个单独的 thredlocalmap。所以当线程调用 thredloccal.get()/set() 方法时,会根据当前线程提取或写入线程对应的内部 thredlocalmap，这样就完成了线程之间的隔离数据存储。</p>\n<h2 id=\"threadlocal-内存泄露问题\"> ThreadLocal 内存泄露问题</h2>\n<p>什么叫内存泄漏，对应的什么叫内存溢出</p>\n<ul>\n<li>Memory overflow:内存溢出，没有足够的内存提供申请者使用。</li>\n<li>Memory leak:内存泄漏，程序申请内存后，无法释放已申请的内存空间，内存泄漏的堆积终将导致内存溢出。</li>\n</ul>\n<h4 id=\"弱引用的回收机制\"> 弱引用的回收机制</h4>\n<img src=\"https://img-blog.csdnimg.cn/img_convert/c6812f84bf1efdd0ff4c02a46ed59809.png\" alt=\"c6812f84bf1efdd0ff4c02a46ed59809.png\" style=\"zoom:80%;\" />\n<p>这一种存在强引用不会被回收。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e3bcda8df2cd820a91868abad29e5a4d.png\" alt=\"e3bcda8df2cd820a91868abad29e5a4d.png\" loading=\"lazy\"></p>\n<p>这里没有强引用将会被回收。</p>\n<h4 id=\"threadlocal-的内存泄漏\"> ThreadLocal 的内存泄漏</h4>\n<div><pre><code><span>static</span> <span>class</span> <span>Entry</span> <span>extends</span> <span>WeakReference</span><span><span>&lt;</span><span>ThreadLocal</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>{</span>\n    <span>/** The value associated with this ThreadLocal. */</span>\n    <span>Object</span> value<span>;</span>\n\n    <span>Entry</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>?</span><span>></span></span> k<span>,</span> <span>Object</span> v<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>k<span>)</span><span>;</span>\n        value <span>=</span> v<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>当使用 ThreadLocal  保存一个 value 时，会在 ThreadLocalMap 中的数组插入一个 Entry 对象，按理说 key-value 都应该以强引用保存在 Entry 对象中，但在 ThreadLocalMap 的实现中，key 被保存到了 WeakReference 对象中。</p>\n<p>这就导致了一个问题，ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，如果创建 ThreadLocal 的线程一直持续运行，那么这个 Entry 对象中的 value 就有可能一直得不到回收，发生内存泄露。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/cc134a429b37e7065db1a5bb6a7a0ebb.png\" alt=\"cc134a429b37e7065db1a5bb6a7a0ebb.png\" loading=\"lazy\"></p>\n<p>如上图所示，我们在作为 key 的 ThreadLocal 对象没有外部强引用，下一次 gc 必将产生 key 值为 null 的数据，若线程没有及时结束必然出现，一条强引用链<code>Threadref</code>–&gt;<code>Thread</code>–&gt;<code>ThreadLocalMap</code>–&gt;<code>Entry</code>，所以这将导致内存泄漏。</p>\n<h4 id=\"为什么设计成-key-是弱引用-value-是强引用\"> 为什么设计成 key 是弱引用，value 是强引用？</h4>\n<p>由于线程池复用导致，一方面咱们又希望尽可能的复用线程，另一方面咱们又希望不需要手动去清理 threadlocal 因为咱们不知道线程什么时候结束。</p>\n<p>通俗点说，就是 ThreadLocalRef 出栈后，因为线程池想复用，这个线程在一直运行，所以 ThreadRef 一直存在于栈中。这时候如果 ThreadLocal 是个强引用，那么这个 Entry 中 value 对象是一直没办法被回收的。而设计成弱引用，就是为了让 gc 的时候，把 ThreadLocal 变为 null。但是 key 为 null 的时候，如上图所示，引用链一直存在，有可能会导致内存泄漏，因此 threadLocalMap 中调用 <code>set()</code>、<code>get()</code>、<code>remove()</code>  方法时候都会先清理 key 为 null 的记录。</p>\n<h4 id=\"解决办法\"> 解决办法</h4>\n<p>threadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>\n<div><pre><code><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> localName <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span>\n<span>try</span> <span>{</span>\n    localName<span>.</span><span>set</span><span>(</span><span>\"占小狼\"</span><span>)</span><span>;</span>\n    <span>// 其它业务逻辑</span>\n<span>}</span> <span>finally</span> <span>{</span>\n    localName<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"inheritablethreadlocal\"> InheritableThreadLocal</h2>\n<p>InheritableThreadLocal继承了ThreadLocal类，get、set方法用的都是父类的方法，只是重写了getMap和createMap</p>\n<div><pre><code><span>ThreadLocalMap</span> <span>getMap</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>\n   <span>return</span> t<span>.</span>inheritableThreadLocals<span>;</span>\n<span>}</span>\n \n<span>void</span> <span>createMap</span><span>(</span><span>Thread</span> t<span>,</span> <span>T</span> firstValue<span>)</span> <span>{</span>\n    t<span>.</span>inheritableThreadLocals <span>=</span> <span>new</span> <span>ThreadLocalMap</span><span>(</span><span>this</span><span>,</span> firstValue<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"为什么-interitablethreadlocal-可以获取到父线程的值\"> 为什么 InteritableThreadLocal 可以获取到父线程的值?</h5>\n<p>Thread 创建的时候，init() 方法中会把父线程的 inheritableThreadLocals 赋值给子线程，从而实现了父子线程变量传递</p>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/e3bcda8df2cd820a91868abad29e5a4d.png",
      "date_modified": "2022-04-29T06:23:43.095Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "Unsafe类介绍",
      "url": "https://fmiles.cn/java/concurrent/Unsafe/",
      "id": "https://fmiles.cn/java/concurrent/Unsafe/",
      "content_html": "<h2 id=\"unsafe类介绍\"> <strong>Unsafe类介绍</strong></h2>\n<p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Oracle正在计划从Java 9中去掉Unsafe类，如果真是如此影响就太大了。</p>\n<h2 id=\"unsafe的主要功能\"> <strong>Unsafe的主要功能</strong></h2>\n<p>我们先来看看Unsafe的初始化方法，这是一个单例模式：</p>\n<div><pre><code><span>private</span> <span>Unsafe</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>private</span> <span>static</span> <span>final</span> <span>Unsafe</span> theUnsafe <span>=</span> <span>new</span> <span>Unsafe</span><span>(</span><span>)</span><span>;</span>\n<span>public</span> <span>static</span> <span>Unsafe</span> <span>getUnsafe</span><span>(</span><span>)</span> <span>{</span>\n    <span>Class</span> cc <span>=</span> <span><span>sun<span>.</span>reflect<span>.</span></span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>2</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>cc<span>.</span><span>getClassLoader</span><span>(</span><span>)</span> <span>!=</span> <span>null</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>SecurityException</span><span>(</span><span>\"Unsafe\"</span><span>)</span><span>;</span>\n    <span>return</span> theUnsafe<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>方法中，限制了它的 ClassLoader，如果这个方法的调用实例不是由Boot ClassLoader加载的，则会报错。所以，正常情况下开发者无法直接使用Unsafe ，如果需要使用它，则需要利用反射：</p>\n<div><pre><code><span>private</span> static Unsafe <span>getUnsafe</span><span>(</span><span>)</span><span>{</span>\n    <span>try</span> <span>{</span>\n        Field field <span>=</span> Unsafe<span>.</span>class<span>.</span><span>getDeclaredField</span><span>(</span><span><span>\"theUnsafe\"</span></span><span>)</span><span>;</span>  <span>// 因为在 unsafe 类中，这个字段就叫 theUnsafe</span>\n        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        Unsafe unsafe <span>=</span> <span>(</span>Unsafe<span>)</span> field<span>.</span><span>get</span><span>(</span><span>null</span><span>)</span><span>;</span>\n        <span>return</span> unsafe<span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span>Exception e<span>)</span> <span>{</span>\n        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>从 Unsafe 的方法入手，发现 Unsafe 主要有以下几个方面的功能：</p>\n<ul>\n<li>操纵对象属性</li>\n<li>操纵数组元素</li>\n<li>线程挂起与恢复、CAS</li>\n</ul>\n<h4 id=\"_1-操纵对象属性\"> <strong>1 操纵对象属性</strong></h4>\n<p>操纵对象属性，主要落在这个方法上：</p>\n<div><pre><code><span>public</span> <span>native</span> <span>long</span> <span>objectFieldOffset</span><span>(</span><span>Field</span> f<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>通过此方法，可以获取对象中某个属性的内存偏移地址，然后可根据偏移地址直接对属性进行修改，属性是否可读都无所谓，都能修改。</p>\n<div><pre><code><span>Field</span> name <span>=</span> user<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n<span><span>long</span></span> nameOffset <span>=</span> <span>unsafe</span><span>.</span><span>objectFieldOffset</span><span>(</span>name<span>)</span><span>;</span>\n<span>unsafe</span><span>.</span><span>putObject</span><span>(</span>user<span>,</span> nameOffset<span>,</span> <span>\"jim\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_2-操作数组元素\"> <strong>2 操作数组元素</strong></h4>\n<p>操纵数组元素，主要涉及两个接口。</p>\n<div><pre><code><span>public</span> <span>native</span> <span>int</span> <span>arrayBaseOffset</span><span>(</span><span>Class</span> arrayClass<span>)</span><span>;</span>\n<span>public</span> <span>native</span> <span>int</span> <span>arrayIndexScale</span><span>(</span><span>Class</span> arrayClass<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>arrayBaseOffset，获取数组第一个元素的偏移地址。arrayIndexScale，获取数组中元素的增量地址。arrayBaseOffset与arrayIndexScale配合起来使用，就可以定位数组中每个元素在内存中的位置</p>\n<p>索引为 i 的元素可以使用如下代码定位：</p>\n<div><pre><code><span>int</span> baseOffset <span>=</span> unsafe<span>.</span><span>arrayBaseOffset</span><span>(</span>array<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>int</span> indexScale <span>=</span> unsafe<span>.</span><span>arrayIndexScale</span><span>(</span>array<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\nbaseOffset <span>+</span> i<span>*</span>indexScale\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在ReentrantLock的源码中我又发现了一种新的元素定位方式：</p>\n<div><pre><code><span>int</span> ssfit <span>=</span> <span>31</span> <span>-</span> Integer<span>.</span><span>numberOfLeadingZeros</span><span>(</span>indexScale<span>)</span><span>;</span>\n<span>(</span>i <span>&lt;&lt;</span> ssfit<span>)</span> <span>+</span> baseOffset\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>查看Integer的源码，发现 numberOfLeadingZeros 方法里注释如下：\nfloor(log2(x)) = 31 - numberOfLeadingZeros(x)</p>\n<p>如果这是一个int型数组，indexScale 等于4，那么 ssfit 值为2，所以乘以4和向左移2位，结果是一样的。</p>\n<p>不过第1种方法比较容易理解。想象下，这是在c语言中，如果已知数组第1个元素指针，每个元素占用的字节数也已知，那么计算其它元素的位置就和第1种方法是一样的。</p>\n<div><pre><code><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> array<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>//unsafe.putInt(array, baseOffset + i*indexScale, i);</span>\n            unsafe<span>.</span><span>putInt</span><span>(</span>array<span>,</span> <span>(</span>i <span>&lt;&lt;</span> ssfit<span>)</span> <span>+</span> baseOffset<span>,</span> i<span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>所以，通过如上代码就可以更改数组的元素了。</p>\n<h4 id=\"_3-线程挂起与恢复、cas\"> <strong>3 线程挂起与恢复、CAS</strong></h4>\n<p>如果我们使用 ReentrantLock 进行多线程开发，当一个线程抢占锁失败时，线程将被挂起，实现线程挂起的正是 Unsafe 类。</p>\n<p>将一个线程进行挂起是通过 park 方法实现的，调用 park 后，线程将一直阻塞直到超时或者中断等条件出现。unpark 可以终止一个挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在 LockSupport 类中，LockSupport 类中有各种版本 pack 方法，但最终都调用了Unsafe.park()方法。</p>\n<p>CAS，一种乐观锁机制，如果对象当前值和期望值一样，那么则将对象的值设置成新值。和悲观锁不一样，它不需要抢占锁，它是一种尝试性的，能有效地提高效率，它的全称是 compareAndSwap ，依赖于硬件的原子操作实现。</p>\n<h4 id=\"总结\"> <strong>总结</strong></h4>\n<p>之前也没有想过总结Unsafe类，不过在看 ConcurrentHashMap 源码时，涉及到 ReentrantLock 类，而 ReentrantLock 类中又涉及到了 Unsafe类，所以总结一下，现在全部打通关了，美滋滋。</p>\n<p>Unsafe类中，还有一些有意思的方法没有介绍了，比如 allocateInstance，调用此方法可以生成一个新对象，有意思的是，生成新对象时可以避过此对象的构造函数。即使是反射，最后也是要调用对象的构造函数的。所以Unsafe这个能力还是非常有意思的。</p>\n<p>https://www.jianshu.com/p/cda24891f9e4</p>\n",
      "date_modified": "2022-04-29T06:23:43.114Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "AQS前置知识",
      "url": "https://fmiles.cn/java/concurrent/locks/AQS%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/",
      "id": "https://fmiles.cn/java/concurrent/locks/AQS%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/",
      "content_html": "<h2 id=\"abstractqueuedsynchronizer\"> AbstractQueuedSynchronizer</h2>\n<p>重入锁(ReentrantLock) 和信号量(Semaphore)是两个极其重要的并发控制工具。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70760cab928a4d7a9af46c5513421c45~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\" loading=\"lazy\"></p>\n<p>可以看到， 重入锁和信号量都在自己内部，实现了一个 AbstractQueuedSynchronizer 的子类，子类的名字都是 Sync。而这个 Sync 类，也正是重入锁和信号量的核心实现。子类 Sync 中的代码也比较少，其核心算法都由 AbstractQueuedSynchronizer 提供。因此，可以说，只要大家了解了AbstractQueuedSynchronizer，就清楚得知道重入锁和信号量的实现原理了。</p>\n<h2 id=\"aqs-对资源的共享方式\"> AQS 对资源的共享方式</h2>\n<ul>\n<li>\n<h5 id=\"exclusive-独占\"> Exclusive（独占）</h5>\n</li>\n</ul>\n<p>只有一个线程能执行，如 ReentantLock，具体看 ReentrantLock。</p>\n<ul>\n<li>\n<h5 id=\"share-共享\"> Share （共享）</h5>\n</li>\n</ul>\n<p>多个线程可同时执行，如 <code>Semaphore/CountDownLatch</code>。<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code>。</p>\n<h2 id=\"前置知识\"> 前置知识</h2>\n<h4 id=\"基于许可的多线程控制\"> 基于许可的多线程控制</h4>\n<p>为了控制多个线程访问共享资源 ，我们需要为每个访问共享区间的线程派发一个许可。拿到一个许可的线程才能进入共享区间活动。当线程完成工作后，离开共享区间时，必须要归还许可，以确保后续的线程可以正常取得许可。如果许可用完了，那么线程进入共享区间时，就必须等待，这就是控制多线程并行的基本思想。</p>\n<h4 id=\"排他锁和共享锁\"> 排他锁和共享锁</h4>\n<p>第二个重要的概念就是排他锁(exclusive)和共享锁(shared)。顾名思义，在排他模式上，只有一个线程可以访问共享变量，而共享模式则允许多个线程同时访问。简单地说，重入锁是排他的；信号量是共享的。</p>\n<p>用摩天轮的话来说，排他锁就是虽然我这里有20个位置，但是小朋友也只能一个一个上哦，多出来的位置怎么办呢，可以空着，也可以让摩天轮上唯一的小孩换着做，他想坐哪儿就坐哪儿，1分钟换个位置，都没有关系。而共享锁，就是玩耍摩天轮正常的打开方式了。</p>\n<h4 id=\"locksupport\"> LockSupport</h4>\n<p>LockSupport 可以理解为一个工具类。它的作用很简单，就是挂起和继续执行线程。它的常用的 API 如下：</p>\n<ul>\n<li>public static void park() : 如果没有可用许可，则挂起当前线程。<em>注意：unpark 和 线程中断都可唤醒 park</em>。</li>\n<li>public static void unpark(Thread thread)：给 thread 一个可用的许可，让它得以继续执行</li>\n</ul>\n<p>因为单词 park 的意思就是停车，因此这里 park() 函数就表示让线程暂停。反之，unpark() 则表示让线程继续执行。</p>\n<p>需要注意的是，LockSupport本身也是基于许可的实现，如何理解这句话呢，请看下面的代码：</p>\n<div><pre><code><span>LockSupport</span><span>.</span><span>unpark</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>大家可以猜一下，park() 之后，当前线程是停止，还是可以继续执行呢？</p>\n<p>答案是：可以继续执行。那是因为在 park() 之前，先执行了 unpark()，进而释放了一个许可，也就是说当前线程有一个可用的许可。而 park() 在有可用许可的情况下，是不会阻塞线程的。</p>\n<p>综上所述，park() 和 unpark() 的执行效果和它调用的先后顺序没有关系。这一点相当重要，因为在一个多线程的环境中，我们往往很难保证函数调用的先后顺序(都在不同的线程中并发执行)，因此，这种基于许可的做法能够最大限度保证程序不出错。</p>\n<p>与 park() 和 unpark() 相比， 一个典型的反面教材就是 Thread.resume() 和 Thread.suspend()。</p>\n<p>看下面的代码：</p>\n<div><pre><code><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>resume</span><span>(</span><span>)</span><span>;</span>  <span>// 挂起的线程执行</span>\n<span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>suspend</span><span>(</span><span>)</span><span>;</span>  <span>// 挂起线程</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>首先让线程继续执行，接着在挂起线程。这个写法和上面的park()的示例非常接近，但是运行结果却是截然不同的。在这里，当前线程就是卡死。</p>\n<p>因此，使用park()和unpark()才是我们的首选。而在AbstractQueuedSynchronizer中，也正是使用了LockSupport的park()和unpark()操作来控制线程的运行状态的。</p>\n<h4 id=\"原理\"> 原理</h4>\n<p>LockSupport 就是通过控制变量 _counter 来对线程阻塞唤醒进行控制的。原理有点类似于信号量机制。</p>\n<blockquote>\n<p>当调用park()方法时，会将_counter置为0，同时判断前值，等于1说明前面被unpark过,则直接退出，否则将使该线程阻塞。</p>\n<p>当调用unpark()方法时，会将_counter置为1，同时判断前值，等于0会进行线程唤醒，否则直接退出。</p>\n</blockquote>\n<p>当先调用两次unpark()之后，那么<code>_counter</code> 值还是1，然后第一次调用<code>park()</code>，将<code>_counter</code>置为0，同时前值等于1,所以直接退出了，但是在第二次<code>park()</code>的时候，<code>_count</code>值是0，所以此时直接被阻塞了。</p>\n",
      "image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70760cab928a4d7a9af46c5513421c45~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp",
      "date_modified": "2022-04-29T06:23:43.115Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "Condition",
      "url": "https://fmiles.cn/java/concurrent/locks/Condition/",
      "id": "https://fmiles.cn/java/concurrent/locks/Condition/",
      "content_html": "<h2 id=\"condition\"> Condition</h2>\n<p>我们先来看看 Condition 的使用场景，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，请看 Doug Lea 给出的这个例子：</p>\n<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>locks<span>.</span></span><span>Condition</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>locks<span>.</span></span><span>Lock</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>locks<span>.</span></span><span>ReentrantLock</span><span>;</span>\n\n<span>class</span> <span>BoundedBuffer</span> <span>{</span>\n    <span>final</span> <span>Lock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n    <span>// condition 依赖于 lock 来产生</span>\n    <span>final</span> <span>Condition</span> notFull <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n    <span>final</span> <span>Condition</span> notEmpty <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n\n    <span>final</span> <span>Object</span><span>[</span><span>]</span> items <span>=</span> <span>new</span> <span>Object</span><span>[</span><span>100</span><span>]</span><span>;</span>\n    <span>int</span> putptr<span>,</span> takeptr<span>,</span> count<span>;</span>\n\n    <span>// 生产</span>\n    <span>public</span> <span>void</span> <span>put</span><span>(</span><span>Object</span> x<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>while</span> <span>(</span>count <span>==</span> items<span>.</span>length<span>)</span>\n                notFull<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>  <span>// 队列已满，等待，直到 not full 才能继续生产</span>\n            items<span>[</span>putptr<span>]</span> <span>=</span> x<span>;</span>\n            <span>if</span> <span>(</span><span>++</span>putptr <span>==</span> items<span>.</span>length<span>)</span> putptr <span>=</span> <span>0</span><span>;</span>\n            <span>++</span>count<span>;</span>\n            notEmpty<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span> <span>// 生产成功，队列已经 not empty 了，发个通知出去</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>// 消费</span>\n    <span>public</span> <span>Object</span> <span>take</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>while</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span>\n                notEmpty<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span> <span>// 队列为空，等待，直到队列 not empty，才能继续消费</span>\n            <span>Object</span> x <span>=</span> items<span>[</span>takeptr<span>]</span><span>;</span>\n            <span>if</span> <span>(</span><span>++</span>takeptr <span>==</span> items<span>.</span>length<span>)</span> takeptr <span>=</span> <span>0</span><span>;</span>\n            <span>--</span>count<span>;</span>\n            notFull<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span> <span>// 被我消费掉一个，队列 not full 了，发个通知出去</span>\n            <span>return</span> x<span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><blockquote>\n<p>1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 wait(), notify() 或 notifyAll() 方法。</p>\n<p>2、ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue</p>\n</blockquote>\n<p>在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock  的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。</p>\n<p>每个 ReentrantLock  实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p>\n<div><pre><code><span>final</span> <span>ConditionObject</span> <span>newCondition</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 实例化一个 ConditionObject</span>\n    <span>return</span> <span>new</span> <span>ConditionObject</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"conditionobject\"> ConditionObject</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>ConditionObject</span> <span>implements</span> <span>Condition</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>1173984872572414699L</span><span>;</span>\n        <span>// 条件队列的第一个节点</span>\n          <span>// 不要管这里的关键字 transient，是不参与序列化的意思</span>\n        <span>private</span> <span>transient</span> <span>Node</span> firstWaiter<span>;</span>\n        <span>// 条件队列的最后一个节点</span>\n        <span>private</span> <span>transient</span> <span>Node</span> lastWaiter<span>;</span>\n        <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在上一篇介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），我画了一张简单的图用来说明这个。</p>\n<blockquote>\n<p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。</p>\n</blockquote>\n<p><img src=\"./images/aqs2-2.png\" alt=\"condition-2\" loading=\"lazy\"></p>\n<p>基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p>\n<ol>\n<li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；</li>\n<li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li>\n<li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li>\n<li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li>\n</ol>\n<h2 id=\"原理\"> 原理</h2>\n<h3 id=\"线程等待-await\"> 线程等待 await()</h3>\n<div><pre><code><span>// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span>\n<span>// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span>\n<span>public</span> <span>final</span> <span>void</span> <span>await</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>// 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态</span>\n    <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 添加到 condition 的条件队列中</span>\n    <span>Node</span> node <span>=</span> <span>addConditionWaiter</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 释放锁，返回值是释放锁之前的 state 值</span>\n    <span>// await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span>\n    <span>int</span> savedState <span>=</span> <span>fullyRelease</span><span>(</span>node<span>)</span><span>;</span>\n\n    <span>int</span> interruptMode <span>=</span> <span>0</span><span>;</span>\n    <span>// 这里退出循环有两种情况，之后再仔细分析</span>\n    <span>// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span>\n    <span>// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span>\n    <span>while</span> <span>(</span><span>!</span><span>isOnSyncQueue</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>\n        <span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>interruptMode <span>=</span> <span>checkInterruptWhileWaiting</span><span>(</span>node<span>)</span><span>)</span> <span>!=</span> <span>0</span><span>)</span>\n            <span>break</span><span>;</span>\n    <span>}</span>\n    <span>// 被唤醒后，将进入阻塞队列，等待获取锁</span>\n    <span>if</span> <span>(</span><span>acquireQueued</span><span>(</span>node<span>,</span> savedState<span>)</span> <span>&amp;&amp;</span> interruptMode <span>!=</span> THROW_IE<span>)</span>\n        interruptMode <span>=</span> REINTERRUPT<span>;</span>\n    <span>if</span> <span>(</span>node<span>.</span>nextWaiter <span>!=</span> <span>null</span><span>)</span> <span>// clean up if cancelled</span>\n        <span>unlinkCancelledWaiters</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>interruptMode <span>!=</span> <span>0</span><span>)</span>\n        <span>reportInterruptAfterWait</span><span>(</span>interruptMode<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>1、节点加入条件队列</p>\n<p>注意这里 Node  waitStatus 是 Node.CONDITION。</p>\n<p>当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用 unlinkCancelledWaiters()  方法，该方法用于清除队列中已经取消等待的节点。</p>\n<div><pre><code><span>// 将当前线程对应的节点入队，插入队尾</span>\n<span>private</span> <span>Node</span> <span>addConditionWaiter</span><span>(</span><span>)</span> <span>{</span>\n    <span>Node</span> t <span>=</span> lastWaiter<span>;</span>\n    <span>// 如果条件队列的最后一个节点取消了，将其清除出去</span>\n    <span>// 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span>\n    <span>if</span> <span>(</span>t <span>!=</span> <span>null</span> <span>&amp;&amp;</span> t<span>.</span>waitStatus <span>!=</span> <span>Node</span><span>.</span>CONDITION<span>)</span> <span>{</span>\n        <span>// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span>\n        <span>unlinkCancelledWaiters</span><span>(</span><span>)</span><span>;</span>\n        t <span>=</span> lastWaiter<span>;</span>\n    <span>}</span>\n    <span>// node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span>\n    <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> <span>Node</span><span>.</span>CONDITION<span>)</span><span>;</span>\n\n    <span>// t 此时是 lastWaiter，队尾</span>\n    <span>// 如果队列为空</span>\n    <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span>\n        firstWaiter <span>=</span> node<span>;</span>\n    <span>else</span>\n        t<span>.</span>nextWaiter <span>=</span> node<span>;</span>\n    lastWaiter <span>=</span> node<span>;</span>\n    <span>return</span> node<span>;</span>\n<span>}</span>\n\n<span>// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span>\n<span>// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span>\n<span>private</span> <span>void</span> <span>unlinkCancelledWaiters</span><span>(</span><span>)</span> <span>{</span>\n    <span>Node</span> t <span>=</span> firstWaiter<span>;</span>\n    <span>Node</span> trail <span>=</span> <span>null</span><span>;</span>\n    <span>while</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>Node</span> next <span>=</span> t<span>.</span>nextWaiter<span>;</span>\n        <span>// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span>\n        <span>if</span> <span>(</span>t<span>.</span>waitStatus <span>!=</span> <span>Node</span><span>.</span>CONDITION<span>)</span> <span>{</span>\n            t<span>.</span>nextWaiter <span>=</span> <span>null</span><span>;</span>\n            <span>if</span> <span>(</span>trail <span>==</span> <span>null</span><span>)</span>\n                firstWaiter <span>=</span> next<span>;</span>\n            <span>else</span>\n                trail<span>.</span>nextWaiter <span>=</span> next<span>;</span>\n            <span>if</span> <span>(</span>next <span>==</span> <span>null</span><span>)</span>\n                lastWaiter <span>=</span> trail<span>;</span>\n        <span>}</span>\n        <span>else</span>\n            trail <span>=</span> t<span>;</span>\n        t <span>=</span> next<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>2、完全释放独占锁。（为什么在这里就把 所有的锁释放了？？可能是为了只有在signal才转移？？ ）</p>\n<p>节点入队了以后，会调用 <code>int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。</p>\n<blockquote>\n<p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p>\n</blockquote>\n<div><pre><code><span>// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span>\n<span>// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span>\n<span>//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span>\n<span>//         相应的，如果 lock 重入了 n 次，savedState == n</span>\n<span>// 如果这个方法失败，会将节点设置为\"取消\"状态，并抛出异常 IllegalMonitorStateException</span>\n<span>final</span> <span>int</span> <span>fullyRelease</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n    <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>int</span> savedState <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n        <span>// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span>\n        <span>if</span> <span>(</span><span>release</span><span>(</span>savedState<span>)</span><span>)</span> <span>{</span>\n            failed <span>=</span> <span>false</span><span>;</span>\n            <span>return</span> savedState<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>IllegalMonitorStateException</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span>failed<span>)</span>\n            node<span>.</span>waitStatus <span>=</span> <span>Node</span><span>.</span>CANCELLED<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>\n<p>考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 <code>node.waitStatus = Node.CANCELLED</code>，这个已经入队的节点之后会被后继的节点”请出去“。</p>\n</blockquote>\n<p>3、等待进入阻塞队列。</p>\n<p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。（别瞎几把理解，都挂起了，还 while 个屁啊，等待唤醒就好了）</p>\n<div><pre><code><span>int</span> interruptMode <span>=</span> <span>0</span><span>;</span>\n<span>// 如果不在阻塞队列中，注意了，是阻塞队列</span>\n<span>while</span> <span>(</span><span>!</span><span>isOnSyncQueue</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>\n    <span>// 线程挂起</span>\n    <span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>this</span><span>)</span><span>;</span>\n\n    <span>// 这里可以先不用看了，等看到它什么时候被 unpark 再说</span>\n    <span>if</span> <span>(</span><span>(</span>interruptMode <span>=</span> <span>checkInterruptWhileWaiting</span><span>(</span>node<span>)</span><span>)</span> <span>!=</span> <span>0</span><span>)</span>\n        <span>break</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>判断是否在阻塞队列中：</p>\n<ul>\n<li>当前节点 waitSatus == -2 ，即 Node.CONDITION，不在队列中</li>\n<li>如果节点已经有后继接，说明已经进去阻塞队列。因为 Condition 中 Node的pre 和 next 是 null。</li>\n</ul>\n<div><pre><code><span>// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span>\n<span>// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span>\n<span>// 这个方法就是判断 node 是否已经移动到阻塞队列了</span>\n<span>final</span> <span>boolean</span> <span>isOnSyncQueue</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n\n    <span>// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span>\n    <span>// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span>\n    <span>// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span>\n    <span>if</span> <span>(</span>node<span>.</span>waitStatus <span>==</span> <span>Node</span><span>.</span>CONDITION <span>||</span> node<span>.</span>prev <span>==</span> <span>null</span><span>)</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span>\n    <span>if</span> <span>(</span>node<span>.</span>next <span>!=</span> <span>null</span><span>)</span> \n        <span>return</span> <span>true</span><span>;</span>\n\n    <span>// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span>\n\n    <span>// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span>\n    <span>// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span>\n    <span>// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span>\n\n    <span>return</span> <span>findNodeFromTail</span><span>(</span>node<span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span>\n<span>private</span> <span>boolean</span> <span>findNodeFromTail</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n    <span>Node</span> t <span>=</span> tail<span>;</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>t <span>==</span> node<span>)</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span>\n            <span>return</span> <span>false</span><span>;</span>\n        t <span>=</span> t<span>.</span>prev<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>4、唤醒后检查中断状态</p>\n<p>signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p>\n<p>等线程从挂起中恢复过来，继续往下看</p>\n<div><pre><code><span>int</span> interruptMode <span>=</span> <span>0</span><span>;</span>\n<span>while</span> <span>(</span><span>!</span><span>isOnSyncQueue</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>\n    <span>// 线程挂起</span>\n    <span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>this</span><span>)</span><span>;</span>\n\n    <span>if</span> <span>(</span><span>(</span>interruptMode <span>=</span> <span>checkInterruptWhileWaiting</span><span>(</span>node<span>)</span><span>)</span> <span>!=</span> <span>0</span><span>)</span>\n        <span>break</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p>\n<ul>\n<li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li>\n<li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li>\n<li>0 ：说明在 await 期间，没有发生中断</li>\n</ul>\n<p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p>\n<div><pre><code><span>// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span>\n<span>// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span>\n<span>// 3. 没有发生中断，返回 0</span>\n<span>private</span> <span>int</span> <span>checkInterruptWhileWaiting</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n    <span>return</span> <span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span> <span>?</span>\n        <span>(</span><span>transferAfterCancelledWait</span><span>(</span>node<span>)</span> <span>?</span> THROW_IE <span>:</span> REINTERRUPT<span>)</span> <span>:</span>\n        <span>0</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>\n<p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p>\n</blockquote>\n<p>看看怎么判断是 signal 之前还是之后发生的中断：</p>\n<ul>\n<li>如果 node waitStatus 成功设置为 0：signal 之前中断。因为 signal 先发生会将 waitStatus 设置为 0。</li>\n<li>如果 signal 之后中断 ，并且没有插入阻塞队列，</li>\n</ul>\n<div><pre><code><span>// 只有线程处于中断状态，才会调用此方法</span>\n<span>// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span>\n<span>// 返回 true：如果此线程在 signal 之前被取消，</span>\n<span>final</span> <span>boolean</span> <span>transferAfterCancelledWait</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n    <span>// 用 CAS 将节点状态设置为 0 </span>\n    <span>// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span>\n    <span>if</span> <span>(</span><span>compareAndSetWaitStatus</span><span>(</span>node<span>,</span> <span>Node</span><span>.</span>CONDITION<span>,</span> <span>0</span><span>)</span><span>)</span> <span>{</span>\n        <span>// 将节点放入阻塞队列</span>\n        <span>// 这里我们看到，即使中断了，依然会转移到阻塞队列</span>\n        <span>enq</span><span>(</span>node<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n    <span>// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span>\n    <span>// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span>\n    <span>// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span>\n    <span>// ？？？？？这里为什么要把线程让掉？？？虽然可能是因为 signal 调用之后被中断需要时间把node转移到 阻塞队列，但是为什么要把当前线程 yield</span>\n    <span>//    也许是为了给其他线程公平执行的机会？？</span>\n    <span>while</span> <span>(</span><span>!</span><span>isOnSyncQueue</span><span>(</span>node<span>)</span><span>)</span>\n        <span>Thread</span><span>.</span><span>yield</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>\n<p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p>\n</blockquote>\n<p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p>\n<p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。</p>\n<p>6、获取独占锁</p>\n<p>while 循环出来以后，下面是这段代码：</p>\n<div><pre><code><span>if</span> <span>(</span><span>acquireQueued</span><span>(</span>node<span>,</span> savedState<span>)</span> <span>&amp;&amp;</span> interruptMode <span>!=</span> THROW_IE<span>)</span>\n    interruptMode <span>=</span> REINTERRUPT<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p>\n<p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p>\n<p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p>\n<p>继续往下：</p>\n<div><pre><code><span>if</span> <span>(</span>node<span>.</span>nextWaiter <span>!=</span> <span>null</span><span>)</span> <span>// clean up if cancelled</span>\n    <span>unlinkCancelledWaiters</span><span>(</span><span>)</span><span>;</span>\n<span>if</span> <span>(</span>interruptMode <span>!=</span> <span>0</span><span>)</span>\n    <span>reportInterruptAfterWait</span><span>(</span>interruptMode<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p>\n<p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p>\n<p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p>\n<p>7、处理中断状态</p>\n<p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p>\n<ul>\n<li>0：什么都不做，没有被中断过；</li>\n<li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li>\n<li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li>\n</ul>\n<div><pre><code><span>private</span> <span>void</span> <span>reportInterruptAfterWait</span><span>(</span><span>int</span> interruptMode<span>)</span>\n    <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>if</span> <span>(</span>interruptMode <span>==</span> THROW_IE<span>)</span>\n        <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n    <span>else</span> <span>if</span> <span>(</span>interruptMode <span>==</span> REINTERRUPT<span>)</span>\n        <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>个人理解是不是被唤醒的线程发现自己还在中间期间，但是决定先不中断，先把事情干完了。interruptMode 临时被设置为上面两个值，等事情干完后，再重新中断。？？？？？？？？？？？？？？？？？？？？、</p>\n<h3 id=\"线程唤醒-signal\"> 线程唤醒 signal()</h3>\n<p>唤醒的本质其实就是将此线程的 node 从条件队列转移到阻塞队列。</p>\n<div><pre><code><span>// 唤醒等待了最久的线程</span>\n<span>// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span>\n<span>public</span> <span>final</span> <span>void</span> <span>signal</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 调用 signal 方法的线程必须持有当前的独占锁</span>\n    <span>if</span> <span>(</span><span>!</span><span>isHeldExclusively</span><span>(</span><span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>IllegalMonitorStateException</span><span>(</span><span>)</span><span>;</span>\n    <span>Node</span> first <span>=</span> firstWaiter<span>;</span>\n    <span>if</span> <span>(</span>first <span>!=</span> <span>null</span><span>)</span>\n        <span>doSignal</span><span>(</span>first<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>转移 fistWaiter 到阻塞队列过程。</p>\n<p>注意阻塞队列需要把前驱节点 waitStatus 设置为 -1。</p>\n<div><pre><code><span>// 从条件队列队头往后遍历，找出第一个需要转移的 node</span>\n<span>// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span>\n<span>private</span> <span>void</span> <span>doSignal</span><span>(</span><span>Node</span> first<span>)</span> <span>{</span>\n    <span>do</span> <span>{</span>\n          <span>// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span>\n        <span>// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span>\n        <span>if</span> <span>(</span> <span>(</span>firstWaiter <span>=</span> first<span>.</span>nextWaiter<span>)</span> <span>==</span> <span>null</span><span>)</span>\n            lastWaiter <span>=</span> <span>null</span><span>;</span>\n        <span>// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span>\n        first<span>.</span>nextWaiter <span>=</span> <span>null</span><span>;</span>\n    <span>}</span> <span>while</span> <span>(</span><span>!</span><span>transferForSignal</span><span>(</span>first<span>)</span> <span>&amp;&amp;</span>\n             <span>(</span>first <span>=</span> firstWaiter<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n      <span>// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span>\n<span>}</span>\n\n<span>// 将节点从条件队列转移到阻塞队列</span>\n<span>// true 代表成功转移</span>\n<span>// false 代表在 signal 之前，节点已经取消了</span>\n<span>final</span> <span>boolean</span> <span>transferForSignal</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n\n    <span>// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span>\n    <span>// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span>\n    <span>// 否则，将 waitStatus 置为 0</span>\n    <span>if</span> <span>(</span><span>!</span><span>compareAndSetWaitStatus</span><span>(</span>node<span>,</span> <span>Node</span><span>.</span>CONDITION<span>,</span> <span>0</span><span>)</span><span>)</span>\n        <span>return</span> <span>false</span><span>;</span>\n\n    <span>// enq(node): 自旋进入阻塞队列的队尾。在加锁的时候添加队尾节点用到这方法</span>\n    <span>// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span>\n    <span>Node</span> p <span>=</span> <span>enq</span><span>(</span>node<span>)</span><span>;</span>\n    <span>int</span> ws <span>=</span> p<span>.</span>waitStatus<span>;</span>\n    <span>// ws > 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span>\n    <span>// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span>\n    <span>if</span> <span>(</span>ws <span>></span> <span>0</span> <span>||</span> <span>!</span><span>compareAndSetWaitStatus</span><span>(</span>p<span>,</span> ws<span>,</span> <span>Node</span><span>.</span>SIGNAL<span>)</span><span>)</span>\n        <span>// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span>\n        <span>LockSupport</span><span>.</span><span>unpark</span><span>(</span>node<span>.</span>thread<span>)</span><span>;</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 <code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p>\n<p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p>\n<h3 id=\"带超时机制的-await\"> 带超时机制的  await</h3>\n<div><pre><code><span>public</span> <span>final</span> <span>long</span> <span>awaitNanos</span><span>(</span><span>long</span> nanosTimeout<span>)</span> \n                  <span>throws</span> <span>InterruptedException</span>\n<span>public</span> <span>final</span> <span>boolean</span> <span>awaitUntil</span><span>(</span><span>Date</span> deadline<span>)</span>\n                <span>throws</span> <span>InterruptedException</span>\n<span>public</span> <span>final</span> <span>boolean</span> <span>await</span><span>(</span><span>long</span> time<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n                <span>throws</span> <span>InterruptedException</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这三个方法都差不多，我们就挑一个出来看看吧：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>boolean</span> <span>await</span><span>(</span><span>long</span> time<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n        <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>// 等待这么多纳秒</span>\n    <span>long</span> nanosTimeout <span>=</span> unit<span>.</span><span>toNanos</span><span>(</span>time<span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n    <span>Node</span> node <span>=</span> <span>addConditionWaiter</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> savedState <span>=</span> <span>fullyRelease</span><span>(</span>node<span>)</span><span>;</span>\n    <span>// 当前时间 + 等待时长 = 过期时间</span>\n    <span>final</span> <span>long</span> deadline <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span> <span>+</span> nanosTimeout<span>;</span>\n    <span>// 用于返回 await 是否超时</span>\n    <span>boolean</span> timedout <span>=</span> <span>false</span><span>;</span>\n    <span>int</span> interruptMode <span>=</span> <span>0</span><span>;</span>\n    <span>while</span> <span>(</span><span>!</span><span>isOnSyncQueue</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>\n        <span>// 时间到啦</span>\n        <span>if</span> <span>(</span>nanosTimeout <span>&lt;=</span> <span>0L</span><span>)</span> <span>{</span>\n            <span>// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span>\n            <span>// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span>\n            <span>// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span>\n            timedout <span>=</span> <span>transferAfterCancelledWait</span><span>(</span>node<span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n        <span>// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span>\n        <span>// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span>\n        <span>if</span> <span>(</span>nanosTimeout <span>>=</span> spinForTimeoutThreshold<span>)</span>\n            <span>LockSupport</span><span>.</span><span>parkNanos</span><span>(</span><span>this</span><span>,</span> nanosTimeout<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>(</span>interruptMode <span>=</span> <span>checkInterruptWhileWaiting</span><span>(</span>node<span>)</span><span>)</span> <span>!=</span> <span>0</span><span>)</span>\n            <span>break</span><span>;</span>\n        <span>// 得到剩余时间</span>\n        nanosTimeout <span>=</span> deadline <span>-</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span><span>acquireQueued</span><span>(</span>node<span>,</span> savedState<span>)</span> <span>&amp;&amp;</span> interruptMode <span>!=</span> THROW_IE<span>)</span>\n        interruptMode <span>=</span> REINTERRUPT<span>;</span>\n    <span>if</span> <span>(</span>node<span>.</span>nextWaiter <span>!=</span> <span>null</span><span>)</span>\n        <span>unlinkCancelledWaiters</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>interruptMode <span>!=</span> <span>0</span><span>)</span>\n        <span>reportInterruptAfterWait</span><span>(</span>interruptMode<span>)</span><span>;</span>\n    <span>return</span> <span>!</span>timedout<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p>\n<p>参考：</p>\n<p>https://javadoop.com/post/AbstractQueuedSynchronizer-2</p>\n",
      "date_modified": "2022-04-29T06:23:43.120Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "Condition",
      "url": "https://fmiles.cn/java/concurrent/locks/CountDownLatch/",
      "id": "https://fmiles.cn/java/concurrent/locks/CountDownLatch/",
      "content_html": "<p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>。</p>\n<h2 id=\"例子\"> 例子</h2>\n<p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p>\n<p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作</p>\n<div><pre><code><span>class</span> <span>Driver2</span> <span>{</span> <span>// ...</span>\n    <span>void</span> <span>main</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>CountDownLatch</span> doneSignal <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span><span>N</span><span>)</span><span>;</span>\n        <span>Executor</span> e <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>8</span><span>)</span><span>;</span>\n\n        <span>// 创建 N 个任务，提交给线程池来执行</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> <span>++</span>i<span>)</span> <span>// create and start threads</span>\n            e<span>.</span><span>execute</span><span>(</span><span>new</span> <span>WorkerRunnable</span><span>(</span>doneSignal<span>,</span> i<span>)</span><span>)</span><span>;</span>\n\n        <span>// 等待所有的任务完成，这个方法才会返回</span>\n        doneSignal<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>           <span>// wait for all to finish</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>WorkerRunnable</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>CountDownLatch</span> doneSignal<span>;</span>\n    <span>private</span> <span>final</span> <span>int</span> i<span>;</span>\n\n    <span>WorkerRunnable</span><span>(</span><span>CountDownLatch</span> doneSignal<span>,</span> <span>int</span> i<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>doneSignal <span>=</span> doneSignal<span>;</span>\n        <span>this</span><span>.</span>i <span>=</span> i<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>doWork</span><span>(</span>i<span>)</span><span>;</span>\n            <span>// 这个线程的任务完成了，调用 countDown 方法</span>\n            doneSignal<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> ex<span>)</span> <span>{</span>\n        <span>}</span> <span>// return;</span>\n    <span>}</span>\n\n    <span>void</span> <span>doWork</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。</p>\n<p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch</p>\n<div><pre><code><span>class</span> <span>Driver</span> <span>{</span> <span>// ...</span>\n    <span>void</span> <span>main</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>CountDownLatch</span> startSignal <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>CountDownLatch</span> doneSignal <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span><span>N</span><span>)</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> <span>++</span>i<span>)</span> <span>// create and start threads</span>\n            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Worker</span><span>(</span>startSignal<span>,</span> doneSignal<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。</span>\n        <span>doSomethingElse</span><span>(</span><span>)</span><span>;</span>            <span>// don't let run yet</span>\n        <span>// 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过</span>\n        startSignal<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>      <span>// let all threads proceed</span>\n        <span>doSomethingElse</span><span>(</span><span>)</span><span>;</span>\n        <span>// 等待所有任务结束</span>\n        doneSignal<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>           <span>// wait for all to finish</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Worker</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>CountDownLatch</span> startSignal<span>;</span>\n    <span>private</span> <span>final</span> <span>CountDownLatch</span> doneSignal<span>;</span>\n\n    <span>Worker</span><span>(</span><span>CountDownLatch</span> startSignal<span>,</span> <span>CountDownLatch</span> doneSignal<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>startSignal <span>=</span> startSignal<span>;</span>\n        <span>this</span><span>.</span>doneSignal <span>=</span> doneSignal<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>// 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里</span>\n            <span>// 等大家都准备好了，再打开这个门栓</span>\n            startSignal<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n            <span>doWork</span><span>(</span><span>)</span><span>;</span>\n            doneSignal<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> ex<span>)</span> <span>{</span>\n        <span>}</span> <span>// return;</span>\n    <span>}</span>\n\n    <span>void</span> <span>doWork</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏，目的是让所有的线程站在一个起跑线上。</p>\n<p><img src=\"./images/5.png\" alt=\"5\" loading=\"lazy\"></p>\n<p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p>\n<h2 id=\"原理\"> 原理</h2>\n<div><pre><code><span>public</span> <span>CountDownLatch</span><span>(</span><span>int</span> count<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>count <span>&lt;</span> <span>0</span><span>)</span> <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"count &lt; 0\"</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>sync <span>=</span> <span>new</span> <span>Sync</span><span>(</span>count<span>)</span><span>;</span>\n<span>}</span>\n<span>// 老套路了，内部封装一个 Sync 类继承自 AQS</span>\n<span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>Sync</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>{</span>\n    <span>Sync</span><span>(</span><span>int</span> count<span>)</span> <span>{</span>\n        <span>// 这样就 state == count 了</span>\n        <span>setState</span><span>(</span>count<span>)</span><span>;</span>\n    <span>}</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>\n<p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p>\n</blockquote>\n<p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p>\n<p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：<em>所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</em></p>\n<p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CountDownLatchDemo</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n        <span>CountDownLatch</span> latch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span><span>2</span><span>)</span><span>;</span>\n\n        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> ignore<span>)</span> <span>{</span>\n                <span>}</span>\n                <span>// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()</span>\n                latch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"t1\"</span><span>)</span><span>;</span>\n\n        <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>10000</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> ignore<span>)</span> <span>{</span>\n                <span>}</span>\n                <span>// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()</span>\n                latch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"t2\"</span><span>)</span><span>;</span>\n\n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>Thread</span> t3 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>// 阻塞，等待 state 减为 0</span>\n                    latch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"线程 t3 从 await 中返回了\"</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"线程 t3 await 被中断\"</span><span>)</span><span>;</span>\n                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"t3\"</span><span>)</span><span>;</span>\n        <span>Thread</span> t4 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    <span>// 阻塞，等待 state 减为 0</span>\n                    latch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"线程 t4 从 await 中返回了\"</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"线程 t4 await 被中断\"</span><span>)</span><span>;</span>\n                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"t4\"</span><span>)</span><span>;</span>\n\n        t3<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        t4<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><p>上述程序，大概在过了 10 秒左右的时候，会输出：</p>\n<div><pre><code>线程 t3 从 await 中返回了\n线程 t4 从 await 中返回了\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>这两条输出，顺序不是绝对的</p>\n<p>后面的分析，我们假设 t3 先进入阻塞队列</p>\n</blockquote>\n<h3 id=\"await\"> await()</h3>\n<p>主要作用就是通过 state 阻塞，让所有线程入队。不管主线程和人物线程执行顺序，只要设置了 await，就相当于有了个栅栏在这里，子线程先执行完任务过来，就得在这等着。当然了，如果最开始就执行 await，那就相当于让等着让所有线程都准备好，再去做事。</p>\n<div><pre><code><span>public</span> <span>void</span> <span>await</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    sync<span>.</span><span>acquireSharedInterruptibly</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>final</span> <span>void</span> <span>acquireSharedInterruptibly</span><span>(</span><span>int</span> arg<span>)</span>\n        <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>// 这也是老套路了，我在第二篇的中断那一节说过了</span>\n    <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。</span>\n    <span>// 也就是说，这个 if 返回 true，然后往里看</span>\n    <span>if</span> <span>(</span><span>tryAcquireShared</span><span>(</span>arg<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>\n        <span>doAcquireSharedInterruptibly</span><span>(</span>arg<span>)</span><span>;</span>\n<span>}</span>\n<span>// 只有当 state == 0 的时候，这个方法才会返回 1</span>\n<span>protected</span> <span>int</span> <span>tryAcquireShared</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>getState</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>获取共享锁失败，入队。</p>\n<p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p>\n<div><pre><code><span>private</span> <span>void</span> <span>doAcquireSharedInterruptibly</span><span>(</span><span>int</span> arg<span>)</span>\n    <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>// 1. 入队</span>\n    <span>final</span> <span>Node</span> node <span>=</span> <span>addWaiter</span><span>(</span><span>Node</span><span>.</span>SHARED<span>)</span><span>;</span>\n    <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>p <span>==</span> head<span>)</span> <span>{</span>\n                <span>// 同上，只要 state 不等于 0，那么这个方法返回 -1</span>\n                <span>int</span> r <span>=</span> <span>tryAcquireShared</span><span>(</span>arg<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>r <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>setHeadAndPropagate</span><span>(</span>node<span>,</span> r<span>)</span><span>;</span>\n                    p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>\n                    failed <span>=</span> <span>false</span><span>;</span>\n                    <span>return</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>// 2</span>\n            <span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>\n                <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>\n                <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span>failed<span>)</span>\n            <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p>\n<img src=\"images/2.png\" alt=\"2\" style=\"zoom: 50%;\" />\n<p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p>\n<img src=\"images/3.png\" alt=\"3\" style=\"zoom:50%;\" />\n<p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p>\n<p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p>\n<img src=\"images/4.png\" alt=\"4\" style=\"zoom:50%;\" />\n<p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p>\n<p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p>\n<img src=\"images/1.png\" alt=\"1\" style=\"zoom: 50%;\" />\n<p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p>\n<h3 id=\"countdown\"> countDown()</h3>\n<p>调用一次，state 减 1。</p>\n<div><pre><code><span>public</span> <span>void</span> <span>countDown</span><span>(</span><span>)</span> <span>{</span>\n    sync<span>.</span><span>releaseShared</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>final</span> <span>boolean</span> <span>releaseShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span>\n    <span>// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了</span>\n    <span>//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧</span>\n    <span>if</span> <span>(</span><span>tryReleaseShared</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>\n        <span>// 唤醒 await 的线程</span>\n        <span>doReleaseShared</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n<span>// 这个方法很简单，用自旋的方法实现 state 减 1</span>\n<span>protected</span> <span>boolean</span> <span>tryReleaseShared</span><span>(</span><span>int</span> releases<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span>\n            <span>return</span> <span>false</span><span>;</span> <span>// 这里意思是初始就是 0，不需要唤醒的。</span>\n        <span>int</span> nextc <span>=</span> c<span>-</span><span>1</span><span>;</span>\n        <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span>c<span>,</span> nextc<span>)</span><span>)</span>\n            <span>return</span> nextc <span>==</span> <span>0</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>唤醒 await 的线程。</p>\n<p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p>\n<div><pre><code><span>// 调用这个方法的时候，state == 0</span>\n<span>// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析</span>\n<span>private</span> <span>void</span> <span>doReleaseShared</span><span>(</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>Node</span> h <span>=</span> head<span>;</span>\n        <span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h <span>!=</span> tail<span>)</span> <span>{</span>\n            <span>int</span> ws <span>=</span> h<span>.</span>waitStatus<span>;</span>\n            <span>// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span>\n            <span>if</span> <span>(</span>ws <span>==</span> <span>Node</span><span>.</span>SIGNAL<span>)</span> <span>{</span>\n                <span>// 将 head 的 waitStatue 设置为 0</span>\n                <span>if</span> <span>(</span><span>!</span><span>compareAndSetWaitStatus</span><span>(</span>h<span>,</span> <span>Node</span><span>.</span>SIGNAL<span>,</span> <span>0</span><span>)</span><span>)</span>\n                    <span>continue</span><span>;</span>            <span>// loop to recheck cases</span>\n                <span>// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span>\n                <span>// 在这里，也就是唤醒 t3</span>\n                <span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>\n            <span>}</span>\n            <span>else</span> <span>if</span> <span>(</span>ws <span>==</span> <span>0</span> <span>&amp;&amp;</span>\n                     <span>!</span><span>compareAndSetWaitStatus</span><span>(</span>h<span>,</span> <span>0</span><span>,</span> <span>Node</span><span>.</span>PROPAGATE<span>)</span><span>)</span> <span>// todo</span>\n                <span>continue</span><span>;</span>                <span>// loop on failed CAS</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>h <span>==</span> head<span>)</span>                   <span>// loop if head changed</span>\n            <span>break</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p>\n<div><pre><code><span>private</span> <span>void</span> <span>doAcquireSharedInterruptibly</span><span>(</span><span>int</span> arg<span>)</span>\n    <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>final</span> <span>Node</span> node <span>=</span> <span>addWaiter</span><span>(</span><span>Node</span><span>.</span>SHARED<span>)</span><span>;</span>\n    <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>p <span>==</span> head<span>)</span> <span>{</span>\n                <span>int</span> r <span>=</span> <span>tryAcquireShared</span><span>(</span>arg<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>r <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>setHeadAndPropagate</span><span>(</span>node<span>,</span> r<span>)</span><span>;</span> <span>// 2. 这里是下一步</span>\n                    p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>\n                    failed <span>=</span> <span>false</span><span>;</span>\n                    <span>return</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>\n                <span>// 1. 唤醒后这个方法返回</span>\n                <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>\n                <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span>failed<span>)</span>\n            <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p>\n<div><pre><code><span>private</span> <span>void</span> <span>setHeadAndPropagate</span><span>(</span><span>Node</span> node<span>,</span> <span>int</span> propagate<span>)</span> <span>{</span>\n    <span>Node</span> h <span>=</span> head<span>;</span> <span>// Record old head for check below</span>\n    <span>setHead</span><span>(</span>node<span>)</span><span>;</span>\n\n    <span>// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span>\n    <span>// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span>\n    <span>if</span> <span>(</span>propagate <span>></span> <span>0</span> <span>||</span> h <span>==</span> <span>null</span> <span>||</span> h<span>.</span>waitStatus <span>&lt;</span> <span>0</span> <span>||</span>\n        <span>(</span>h <span>=</span> head<span>)</span> <span>==</span> <span>null</span> <span>||</span> h<span>.</span>waitStatus <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n        <span>Node</span> s <span>=</span> node<span>.</span>next<span>;</span>\n        <span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span><span>isShared</span><span>(</span><span>)</span><span>)</span>\n            <span>// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span>\n            <span>doReleaseShared</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p>\n<div><pre><code><span>// 调用这个方法的时候，state == 0</span>\n<span>private</span> <span>void</span> <span>doReleaseShared</span><span>(</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>Node</span> h <span>=</span> head<span>;</span>\n        <span>// 1. h == null: 说明阻塞队列为空</span>\n        <span>// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，</span>\n        <span>//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span>\n        <span>// 所以这两种情况不需要进行唤醒后继节点</span>\n        <span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h <span>!=</span> tail<span>)</span> <span>{</span>\n            <span>int</span> ws <span>=</span> h<span>.</span>waitStatus<span>;</span>\n            <span>// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span>\n            <span>if</span> <span>(</span>ws <span>==</span> <span>Node</span><span>.</span>SIGNAL<span>)</span> <span>{</span>\n                <span>// 这里 CAS 失败的场景请看下面的解读</span>\n                <span>if</span> <span>(</span><span>!</span><span>compareAndSetWaitStatus</span><span>(</span>h<span>,</span> <span>Node</span><span>.</span>SIGNAL<span>,</span> <span>0</span><span>)</span><span>)</span>\n                    <span>continue</span><span>;</span>            <span>// loop to recheck cases</span>\n                <span>// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span>\n                <span>// 在这里，也就是唤醒 t4</span>\n                <span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>\n            <span>}</span>\n            <span>else</span> <span>if</span> <span>(</span>ws <span>==</span> <span>0</span> <span>&amp;&amp;</span>\n                     <span>// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span>\n                     <span>!</span><span>compareAndSetWaitStatus</span><span>(</span>h<span>,</span> <span>0</span><span>,</span> <span>Node</span><span>.</span>PROPAGATE<span>)</span><span>)</span>\n                <span>continue</span><span>;</span>                <span>// loop on failed CAS</span>\n        <span>}</span>\n        <span>// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span>\n        <span>// 否则，就是 head 没变，那么退出循环，</span>\n        <span>// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span>\n        <span>if</span> <span>(</span>h <span>==</span> head<span>)</span>                   <span>// loop if head changed</span>\n            <span>break</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p>\n<ol>\n<li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li>\n<li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7...，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li>\n</ol>\n<p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p>\n<p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p>\n<p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p>\n",
      "date_modified": "2022-04-29T06:23:43.124Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "CyclicBarrier",
      "url": "https://fmiles.cn/java/concurrent/locks/CyclicBarrier/",
      "id": "https://fmiles.cn/java/concurrent/locks/CyclicBarrier/",
      "content_html": "<h2 id=\"cyclicbarrier\"> CyclicBarrier</h2>\n<p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p>\n<img src=\"images/cyclicbarrier-2.png\" alt=\"cyclicbarrier-2\" style=\"zoom:50%;\" />\n<p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>\n<p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p>\n<p><img src=\"./images/cyclicbarrier-3.png\" alt=\"cyclicbarrier-3\" loading=\"lazy\"></p>\n<h2 id=\"原理\"> 原理</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>CyclicBarrier</span> <span>{</span>\n    <span>// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做\"一代\"，或者\"一个周期\"</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>Generation</span> <span>{</span>\n        <span>boolean</span> broken <span>=</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>/** The lock for guarding barrier entry */</span>\n    <span>private</span> <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// CyclicBarrier 是基于 Condition 的</span>\n    <span>// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span>\n    <span>private</span> <span>final</span> <span>Condition</span> trip <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 参与的线程数</span>\n    <span>private</span> <span>final</span> <span>int</span> parties<span>;</span>\n\n    <span>// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span>\n    <span>private</span> <span>final</span> <span>Runnable</span> barrierCommand<span>;</span>\n\n    <span>// 当前所处的“代”</span>\n    <span>private</span> <span>Generation</span> generation <span>=</span> <span>new</span> <span>Generation</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span>\n    <span>// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span>\n    <span>private</span> <span>int</span> count<span>;</span>\n\n    <span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>,</span> <span>Runnable</span> barrierAction<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>parties <span>&lt;=</span> <span>0</span><span>)</span> <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>parties <span>=</span> parties<span>;</span>\n        <span>this</span><span>.</span>count <span>=</span> parties<span>;</span>\n        <span>this</span><span>.</span>barrierCommand <span>=</span> barrierAction<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>parties<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>首先，先看怎么开启新的一代：</p>\n<div><pre><code><span>// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span>\n<span>private</span> <span>void</span> <span>nextGeneration</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 首先，需要唤醒所有的在栅栏上等待的线程</span>\n    trip<span>.</span><span>signalAll</span><span>(</span><span>)</span><span>;</span>\n    <span>// 更新 count 的值</span>\n    count <span>=</span> parties<span>;</span>\n    <span>// 重新生成“新一代”</span>\n    generation <span>=</span> <span>new</span> <span>Generation</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p>\n</blockquote>\n<p>看看怎么打破一个栅栏：</p>\n<div><pre><code><span>private</span> <span>void</span> <span>breakBarrier</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 设置状态 broken 为 true</span>\n    generation<span>.</span>broken <span>=</span> <span>true</span><span>;</span>\n    <span>// 重置 count 为初始值 parties</span>\n    count <span>=</span> parties<span>;</span>\n    <span>// 唤醒所有已经在等待的线程</span>\n    trip<span>.</span><span>signalAll</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"await\"> await():</h3>\n<p>等待所有通过栅栏的线程。</p>\n<div><pre><code><span>// 不带超时机制</span>\n<span>public</span> <span>int</span> <span>await</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>BrokenBarrierException</span> <span>{</span>\n    <span>try</span> <span>{</span>\n        <span>return</span> <span>dowait</span><span>(</span><span>false</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>TimeoutException</span> toe<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>Error</span><span>(</span>toe<span>)</span><span>;</span> <span>// cannot happen</span>\n    <span>}</span>\n<span>}</span>\n<span>// 带超时机制，如果超时抛出 TimeoutException 异常</span>\n<span>public</span> <span>int</span> <span>await</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n    <span>throws</span> <span>InterruptedException</span><span>,</span>\n           <span>BrokenBarrierException</span><span>,</span>\n           <span>TimeoutException</span> <span>{</span>\n    <span>return</span> <span>dowait</span><span>(</span><span>true</span><span>,</span> unit<span>.</span><span>toNanos</span><span>(</span>timeout<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>等待的实现</p>\n<div><pre><code><span>private</span> <span>int</span> <span>dowait</span><span>(</span><span>boolean</span> timed<span>,</span> <span>long</span> nanos<span>)</span>\n        <span>throws</span> <span>InterruptedException</span><span>,</span> <span>BrokenBarrierException</span><span>,</span>\n               <span>TimeoutException</span> <span>{</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    <span>// 先要获取到锁，然后在 finally 中要记得释放锁</span>\n    <span>// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span>\n    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>final</span> <span>Generation</span> g <span>=</span> generation<span>;</span>\n        <span>// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span>\n        <span>if</span> <span>(</span>g<span>.</span>broken<span>)</span>\n            <span>throw</span> <span>new</span> <span>BrokenBarrierException</span><span>(</span><span>)</span><span>;</span>\n        <span>// 检查中断状态，如果中断了，抛出 InterruptedException 异常</span>\n        <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// index 是这个 await 方法的返回值</span>\n        <span>// 注意到这里，这个是从 count 递减后得到的值</span>\n        <span>int</span> index <span>=</span> <span>--</span>count<span>;</span>\n\n        <span>// 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span>\n        <span>if</span> <span>(</span>index <span>==</span> <span>0</span><span>)</span> <span>{</span>  <span>// tripped</span>\n            <span>boolean</span> ranAction <span>=</span> <span>false</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span>\n                <span>final</span> <span>Runnable</span> command <span>=</span> barrierCommand<span>;</span>\n                <span>if</span> <span>(</span>command <span>!=</span> <span>null</span><span>)</span>\n                    command<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n                <span>// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span>\n                ranAction <span>=</span> <span>true</span><span>;</span>\n                <span>// 唤醒等待的线程，然后开启新的一代</span>\n                <span>nextGeneration</span><span>(</span><span>)</span><span>;</span>\n                <span>return</span> <span>0</span><span>;</span>\n            <span>}</span> <span>finally</span> <span>{</span>\n                <span>if</span> <span>(</span><span>!</span>ranAction<span>)</span>\n                    <span>// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span>\n                    <span>// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span>\n                    <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>// loop until tripped, broken, interrupted, or timed out</span>\n        <span>// 如果是最后一个线程调用 await，那么上面就返回了</span>\n        <span>// 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span>\n                <span>if</span> <span>(</span><span>!</span>timed<span>)</span>\n                    trip<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                <span>else</span> <span>if</span> <span>(</span>nanos <span>></span> <span>0L</span><span>)</span>\n                    nanos <span>=</span> trip<span>.</span><span>awaitNanos</span><span>(</span>nanos<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> ie<span>)</span> <span>{</span>\n                <span>// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span>\n                <span>if</span> <span>(</span>g <span>==</span> generation <span>&amp;&amp;</span> <span>!</span> g<span>.</span>broken<span>)</span> <span>{</span>\n                    <span>// 打破栅栏</span>\n                    <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>\n                    <span>// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span>\n                    <span>throw</span> ie<span>;</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span>\n                    <span>// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span>\n                    <span>// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span>\n                    <span>// 而是之后抛出 BrokenBarrierException 异常</span>\n                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n\n              <span>// 唤醒后，检查栅栏是否是“破的”</span>\n            <span>if</span> <span>(</span>g<span>.</span>broken<span>)</span>\n                <span>throw</span> <span>new</span> <span>BrokenBarrierException</span><span>(</span><span>)</span><span>;</span>\n\n            <span>// 这个 for 循环除了异常，就是要从这里退出了</span>\n            <span>// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span>\n            <span>// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span>\n            <span>// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span>\n            <span>// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span>\n            <span>// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span>\n            <span>if</span> <span>(</span>g <span>!=</span> generation<span>)</span>\n                <span>return</span> index<span>;</span>\n\n            <span>// 如果醒来发现超时了，打破栅栏，抛出异常</span>\n            <span>if</span> <span>(</span>timed <span>&amp;&amp;</span> nanos <span>&lt;=</span> <span>0L</span><span>)</span> <span>{</span>\n                <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>\n                <span>throw</span> <span>new</span> <span>TimeoutException</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br></div></div><p>下面开始收尾工作。</p>\n<p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p>\n<div><pre><code><span>public</span> <span>int</span> <span>getNumberWaiting</span><span>(</span><span>)</span> <span>{</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>return</span> parties <span>-</span> count<span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>isBroken</span><span>(</span><span>)</span> <span>{</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>return</span> generation<span>.</span>broken<span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p>\n<ol>\n<li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li>\n<li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li>\n<li>指定执行的操作抛出了异常，这个我们前面也说过。</li>\n</ol>\n<p>最后，我们来看看怎么重置一个栅栏：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>reset</span><span>(</span><span>)</span> <span>{</span>\n    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>\n    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>breakBarrier</span><span>(</span><span>)</span><span>;</span>   <span>// break the current generation</span>\n        <span>nextGeneration</span><span>(</span><span>)</span><span>;</span> <span>// start a new generation</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>\n<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>\n<p>怎么样，CyclicBarrier 源码很简单吧。</p>\n",
      "date_modified": "2022-04-29T06:23:43.126Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "Semaphore",
      "url": "https://fmiles.cn/java/concurrent/locks/Semaphore/",
      "id": "https://fmiles.cn/java/concurrent/locks/Semaphore/",
      "content_html": "<p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p>\n<p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p>\n<p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>\n<p>构造方法：</p>\n<div><pre><code><span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>{</span>\n    sync <span>=</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>\n    sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>permits</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p>\n<p>看 acquire 方法：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>acquire</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    sync<span>.</span><span>acquireSharedInterruptibly</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>void</span> <span>acquireUninterruptibly</span><span>(</span><span>)</span> <span>{</span>\n    sync<span>.</span><span>acquireShared</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    <span>if</span> <span>(</span><span>permits</span> <span>&lt;</span> <span>0</span><span>)</span> <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>\n    sync<span>.</span><span>acquireSharedInterruptibly</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>void</span> <span>acquireUninterruptibly</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>permits</span> <span>&lt;</span> <span>0</span><span>)</span> <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>\n    sync<span>.</span><span>acquireShared</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p>\n<p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>acquireUninterruptibly</span><span>(</span><span>)</span> <span>{</span>\n    sync<span>.</span><span>acquireShared</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>final</span> <span>void</span> <span>acquireShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>tryAcquireShared</span><span>(</span>arg<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>\n        <span>doAcquireShared</span><span>(</span>arg<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p>\n<div><pre><code><span>// 公平策略：</span>\n<span>protected</span> <span>int</span> <span>tryAcquireShared</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span>\n        <span>if</span> <span>(</span><span>hasQueuedPredecessors</span><span>(</span><span>)</span><span>)</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>int</span> available <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> remaining <span>=</span> available <span>-</span> acquires<span>;</span>\n        <span>if</span> <span>(</span>remaining <span>&lt;</span> <span>0</span> <span>||</span>\n            <span>compareAndSetState</span><span>(</span>available<span>,</span> remaining<span>)</span><span>)</span>\n            <span>return</span> remaining<span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>// 非公平策略：</span>\n<span>protected</span> <span>int</span> <span>tryAcquireShared</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n    <span>return</span> <span>nonfairTryAcquireShared</span><span>(</span>acquires<span>)</span><span>;</span>\n<span>}</span>\n<span>final</span> <span>int</span> <span>nonfairTryAcquireShared</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>int</span> available <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> remaining <span>=</span> available <span>-</span> acquires<span>;</span>\n        <span>if</span> <span>(</span>remaining <span>&lt;</span> <span>0</span> <span>||</span>\n            <span>compareAndSetState</span><span>(</span>available<span>,</span> remaining<span>)</span><span>)</span>\n            <span>return</span> remaining<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p>\n<p>我们再回到 acquireShared 方法，</p>\n<div><pre><code><span>public</span> <span>final</span> <span>void</span> <span>acquireShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>tryAcquireShared</span><span>(</span>arg<span>)</span> <span>&lt;</span> <span>0</span><span>)</span>\n        <span>doAcquireShared</span><span>(</span>arg<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p>\n<div><pre><code><span>private</span> <span>void</span> <span>doAcquireShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>final</span> <span>Node</span> node <span>=</span> <span>addWaiter</span><span>(</span><span>Node</span><span>.</span>SHARED<span>)</span><span>;</span>\n    <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>boolean</span> interrupted <span>=</span> <span>false</span><span>;</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>p <span>==</span> head<span>)</span> <span>{</span>\n                <span>int</span> r <span>=</span> <span>tryAcquireShared</span><span>(</span>arg<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>r <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>setHeadAndPropagate</span><span>(</span>node<span>,</span> r<span>)</span><span>;</span>\n                    p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>\n                    <span>if</span> <span>(</span>interrupted<span>)</span>\n                        <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>\n                    failed <span>=</span> <span>false</span><span>;</span>\n                    <span>return</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>\n                <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>\n                interrupted <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span>failed<span>)</span>\n            <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p>\n<div><pre><code><span>// 任务介绍，释放一个资源</span>\n<span>public</span> <span>void</span> <span>release</span><span>(</span><span>)</span> <span>{</span>\n    sync<span>.</span><span>releaseShared</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>final</span> <span>boolean</span> <span>releaseShared</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>tryReleaseShared</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>\n        <span>doReleaseShared</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n\n<span>protected</span> <span>final</span> <span>boolean</span> <span>tryReleaseShared</span><span>(</span><span>int</span> releases<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>int</span> current <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> next <span>=</span> current <span>+</span> releases<span>;</span>\n        <span>// 溢出，当然，我们一般也不会用这么大的数</span>\n        <span>if</span> <span>(</span>next <span>&lt;</span> current<span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>\"Maximum permit count exceeded\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span>current<span>,</span> next<span>)</span><span>)</span>\n            <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p>\n<div><pre><code><span>private</span> <span>void</span> <span>doReleaseShared</span><span>(</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>Node</span> h <span>=</span> head<span>;</span>\n        <span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h <span>!=</span> tail<span>)</span> <span>{</span>\n            <span>int</span> ws <span>=</span> h<span>.</span>waitStatus<span>;</span>\n            <span>if</span> <span>(</span>ws <span>==</span> <span>Node</span><span>.</span>SIGNAL<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>!</span><span>compareAndSetWaitStatus</span><span>(</span>h<span>,</span> <span>Node</span><span>.</span>SIGNAL<span>,</span> <span>0</span><span>)</span><span>)</span>\n                    <span>continue</span><span>;</span>            <span>// loop to recheck cases</span>\n                <span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>\n            <span>}</span>\n            <span>else</span> <span>if</span> <span>(</span>ws <span>==</span> <span>0</span> <span>&amp;&amp;</span>\n                     <span>!</span><span>compareAndSetWaitStatus</span><span>(</span>h<span>,</span> <span>0</span><span>,</span> <span>Node</span><span>.</span>PROPAGATE<span>)</span><span>)</span>\n                <span>continue</span><span>;</span>                <span>// loop on failed CAS</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>h <span>==</span> head<span>)</span>                   <span>// loop if head changed</span>\n            <span>break</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p>\n",
      "date_modified": "2022-04-29T06:23:43.127Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "线程池基础",
      "url": "https://fmiles.cn/java/concurrent/thread/ThreadPoo%E5%9F%BA%E7%A1%80/",
      "id": "https://fmiles.cn/java/concurrent/thread/ThreadPoo%E5%9F%BA%E7%A1%80/",
      "content_html": "<h2 id=\"线程池工作原理\"> 线程池工作原理</h2>\n<p><img src=\"./images/4134622-fbbdbcb6bcc00178.png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>\n<ul>\n<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>\n<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数:</p>\n<ol>\n<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>\n<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>\n<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>\n</ol>\n<h4 id=\"threadpoolexecutor-饱和策略定义\"> <strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></h4>\n<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略</p>\n<ul>\n<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>\n<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>\n<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>\n<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>\n",
      "date_modified": "2022-04-29T06:23:43.128Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "线程池几个类的继承关系：",
      "url": "https://fmiles.cn/java/concurrent/thread/ThreadPool%E5%8E%9F%E7%90%86/",
      "id": "https://fmiles.cn/java/concurrent/thread/ThreadPool%E5%8E%9F%E7%90%86/",
      "content_html": "<h5 id=\"线程池几个类的继承关系\"> 线程池几个类的继承关系：</h5>\n<img src=\"images/1.jpg\" alt=\"1\" style=\"zoom:50%;\" />\n<p>线程池还涉及到下图中的这些类：</p>\n<p><img src=\"./images/others.png\" alt=\"others\" loading=\"lazy\"></p>\n<p>另外，由于线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p>\n<h2 id=\"executor-接口\"> Executor 接口</h2>\n<div><pre><code><span>/* \n * @since 1.5\n * @author Doug Lea\n */</span>\n<span>public</span> <span>interface</span> <span>Executor</span> <span>{</span>\n    <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>我们可以看到 Executor 接口非常简单，就一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p>\n<p>我们经常这样启动一个线程：</p>\n<div><pre><code><span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span><span>{</span>\n  <span>// do something</span>\n<span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>用了线程池 Executor 后就可以像下面这么使用：</p>\n<div><pre><code><span>Executor</span> executor <span>=</span> anExecutor<span>;</span>\nexecutor<span>.</span><span>execute</span><span>(</span><span>new</span> <span>RunnableTask1</span><span>(</span><span>)</span><span>)</span><span>;</span>\nexecutor<span>.</span><span>execute</span><span>(</span><span>new</span> <span>RunnableTask2</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p>\n<div><pre><code><span>class</span> <span>DirectExecutor</span> <span>implements</span> <span>Executor</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> r<span>)</span> <span>{</span>\n        r<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span><span>// 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，我们可以这么实现：</p>\n<div><pre><code><span>class</span> <span>ThreadPerTaskExecutor</span> <span>implements</span> <span>Executor</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> r<span>)</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span>r<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>  <span>// 每个任务都用一个新的线程来执行</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p>\n<div><pre><code><span>class</span> <span>SerialExecutor</span> <span>implements</span> <span>Executor</span> <span>{</span>\n    <span>// 任务队列</span>\n    <span>final</span> <span>Queue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> tasks <span>=</span> <span>new</span> <span>ArrayDeque</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>// 这个才是真正的执行器</span>\n    <span>final</span> <span>Executor</span> executor<span>;</span>\n    <span>// 当前正在执行的任务</span>\n    <span>Runnable</span> active<span>;</span>\n\n    <span>// 初始化的时候，指定执行器</span>\n    <span>SerialExecutor</span><span>(</span><span>Executor</span> executor<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>executor <span>=</span> executor<span>;</span>\n    <span>}</span>\n\n    <span>// 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>execute</span><span>(</span><span>final</span> <span>Runnable</span> r<span>)</span> <span>{</span>\n        tasks<span>.</span><span>offer</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    r<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>finally</span> <span>{</span>\n                    <span>scheduleNext</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>active <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>scheduleNext</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>protected</span> <span>synchronized</span> <span>void</span> <span>scheduleNext</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>(</span>active <span>=</span> tasks<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>// 具体的执行转给真正的执行器 executor</span>\n            executor<span>.</span><span>execute</span><span>(</span>active<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p>\n<h2 id=\"executorservice\"> ExecutorService</h2>\n<p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p>\n<div><pre><code><span>ExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span>args<span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n<span>ExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span>args<span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p>\n<p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ExecutorService</span> <span>extends</span> <span>Executor</span> <span>{</span>\n\n    <span>// 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span>\n    <span>void</span> <span>shutdown</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span>\n    <span>// 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span>\n    <span>List</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> <span>shutdownNow</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 线程池是否已关闭</span>\n    <span>boolean</span> <span>isShutdown</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span>\n    <span>// 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span>\n    <span>boolean</span> <span>isTerminated</span><span>(</span><span>)</span><span>;</span>\n\n    <span>// 等待所有任务完成，并设置超时时间</span>\n    <span>// 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span>\n    <span>// 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span>\n    <span>boolean</span> <span>awaitTermination</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n            <span>throws</span> <span>InterruptedException</span><span>;</span>\n\n    <span>// 提交一个 Callable 任务</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>Future</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>submit</span><span>(</span><span>Callable</span><span><span>&lt;</span><span>T</span><span>></span></span> task<span>)</span><span>;</span>\n\n    <span>// 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span>\n    <span>// 因为 Runnable 的 run 方法本身并不返回任何东西</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>Future</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>submit</span><span>(</span><span>Runnable</span> task<span>,</span> <span>T</span> result<span>)</span><span>;</span>\n\n    <span>// 提交一个 Runnable 任务</span>\n    <span>Future</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>submit</span><span>(</span><span>Runnable</span> task<span>)</span><span>;</span>\n\n    <span>// 执行所有任务，返回 Future 类型的一个 list</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>Future</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>invokeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Callable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> tasks<span>)</span>\n            <span>throws</span> <span>InterruptedException</span><span>;</span>\n\n    <span>// 也是执行所有任务，但是这里设置了超时时间</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>Future</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>invokeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Callable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> tasks<span>,</span>\n                                  <span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n            <span>throws</span> <span>InterruptedException</span><span>;</span>\n\n    <span>// 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>invokeAny</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Callable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> tasks<span>)</span>\n            <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>;</span>\n\n    <span>// 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span>\n    <span>// 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>invokeAny</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Callable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> tasks<span>,</span>\n                    <span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>\n            <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>,</span> <span>TimeoutException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p>\n<h2 id=\"futuretask\"> FutureTask</h2>\n<p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p>\n<h2 id=\"threadpoolexecutor\"> ThreadPoolExecutor</h2>\n<p>Executor  -&gt; execute()   就是提交一个任务</p>\n<p>ExecutorService 能提交任务，能获取结果，能关闭线程池。</p>\n<p>AbstractExecutorService</p>\n<p>FutureTask  Callable 返回run执行结果</p>\n",
      "date_modified": "2022-04-29T06:23:43.129Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "线程相关知识",
      "url": "https://fmiles.cn/java/concurrent/thread/Thread%E7%9B%B8%E5%85%B3/",
      "id": "https://fmiles.cn/java/concurrent/thread/Thread%E7%9B%B8%E5%85%B3/",
      "content_html": "<h2 id=\"线程的生命周期\"> 线程的生命周期</h2>\n<p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>\n<p><img src=\"./images/Java+线程状态变迁.png\" alt=\"Java 线程状态变迁 \" loading=\"lazy\"></p>\n<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>\n<blockquote>\n<p>在操作系统中层面线程有 READY 和 RUNNING 状态，而在 JVM 层面只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>\n<p><strong>为什么 JVM 没有区分这两种状态呢？</strong></p>\n<p>现在的<strong>时分</strong>（time-sharing）<strong>多任务</strong>（multi-task）操作系统架构通常都是用所谓的“<strong>时间分片</strong>（time quantum or time slice）”方式进行<strong>抢占式</strong>（preemptive）轮转调度（round-robin式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>\n</blockquote>\n<h3 id=\"阻塞与等待的区别\"> 阻塞与等待的区别</h3>\n<p>阻塞：当一个线程试图获取对象锁（非java.util.concurrent库中的锁，即synchronized），而该锁被其他线程持有，则该线程进入阻塞状态。它的特点是<strong>使用简单，由JVM调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断</strong>。\n等待：当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。它的特点是<strong>需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断</strong>。例如调用：Object.wait()、Thread.join()以及等待Lock或Condition。</p>\n<p>需要强调的是虽然 synchronized 和 JUC 里的 Lock 都实现锁的功能，但线程进入的状态是不一样的。<strong>synchronized 会让线程进入阻塞态，而 JUC 里的 Lock 是用 LockSupport.park()/unpark() 来实现阻塞/唤醒的，会让线程进入等待态</strong>。但话又说回来，虽然等锁时进入的状态不一样，但被唤醒后又都进入runnable态，从行为效果来看又是一样的。</p>\n<h2 id=\"等待集合-和-唤醒-wait-sets-and-notification\"> 等待集合 和 唤醒（Wait Sets and Notification）</h2>\n<p>每个 java 对象，都关联了一个监视器，也关联了一个<strong>等待集合</strong>。等待集合是一个线程集合。</p>\n<p>当对象被创建出来时，它的等待集合是空的，<em>对于向等待集合中添加或者移除线程的</em>操作都是原子的，以下几个操作可以操纵这个等待集合：Object.wait, Object.notify, Object.notifyAll。</p>\n<p>等待集合也可能受到线程的中断状态的影响，也受到线程中处理中断的方法的影响。另外，sleep 方法和 join 方法可以感知到线程的 wait 和 notify。</p>\n<blockquote>\n<ul>\n<li>Thread 中的 sleep、join、interrupt</li>\n<li>继承自 Object 的 wait、notify、notifyAll</li>\n<li>还有 Java 的中断，这个概念也很重要</li>\n</ul>\n</blockquote>\n<h3 id=\"等待-wait\"> 等待(Wait)</h3>\n",
      "date_modified": "2022-04-29T06:23:43.130Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "ReentrantLock",
      "url": "https://fmiles.cn/java/concurrent/locks/ReentrantLock/",
      "id": "https://fmiles.cn/java/concurrent/locks/ReentrantLock/",
      "content_html": "<h2 id=\"aqs-结构\"> AQS 结构</h2>\n<div><pre><code><span>// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span>\n<span>private</span> <span>transient</span> <span>volatile</span> <span>Node</span> head<span>;</span>\n\n<span>// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span>\n<span>private</span> <span>transient</span> <span>volatile</span> <span>Node</span> tail<span>;</span>\n\n<span>// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span>\n<span>// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span>\n<span>private</span> <span>volatile</span> <span>int</span> state<span>;</span>\n\n<span>// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span>\n<span>// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span>\n<span>// if (currentThread == getExclusiveOwnerThread()) {state++}</span>\n<span>private</span> <span>transient</span> <span>Thread</span> exclusiveOwnerThread<span>;</span> <span>//继承自AbstractOwnableSynchronizer</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p>\n<p><img src=\"./images/aqs-0.png\" alt=\"aqs-0\" loading=\"lazy\"></p>\n<p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p>\n<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>Node</span> <span>{</span>\n    <span>// 标识节点当前在共享模式下</span>\n    <span>static</span> <span>final</span> <span>Node</span> SHARED <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>\n    <span>// 标识节点当前在独占模式下</span>\n    <span>static</span> <span>final</span> <span>Node</span> EXCLUSIVE <span>=</span> <span>null</span><span>;</span>\n\n    <span>// ======== 下面的几个int常量是给waitStatus用的 ===========</span>\n    <span>/** waitStatus value to indicate thread has cancelled */</span>\n    <span>// 代码此线程取消了争抢这个锁</span>\n    <span>static</span> <span>final</span> <span>int</span> CANCELLED <span>=</span>  <span>1</span><span>;</span>\n    <span>/** waitStatus value to indicate successor's thread needs unparking */</span>\n    <span>// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span>\n    <span>static</span> <span>final</span> <span>int</span> SIGNAL    <span>=</span> <span>-</span><span>1</span><span>;</span>\n    <span>/** waitStatus value to indicate thread is waiting on condition */</span>\n    <span>// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span>\n    <span>static</span> <span>final</span> <span>int</span> CONDITION <span>=</span> <span>-</span><span>2</span><span>;</span>\n    <span>/**\n     * waitStatus value to indicate the next acquireShared should\n     * unconditionally propagate\n     */</span>\n    <span>// 同样的不分析，略过吧</span>\n    <span>static</span> <span>final</span> <span>int</span> PROPAGATE <span>=</span> <span>-</span><span>3</span><span>;</span>\n    <span>// =====================================================</span>\n\t<span>// 和 ReentrantLock 无关。用在 Condition 时，表示下一个节点的指针。</span>\n    <span>Node</span> nextWaiter<span>;</span>\n    \n    <span>// =====================================================</span>\n\n    <span>// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span>\n    <span>// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span>\n    <span>//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span>\n    <span>volatile</span> <span>int</span> waitStatus<span>;</span>\n    <span>// 前驱节点的引用</span>\n    <span>volatile</span> <span>Node</span> prev<span>;</span>\n    <span>// 后继节点的引用</span>\n    <span>volatile</span> <span>Node</span> next<span>;</span>\n    <span>// 这个就是线程本尊</span>\n    <span>volatile</span> <span>Thread</span> thread<span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p>\n<p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p>\n<p><img src=\"./images/aqs-0.png\" alt=\"aqs-0\" loading=\"lazy\"></p>\n<p>首先，我们先看下 ReentrantLock 的使用方式。</p>\n<div><pre><code><span>// 我用个web开发中的service概念吧</span>\n<span>public</span> <span>class</span> <span>OrderService</span> <span>{</span>\n    <span>// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span>\n    <span>private</span> <span>static</span> <span>ReentrantLock</span> reentrantLock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>true</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>void</span> <span>createOrder</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 比如我们同一时间，只允许一个线程创建订单</span>\n        reentrantLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>// 通常，lock 之后紧跟着 try 语句</span>\n        <span>try</span> <span>{</span>\n            <span>// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span>\n            <span>// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span>\n            <span>// 执行代码...</span>\n            <span>// 执行代码...</span>\n            <span>// 执行代码...</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>// 释放锁</span>\n            reentrantLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p>\n<div><pre><code><span>abstract</span> <span>static</span> <span>class</span> <span>Sync</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p>\n<div><pre><code><span>public</span> <span>ReentrantLock</span><span>(</span><span>boolean</span> fair<span>)</span> <span>{</span>\n    sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"公平锁\"> 公平锁</h2>\n<h3 id=\"加锁-lock\"> 加锁 Lock</h3>\n<p>lock -&gt; acquire() 。这里 acquire 是继承自 AQS 的实现类。</p>\n<div><pre><code><span>// 争锁</span>\n<span>final</span> <span>void</span> <span>lock</span><span>(</span><span>)</span> <span>{</span>\n    <span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n<span>// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span>\n<span>// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span>\n<span>// 否则，acquireQueued方法会将线程压到队列中</span>\n<span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span> <span>// 此时 arg == 1</span>\n    <span>// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span>\n    <span>// 因为有可能直接就成功了呢，也就不需要进队列排队了，</span>\n    <span>// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span>\n    <span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span>\n        <span>// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span>\n        <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span> <span>{</span>\n        <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>1、尝试获取锁</p>\n<p>就是通过判断 state 值</p>\n<ul>\n<li>== 0 ：没有线程有锁。因为是公平锁，判读堵塞队列为空并且 CAS 尝试更改 state值。成功的话设置独占锁。（因为 ReenrantLock 是独占锁）</li>\n<li>!= 0：说明已经有锁了。如果是独占锁是当前线程获取的，说明重入了（ReentrantLock 可重入锁），那么 state 值增加</li>\n<li>已经有锁且不是当前线程，直接获取锁失败。</li>\n</ul>\n<div><pre><code><span>// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span>\n<span>// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span>\n<span>protected</span> <span>final</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n    <span>final</span> <span>Thread</span> current <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n    <span>// state == 0 此时此刻没有线程持有锁</span>\n    <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span>\n        <span>// 看看有没有别人在队列中等了半天了</span>\n        <span>if</span> <span>(</span><span>!</span><span>hasQueuedPredecessors</span><span>(</span><span>)</span> <span>&amp;&amp;</span>\n            <span>// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span>\n            <span>// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span>\n            <span>// 因为刚刚还没人的，我判断过了</span>\n            <span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> acquires<span>)</span><span>)</span> <span>{</span>\n\n            <span>// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span>\n            <span>setExclusiveOwnerThread</span><span>(</span>current<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span>\n    <span>// 这里不存在并发问题</span>\n    <span>else</span> <span>if</span> <span>(</span>current <span>==</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>int</span> nextc <span>=</span> c <span>+</span> acquires<span>;</span>\n        <span>if</span> <span>(</span>nextc <span>&lt;</span> <span>0</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>\"Maximum lock count exceeded\"</span><span>)</span><span>;</span>\n        <span>setState</span><span>(</span>nextc<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span>\n    <span>// 回到上面一个外层调用方法继续看:</span>\n    <span>// if (!tryAcquire(arg) </span>\n    <span>//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span>\n    <span>//     selfInterrupt();</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n\n<span>// 假设tryAcquire(arg) 返回false，那么代码将执行：</span>\n<span>//        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span>\n<span>// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>2、锁获取失败，把当前线程转为 Node 添加到阻塞队列。</p>\n<p>注意这时候 addWaiter 参数是 Node.EXCLUSIVE，空值。代表是独占锁的意思。</p>\n<p>添加的方式是往前一个节点后面追加：</p>\n<ul>\n<li>前一个节点不为空：直接追加到前一个节点后面。</li>\n<li>前一个节点为空或在 CAS 竞争失败的话，循环的插入尾节点：\n<ul>\n<li>前一个节点为空，说明队列是空的，先初始头尾节点</li>\n<li>前一个节点不为空，循环 cas（循环锁）插入尾节点。即上面获取线程失败的节点入队。</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>// 假设tryAcquire(arg) 返回false，那么代码将执行：</span>\n<span>//        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span>\n<span>// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span>\n\n\n<span>// 此方法的作用是把线程包装成node，同时进入到队列中</span>\n<span>// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span>\n<span>private</span> <span>Node</span> <span>addWaiter</span><span>(</span><span>Node</span> mode<span>)</span> <span>{</span>\n    <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> mode<span>)</span><span>;</span>\n    <span>// Try the fast path of enq; backup to full enq on failure</span>\n    <span>// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span>\n    <span>Node</span> pred <span>=</span> tail<span>;</span>\n\n    <span>// tail!=null => 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span>\n    <span>if</span> <span>(</span>pred <span>!=</span> <span>null</span><span>)</span> <span>{</span> \n        <span>// 将当前的队尾节点，设置为自己的前驱 </span>\n        node<span>.</span>prev <span>=</span> pred<span>;</span> \n        <span>// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span>\n        <span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>pred<span>,</span> node<span>)</span><span>)</span> <span>{</span> \n            <span>// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span>\n            <span>// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span>\n            pred<span>.</span>next <span>=</span> node<span>;</span>\n            <span>// 线程入队了，可以返回了</span>\n            <span>return</span> node<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 仔细看看上面的代码，如果会到这里，</span>\n    <span>// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span>\n    <span>// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span>\n    <span>enq</span><span>(</span>node<span>)</span><span>;</span>\n    <span>return</span> node<span>;</span>\n<span>}</span>\n\n\n<span>// 采用自旋的方式入队</span>\n<span>// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span>\n<span>// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span>\n<span>private</span> <span>Node</span> <span>enq</span><span>(</span><span>final</span> <span>Node</span> node<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n        <span>Node</span> t <span>=</span> tail<span>;</span>\n        <span>// 之前说过，队列为空也会进来这里</span>\n        <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// Must initialize</span>\n            <span>// 初始化head节点</span>\n            <span>// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span>\n            <span>// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span>\n            <span>if</span> <span>(</span><span>compareAndSetHead</span><span>(</span><span>new</span> <span>Node</span><span>(</span><span>)</span><span>)</span><span>)</span>\n                <span>// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span>\n\n                <span>// 这个时候有了head，但是tail还是null，设置一下，</span>\n                <span>// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span>\n                <span>// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span>\n                <span>// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span>\n                tail <span>=</span> head<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// 下面几行，和上一个方法 addWaiter 是一样的，</span>\n            <span>// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span>\n            node<span>.</span>prev <span>=</span> t<span>;</span>\n            <span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>t<span>,</span> node<span>)</span><span>)</span> <span>{</span>\n                t<span>.</span>next <span>=</span> node<span>;</span>\n                <span>return</span> t<span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><p>3、在添加完阻塞队列后，下面这部分就是要挂起线程。挂起后被唤醒去获取锁。</p>\n<p>（1）首先会尝试获取下锁，因为上一步设置 Node 的过程中，出现了没有 head 节点的情况，所以此时是没有线程获得锁，而队列中自己又是第一位。</p>\n<p>（2）没有获取到锁的时候，需要判断当前线程是否需要挂起：</p>\n<ul>\n<li>如果前一个节点是 waitStatus ==  -1：说明前一个节点是挂起的，本线程也需要挂起。</li>\n<li>如果前一个节点 waitStatus &gt; 0：说明前一个节点取消了排队。那么需要往前找到 waitStatus &lt;= 0，因为进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。（仅仅找到前驱，返回的 false）</li>\n<li>如果前一个节点 waitStatus &lt; 0：说明终于找到好爹了，把这个节点 waitStatus 设为 -1，代表以后靠这个线程唤醒自己。（仅仅设置了 -1，返回的是 false）</li>\n</ul>\n<p>原因也很简单，第二步是因为需要设置前一个节点值，还不能挂起；第三步是因为开始的时候值是 0，通过外面方法 acquireQueued的 for 循环不断尝试设置为 -1，所以再未成功之前是不能挂起的。</p>\n<p>（3）通过 LockSupport.park(this) 来挂起线程，设置线程中断状态。</p>\n<div><pre><code><span>// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span>\n<span>// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span>\n<span>// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span>\n<span>// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span>\n<span>final</span> <span>boolean</span> <span>acquireQueued</span><span>(</span><span>final</span> <span>Node</span> node<span>,</span> <span>int</span> arg<span>)</span> <span>{</span>\n    <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>boolean</span> interrupted <span>=</span> <span>false</span><span>;</span>\n        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n            <span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>\n            <span>// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span>\n            <span>// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span>\n            <span>// 所以当前节点可以去试抢一下锁</span>\n            <span>// 这里我们说一下，为什么可以去试试：</span>\n            <span>// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span>\n            <span>// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span>\n            <span>// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span>\n            <span>// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span>\n            <span>if</span> <span>(</span>p <span>==</span> head <span>&amp;&amp;</span> <span>tryAcquire</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>\n                <span>setHead</span><span>(</span>node<span>)</span><span>;</span>\n                p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>\n                failed <span>=</span> <span>false</span><span>;</span>\n                <span>return</span> interrupted<span>;</span>\n            <span>}</span>\n            <span>// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span>\n            <span>// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span>\n            <span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>\n                <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>\n                interrupted <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>// 什么时候 failed 会为 true???</span>\n        <span>// tryAcquire() 方法抛异常的情况</span>\n        <span>if</span> <span>(</span>failed<span>)</span>\n            <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：\"当前线程没有抢到锁，是否需要挂起当前线程？\"</span>\n<span>// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span>\n<span>private</span> <span>static</span> <span>boolean</span> <span>shouldParkAfterFailedAcquire</span><span>(</span><span>Node</span> pred<span>,</span> <span>Node</span> node<span>)</span> <span>{</span>\n    <span>int</span> ws <span>=</span> pred<span>.</span>waitStatus<span>;</span>\n    <span>// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span>\n    <span>if</span> <span>(</span>ws <span>==</span> <span>Node</span><span>.</span>SIGNAL<span>)</span>\n        <span>return</span> <span>true</span><span>;</span>\n\n    <span>// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span>\n    <span>// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span>\n    <span>// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span>\n    <span>// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span>\n    <span>// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span>\n    <span>if</span> <span>(</span>ws <span>></span> <span>0</span><span>)</span> <span>{</span>\n        <span>/*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */</span>\n        <span>do</span> <span>{</span>\n            node<span>.</span>prev <span>=</span> pred <span>=</span> pred<span>.</span>prev<span>;</span>\n        <span>}</span> <span>while</span> <span>(</span>pred<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span><span>;</span>\n        pred<span>.</span>next <span>=</span> node<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>/*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */</span>\n        <span>// 仔细想想，如果进入到这个分支意味着什么</span>\n        <span>// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span>\n        <span>// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span>\n        <span>// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span>\n        <span>// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span>\n        <span>compareAndSetWaitStatus</span><span>(</span>pred<span>,</span> ws<span>,</span> <span>Node</span><span>.</span>SIGNAL<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 这个方法返回 false，那么会再走一次 for 循序，</span>\n    <span>//     然后再次进来此方法，此时会从第一个分支返回 true</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n\n<span>// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span>\n<span>// 这个方法结束根据返回值我们简单分析下：</span>\n<span>// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span>\n<span>//        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span>\n<span>// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span>\n\n<span>// 跳回到前面是这个方法</span>\n<span>// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>\n<span>//                parkAndCheckInterrupt())</span>\n<span>//                interrupted = true;</span>\n\n<span>// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span>\n<span>// 那么需要执行parkAndCheckInterrupt():</span>\n\n<span>// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span>\n<span>// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span>\n<span>private</span> <span>final</span> <span>boolean</span> <span>parkAndCheckInterrupt</span><span>(</span><span>)</span> <span>{</span>\n    <span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>this</span><span>)</span><span>;</span>  <span>//在这里被挂起了</span>\n    <span>return</span> <span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>;</span> <span>// ????????????????????这里中断是为什么？？？？直接挂起不行吗？？？？</span>\n<span>}</span>\n\n<span>// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span>\n\n<span>// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span>\n\n<span>// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span>\n<span>// => 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br></div></div><p>4、selfInterrupt()；</p>\n<p>在 LockSupport.park 挂起被唤醒后</p>\n<ul>\n<li>如果线程没有被中断过，返回 false。接着继续执行 acquireQueued，因为是被唤醒的，按照队列的特性，当前节点的前一个节点就是 head。然后接着当前线程接着尝试获得锁\n<ul>\n<li>获取锁失败：因为前一个节点 waitStatus = -1，所以 shouldParkAfterFailedAcquire 返回 true 直接中断等待下一次抢锁。</li>\n<li>获取锁成功：把当前节点设为头节点，返回 interrupted false，不执行执行 selfInterrupt。</li>\n</ul>\n</li>\n<li>如果这里是通过中断唤起线程，返回 true。接着继续执行 acquireQueued，设置 interrupted = true;重点来了，如果这时候：\n<ul>\n<li>这个节点前一个节点不是头结点：相当于把当前线程唤醒后，查了一下，发现没啥事可做，还是会继续挂起。</li>\n<li>如果这个节点前一个节点是头结点：会尝试获取下锁，成功了后就返回了 interrupted = true，最后执行 selfInterrupt() 中断当前线程。目的是啥？？？？？通过其他线程中断当前线程，唤起当线程，目的是自己中断自己当前线程？？可能是这个中断在其他地方有其他作用吧。</li>\n</ul>\n</li>\n</ul>\n<div><pre><code><span>// 当线程唤醒后，会再次尝试获得锁。</span>\n<span>if</span> <span>(</span>p <span>==</span> head <span>&amp;&amp;</span> <span>tryAcquire</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>\n    <span>setHead</span><span>(</span>node<span>)</span><span>;</span> <span>// 把当前节点设置为头结点</span>\n    p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC   // 头结点不要了</span>\n    failed <span>=</span> <span>false</span><span>;</span>\n    <span>return</span> interrupted<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h5 id=\"这里补充一个真正的取消队列\"> 这里补充一个真正的取消队列</h5>\n<p>ReentrantLock 的另一个 lock 方法：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>lockInterruptibly</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n    sync<span>.</span><span>acquireInterruptibly</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>源码没什么差别，就是在上面第二种中断唤醒线程的时候，直接抛异常。最后这个 cancelAcquire 就会把当前节点踢出去（肝不动，不看源码了）</p>\n<div><pre><code><span>try</span><span>{</span>\n    <span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>\n        <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>\n        <span>// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span>\n        <span>// 这里不再只是标记这个方法的返回值代表中断状态</span>\n        <span>// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span>\n        <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span> <span>finally</span> <span>{</span>\n    <span>if</span> <span>(</span>failed<span>)</span>\n        <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。</p>\n<h3 id=\"解锁-unlock\"> 解锁 unlock</h3>\n<p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p>\n<p>unlock() -&gt; release()。调用的是 ReenLock 内部的 Sync 的实现，底层是 AQS 提供的 releas()</p>\n<div><pre><code><span>// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span>\n<span>public</span> <span>void</span> <span>unlock</span><span>(</span><span>)</span> <span>{</span>\n    sync<span>.</span><span>release</span><span>(</span><span>1</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>final</span> <span>boolean</span> <span>release</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n    <span>// 往后看吧</span>\n    <span>if</span> <span>(</span><span>tryRelease</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>\n        <span>Node</span> h <span>=</span> head<span>;</span>\n        <span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h<span>.</span>waitStatus <span>!=</span> <span>0</span><span>)</span>\n            <span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>1、尝试释放锁。</p>\n<p>比较简单，是当前线程持有锁，减去 state。因为 ReentrantLock 是可重入的，所以在全部释放后，需要把独占线程设为 null。</p>\n<div><pre><code><span>// 回到ReentrantLock看tryRelease方法</span>\n<span>protected</span> <span>final</span> <span>boolean</span> <span>tryRelease</span><span>(</span><span>int</span> releases<span>)</span> <span>{</span>\n    <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span> <span>-</span> releases<span>;</span>\n    <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span> <span>!=</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span>\n        <span>throw</span> <span>new</span> <span>IllegalMonitorStateException</span><span>(</span><span>)</span><span>;</span>\n    <span>// 是否完全释放锁</span>\n    <span>boolean</span> free <span>=</span> <span>false</span><span>;</span>\n    <span>// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span>\n    <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        free <span>=</span> <span>true</span><span>;</span>\n        <span>setExclusiveOwnerThread</span><span>(</span><span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>setState</span><span>(</span>c<span>)</span><span>;</span>\n    <span>return</span> free<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>2、唤醒后续节点。</p>\n<p>如果上一步中，完全释放了锁，即 state =0后，开始唤醒后续节点，前提是这个 head 还存在并且状态不等于 0（因为头节点为空 或者 头节点 == 0 说明阻塞队列空的，不需要唤醒节点的）。</p>\n<p>（1）首先如果头节点 &lt; 0：将头节点设置为 0；</p>\n<p>（2）从尾节点向前找到 &lt;= 0 的所有节点中排在最前面的(fuck，所有队列中的线程当然 waitStaus &lt;= 0了，正常执行肯定找到的是 head 后面第一个节点 了，即当前节点 = head.next！！！)。（可能小于等于 0 的都需要唤醒？？因为是公平锁，所以唤醒最前面的？）</p>\n<p>（3）唤醒线程</p>\n<div><pre><code><span>// 唤醒后继节点</span>\n<span>// 从上面调用处知道，参数node是head头结点</span>\n<span>private</span> <span>void</span> <span>unparkSuccessor</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>\n\n    <span>int</span> ws <span>=</span> node<span>.</span>waitStatus<span>;</span>\n    <span>// 如果head节点当前waitStatus&lt;0, 将其修改为0</span>\n    <span>if</span> <span>(</span>ws <span>&lt;</span> <span>0</span><span>)</span>\n        <span>compareAndSetWaitStatus</span><span>(</span>node<span>,</span> ws<span>,</span> <span>0</span><span>)</span><span>;</span>\n\n    <span>// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span>\n    <span>// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span>\n    <span>Node</span> s <span>=</span> node<span>.</span>next<span>;</span>\n    <span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span> <span>{</span>\n        s <span>=</span> <span>null</span><span>;</span>\n        <span>// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span>\n        <span>for</span> <span>(</span><span>Node</span> t <span>=</span> tail<span>;</span> t <span>!=</span> <span>null</span> <span>&amp;&amp;</span> t <span>!=</span> node<span>;</span> t <span>=</span> t<span>.</span>prev<span>)</span>\n            <span>if</span> <span>(</span>t<span>.</span>waitStatus <span>&lt;=</span> <span>0</span><span>)</span>\n                s <span>=</span> t<span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>s <span>!=</span> <span>null</span><span>)</span>\n        <span>// 唤醒线程</span>\n        <span>LockSupport</span><span>.</span><span>unpark</span><span>(</span>s<span>.</span>thread<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>被唤醒线程后，就接着之前 lock 的那里继续执行。</p>\n<div><pre><code><span>private</span> <span>final</span> <span>boolean</span> <span>parkAndCheckInterrupt</span><span>(</span><span>)</span> <span>{</span>\n    <span>LockSupport</span><span>.</span><span>park</span><span>(</span><span>this</span><span>)</span><span>;</span> <span>// 刚刚线程被挂起在这里了</span>\n    <span>return</span> <span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"补充\"> 补充：</h3>\n<h4 id=\"为什么第一次-tryacquire-成功直接返回了\"> 为什么第一次 tryAcquire 成功直接返回了？</h4>\n<p>第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p>\n<h2 id=\"非公平锁\"> 非公平锁</h2>\n<p>非公平锁和公平锁的区别就两点：</p>\n<p>1、开始就 cas 抢锁，成功了就设置独占锁为自己。</p>\n<p>2、重载了 traAcquire，区别就是没有对阻塞队列判断，直接用 CAS 抢锁。</p>\n<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>NonfairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>\n    <span>final</span> <span>void</span> <span>lock</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span>\n        <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span>\n            <span>setExclusiveOwnerThread</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>else</span>\n            <span>acquire</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>// AbstractQueuedSynchronizer.acquire(int arg)</span>\n    <span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span>\n            <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>\n            <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>protected</span> <span>final</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n        <span>return</span> <span>nonfairTryAcquire</span><span>(</span>acquires<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>/**\n * Performs non-fair tryLock.  tryAcquire is implemented in\n * subclasses, but both need nonfair try for trylock method.\n */</span>\n<span>final</span> <span>boolean</span> <span>nonfairTryAcquire</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n    <span>final</span> <span>Thread</span> current <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>// 这里没有对阻塞队列进行判断</span>\n        <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span><span>0</span><span>,</span> acquires<span>)</span><span>)</span> <span>{</span>\n            <span>setExclusiveOwnerThread</span><span>(</span>current<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>else</span> <span>if</span> <span>(</span>current <span>==</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>int</span> nextc <span>=</span> c <span>+</span> acquires<span>;</span>\n        <span>if</span> <span>(</span>nextc <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>\n            <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>\"Maximum lock count exceeded\"</span><span>)</span><span>;</span>\n        <span>setState</span><span>(</span>nextc<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id=\"总结\"> 总结</h2>\n<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>\n",
      "date_modified": "2022-04-29T06:23:43.137Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "并发编程"
      ]
    },
    {
      "title": "对实例方法上锁：",
      "url": "https://fmiles.cn/java/jvm/bytecode/synchronized%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E5%88%86%E6%9E%90/",
      "id": "https://fmiles.cn/java/jvm/bytecode/synchronized%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E5%88%86%E6%9E%90/",
      "content_html": "<h5 id=\"对实例方法上锁\"> 对实例方法上锁：</h5>\n<div><pre><code><span>private</span> <span>synchronized</span> <span>void</span> <span>setX</span><span>(</span><span>int</span> x<span>)</span><span>{</span>\n       <span>this</span><span>.</span>x <span>=</span> x<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>没加 synchronized 的反编译结果：</p>\n<div><pre><code> <span>private</span> <span>void</span> <span>setX</span><span>(</span><span>int</span><span>)</span><span>;</span>\n    descriptor<span>:</span> <span>(</span><span>I</span><span>)</span><span>V</span>\n    flags<span>:</span> ACC_PRIVATE\n    <span>Code</span><span>:</span>\n      stack<span>=</span><span>2</span><span>,</span> locals<span>=</span><span>2</span><span>,</span> args_size<span>=</span><span>2</span>\n         <span>0</span><span>:</span> aload_0\n         <span>1</span><span>:</span> iload_1\n         <span>2</span><span>:</span> putfield      #<span>4</span>                  <span>// Field x:I</span>\n         <span>5</span><span>:</span> <span>return</span>\n      <span>LineNumberTable</span><span>:</span>\n        line <span>26</span><span>:</span> <span>0</span>\n        line <span>27</span><span>:</span> <span>5</span>\n      <span>LocalVariableTable</span><span>:</span>\n        <span>Start</span>  <span>Length</span>  <span>Slot</span>  <span>Name</span>   <span>Signature</span>\n            <span>0</span>       <span>6</span>     <span>0</span>  <span>this</span>   <span>Lcom</span><span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest2</span><span>;</span>\n            <span>0</span>       <span>6</span>     <span>1</span>     x   <span>I</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>加 synchronized 的反编译结果：</p>\n<div><pre><code><span>private</span> <span>synchronized</span> <span>void</span> <span>setX</span><span>(</span><span>int</span><span>)</span><span>;</span>\n    descriptor<span>:</span> <span>(</span><span>I</span><span>)</span><span>V</span>\n    flags<span>:</span> ACC_PRIVATE<span>,</span> ACC_SYNCHRONIZED\n    <span>Code</span><span>:</span>\n      stack<span>=</span><span>2</span><span>,</span> locals<span>=</span><span>2</span><span>,</span> args_size<span>=</span><span>2</span>\n         <span>0</span><span>:</span> aload_0\n         <span>1</span><span>:</span> iload_1\n         <span>2</span><span>:</span> putfield      #<span>4</span>                  <span>// Field x:I</span>\n         <span>5</span><span>:</span> <span>return</span>\n      <span>LineNumberTable</span><span>:</span>\n        line <span>26</span><span>:</span> <span>0</span>\n        line <span>27</span><span>:</span> <span>5</span>\n      <span>LocalVariableTable</span><span>:</span>\n        <span>Start</span>  <span>Length</span>  <span>Slot</span>  <span>Name</span>   <span>Signature</span>\n            <span>0</span>       <span>6</span>     <span>0</span>  <span>this</span>   <span>Lcom</span><span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest2</span><span>;</span>\n            <span>0</span>       <span>6</span>     <span>1</span>     x   <span>I</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>唯一的区别就是在 访问标志这里多了 ACC_SYNCHRONIZED。</p>\n<p>synchronized 修饰的实例方法的话，表示的是给当前对象加锁。它并不会管方法的描述符，故默认已经在code里面执行过了，moniterenter 和moniterexit 方法也会执行（表示对于对象的上锁和解锁）。</p>\n<p>可重入锁：一个线程拿到对象后调用 synchronized 修饰的方法，此方法里又调用此类的另外的 synchronized 修饰的方法，这里拿到了几个锁，entry count 就加几次（看官网moniterenter解释），那么就必须退出几次，即 moniterexit 几次，直到 entry count 变为0。</p>\n<p>能不用 synchronized  就不用，因为阻塞状态会浪费 cpu 资源。</p>\n<h5 id=\"对实例方法的某部分加锁\"> 对实例方法的某部分加锁：</h5>\n<div><pre><code>  <span>private</span> <span>void</span> <span>test</span><span>(</span><span>String</span> str<span>)</span><span>{</span>\n        <span>synchronized</span> <span>(</span>str<span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"hello word\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里方法的执行过程中就会出现 monitorexit，正常执行结束会规划锁并且跳转22行，即return。但是第二次出现的原因是，如果操作出现了问题，在退出程序之前，还得把锁退还，再抛出异常。</p>\n<div><pre><code><span>private</span> <span>void</span> <span>test</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>)</span><span>;</span>\n    descriptor<span>:</span> <span>(</span><span>Ljava</span><span>/</span>lang<span>/</span><span>String</span><span>;</span><span>)</span><span>V</span>\n    flags<span>:</span> ACC_PRIVATE\n    <span>Code</span><span>:</span>\n      stack<span>=</span><span>2</span><span>,</span> locals<span>=</span><span>4</span><span>,</span> args_size<span>=</span><span>2</span>\n         <span>0</span><span>:</span> aload_1\n         <span>1</span><span>:</span> dup\n         <span>2</span><span>:</span> astore_2\n         <span>3</span><span>:</span> monitorenter\n         <span>4</span><span>:</span> getstatic     #<span>12</span>                 <span>// Field java/lang/System.out:Ljava/io/PrintStream;</span>\n         <span>7</span><span>:</span> ldc           #<span>13</span>                 <span>// String hello word</span>\n         <span>9</span><span>:</span> invokevirtual #<span>14</span>                 <span>// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>\n        <span>12</span><span>:</span> aload_2\n        <span>13</span><span>:</span> monitorexit\n        <span>14</span><span>:</span> <span>goto</span>          <span>22</span>\n        <span>17</span><span>:</span> astore_3\n        <span>18</span><span>:</span> aload_2\n        <span>19</span><span>:</span> monitorexit\n        <span>20</span><span>:</span> aload_3\n        <span>21</span><span>:</span> athrow\n        <span>22</span><span>:</span> <span>return</span>\n      <span>Exception</span> table<span>:</span>\n         from    <span>to</span>  <span>target</span> type\n             <span>4</span>    <span>14</span>    <span>17</span>   any\n            <span>17</span>    <span>20</span>    <span>17</span>   any\n      <span>LineNumberTable</span><span>:</span>\n        line <span>32</span><span>:</span> <span>0</span>\n        line <span>33</span><span>:</span> <span>4</span>\n        line <span>34</span><span>:</span> <span>12</span>\n        line <span>35</span><span>:</span> <span>22</span>\n      <span>LocalVariableTable</span><span>:</span>\n        <span>Start</span>  <span>Length</span>  <span>Slot</span>  <span>Name</span>   <span>Signature</span>\n            <span>0</span>      <span>23</span>     <span>0</span>  <span>this</span>   <span>Lcom</span><span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest2</span><span>;</span>\n            <span>0</span>      <span>23</span>     <span>1</span>   str   <span>Ljava</span><span>/</span>lang<span>/</span><span>String</span><span>;</span>\n      <span>StackMapTable</span><span>:</span> number_of_entries <span>=</span> <span>2</span>\n        frame_type <span>=</span> <span>255</span> <span>/* full_frame */</span>\n          offset_delta <span>=</span> <span>17</span>\n          locals <span>=</span> <span>[</span> <span>class</span> com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest2</span><span>,</span> <span>class</span> java<span>/</span>lang<span>/</span><span>String</span><span>,</span> <span>class</span> java<span>/</span>lang<span>/</span><span>Object</span> <span>]</span>\n          stack <span>=</span> <span>[</span> <span>class</span> java<span>/</span>lang<span>/</span><span>Throwable</span> <span>]</span>\n        frame_type <span>=</span> <span>250</span> <span>/* chop */</span>\n          offset_delta <span>=</span> <span>4</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h5 id=\"对静态方法上锁\"> 对静态方法上锁：</h5>\n<p>当给 static 方法添加 synchronize 时，表示的是给当前类的Class对象上锁。这里就表示给 test 对象的Class 对象上锁。</p>\n<div><pre><code><span>public</span> <span>class</span> test<span>{</span>\n    <span>private</span> <span>synchronized</span> <span>static</span> <span>void</span> <span>test2</span><span>(</span><span>)</span><span>{</span>\n        \n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里其实就是类锁和对象锁的区别，一个是实例对象本身加锁，一个是 Class 对象。</p>\n",
      "date_modified": "2022-04-29T06:23:43.137Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "代理类Class对象生成的过程：",
      "url": "https://fmiles.cn/java/jvm/bytecode/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E5%88%86%E6%9E%90/",
      "id": "https://fmiles.cn/java/jvm/bytecode/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E5%88%86%E6%9E%90/",
      "content_html": "<h4 id=\"代理类class对象生成的过程\"> 代理类Class对象生成的过程：</h4>\n<p>1、newProxyInstance（）方法。里面生成代理类的Class对象</p>\n<div><pre><code><span>Proxy</span> <span>{</span>\n    <span>/** parameter types of a proxy class constructor */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span> <span>]</span> constructorParams <span>=</span>  <span>{</span> <span>InvocationHandler</span><span>.</span><span>class</span> <span>}</span><span>;</span>\n    <span>/**\n     * the invocation handler for this proxy instance.\n     * @serial\n     */</span>\n    <span>protected</span> <span>InvocationHandler</span> h<span>;</span>\n    \n    \n<span>@CallerSensitive</span>\n    <span>public</span> <span>static</span> <span>Object</span> <span>newProxyInstance</span><span>(</span><span>ClassLoader</span> loader<span>,</span>\n                                          <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces<span>,</span>\n                                          <span>InvocationHandler</span> h<span>)</span>\n        <span>throws</span> <span>IllegalArgumentException</span>\n    <span>{</span>\n        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>h<span>)</span><span>;</span>\n\n        <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> intfs <span>=</span> interfaces<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>\n        <span>final</span> <span>SecurityManager</span> sm <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>checkProxyAccess</span><span>(</span><span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>,</span> loader<span>,</span> intfs<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>/*\n         * Look up or generate the designated proxy class.\n         生成Class 对象\n         */</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> cl <span>=</span> <span>getProxyClass0</span><span>(</span>loader<span>,</span> intfs<span>)</span><span>;</span>\n\n        <span>/*\n         * Invoke its constructor with the designated invocation handler.\n         */</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>checkNewProxyPermission</span><span>(</span><span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>,</span> cl<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>// cl 指的就是 $Proxy0,获取其参数类型为 constructorParams（这里是InvocationHandler.class）的构造方法，也就是我们在$Proxy0 那里看见的构造方法。（constructorParams 构造器参数的类型）</span>\n            <span>final</span> <span>Constructor</span><span><span>&lt;</span><span>?</span><span>></span></span> cons <span>=</span> cl<span>.</span><span>getConstructor</span><span>(</span>constructorParams<span>)</span><span>;</span>\n            <span>final</span> <span>InvocationHandler</span> ih <span>=</span> h<span>;</span>\n            <span>if</span> <span>(</span><span>!</span><span>Modifier</span><span>.</span><span>isPublic</span><span>(</span>cl<span>.</span><span>getModifiers</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n                <span>AccessController</span><span>.</span><span>doPrivileged</span><span>(</span><span>new</span> <span>PrivilegedAction</span><span><span>&lt;</span><span>Void</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                    <span>public</span> <span>Void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                        <span>// 突破权限</span>\n                        cons<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                        <span>return</span> <span>null</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n            <span>}</span>\n           \n            <span>// 通过构造器对象调用newInstance创建RealSubject 代理类的实例，即$Proxy0的实例对象。这个有参构造会传入参数 invocationHandler （即自定义的 DynamicSubject）， 而 $Proxy0  的有参构造又会调用 Proxy 的有参构造并且把 invocationHandler传回来，也就是 Proxy.h 这个成员变量。</span>\n            <span>// 这里 new Object[]{h} 是参数值，代表的是DynamicSubject</span>\n            <span>return</span> cons<span>.</span><span>newInstance</span><span>(</span><span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span>h<span>}</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IllegalAccessException</span><span>|</span><span>InstantiationException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>e<span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InvocationTargetException</span> e<span>)</span> <span>{</span>\n            <span>Throwable</span> t <span>=</span> e<span>.</span><span>getCause</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>t <span>instanceof</span> <span>RuntimeException</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>(</span><span>RuntimeException</span><span>)</span> t<span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>t<span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> t<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>NoSuchMethodException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>e<span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><p>2、从 proxyClassCache 获取代理对象，已有的直接从缓存中获取，没有的则创建。</p>\n<div><pre><code> <span>private</span> <span>static</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getProxyClass0</span><span>(</span><span>ClassLoader</span> loader<span>,</span>\n                                           <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>.</span><span>.</span><span>.</span> interfaces<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>interfaces<span>.</span>length <span>></span> <span>65535</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"interface limit exceeded\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// If the proxy class defined by the given loader implementing</span>\n        <span>// the given interfaces exists, this will simply return the cached copy;</span>\n        <span>// otherwise, it will create the proxy class via the ProxyClassFactory</span>\n        <span>return</span> proxyClassCache<span>.</span><span>get</span><span>(</span>loader<span>,</span> interfaces<span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>3、get 方法内部，使用了函数式编程，比较麻烦，不直观。通过调用 supplier.get() 方法，而supplier对象则是通过 factory对象赋值，这个factory对象是supplier 的子类 ，而这里面的则是真正的 get 方法 。</p>\n<p>4、最后是通过 ProxyClassFactory 对象的 generateProxyClass 方法生成字节码数组。通过 definClass0 方法生成Class对象。</p>\n<div><pre><code><span>byte</span><span>[</span><span>]</span> proxyClassFile <span>=</span> <span>ProxyGenerator</span><span>.</span><span>generateProxyClass</span><span>(</span>    proxyName<span>,</span> interfaces<span>,</span> accessFlags<span>)</span><span>;</span>\n<span>return</span> <span>defineClass0</span><span>(</span>loader<span>,</span> proxyName<span>,</span> proxyClassFile<span>,</span> <span>0</span><span>,</span> proxyClassFile<span>.</span>length<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><hr>\n<h4 id=\"代理对象的生成\"> 代理对象的生成：</h4>\n<h5 id=\"动态代理类\"> 动态代理类：</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>DynamicSubject</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n\n    <span>private</span> <span>Object</span> sub<span>;</span>\n\n    <span>public</span> <span>DynamicSubject</span><span>(</span><span>Object</span> sub<span>)</span><span>{</span>\n        <span>this</span><span>.</span>sub <span>=</span> sub<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>// 这里传入的第一个参数，proxy，指的就是 $Proxy0即动态代理对象,</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before calling:\"</span><span>+</span>method<span>)</span><span>;</span>\n\n        <span>// 这里传入的第一个参数就是 RealSubject，</span>\n        method<span>.</span><span>invoke</span><span>(</span><span>this</span><span>.</span>sub<span>,</span>args<span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after calling:\"</span><span>+</span>method<span>)</span><span>;</span>\n\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h5 id=\"自定义的类\"> 自定义的类：</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>RealSubject</span> <span>implements</span> <span>Subject</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"From real subject\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h5 id=\"客户端\"> 客户端：</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 为了把生成的实例对象保存到磁盘上面. ProxyGenerator 类的属性</span>\n        <span>System</span><span>.</span><span>getProperties</span><span>(</span><span>)</span><span>.</span><span>put</span><span>(</span><span>\"sun.misc.ProxyGenerator.saveGeneratedFiles\"</span><span>,</span><span>\"true\"</span><span>)</span><span>;</span>\n\n        <span>RealSubject</span> rs <span>=</span> <span>new</span> <span>RealSubject</span><span>(</span><span>)</span><span>;</span>\n        <span>InvocationHandler</span> ds <span>=</span> <span>new</span> <span>DynamicSubject</span><span>(</span>rs<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> cls <span>=</span> rs<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 这种写法过于复杂，地下产生代理类的方法写入代理类本身即可。</span>\n        <span>Subject</span> subject <span>=</span> <span>(</span><span>Subject</span><span>)</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>cls<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span>cls<span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>ds<span>)</span><span>;</span>\n        subject<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>subject<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>subject<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>\n<div><pre><code>before calling<span>:</span><span>public</span> <span>abstract</span> <span>void</span> <span><span>com<span>.</span>jvm<span>.</span>bytecode<span>.</span></span>Subject</span><span>.</span><span>request</span><span>(</span><span>)</span>\n<span>From</span> real subject\nafter calling<span>:</span><span>public</span> <span>abstract</span> <span>void</span> <span><span>com<span>.</span>jvm<span>.</span>bytecode<span>.</span></span>Subject</span><span>.</span><span>request</span><span>(</span><span>)</span>\n<span>class</span> com<span>.</span>sun<span>.</span>proxy<span>.</span>$<span>Proxy0</span>\n<span>class</span> <span><span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span>Proxy</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>​        通过 newProxyInstance 方法创建了 Subject类型的代理对象，subject 指向的就是动态代理的对象。而subject真正指向的Class对象则是 $Proxy0,而这个 $Proxy0 的父类则是 Proxy。subject 在调用 request方法的时候，就会调用 $Proxy0 的request方法。而通过下面可知，调用  $Proxy0 的 request方法，实际上是调用 Proxy的h，根据上面的分析指导，Proxy.h 就是我们自定义的 DynamicSubject，故而后面的所有的 Proxy.h 的调用都是 DynamicSubject 里面的 invoke 方法。</p>\n<p>下面是 $Proxy0.class文件反编译出来的：</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> $<span>Proxy0</span> <span>extends</span> <span>Proxy</span> <span>implements</span> <span>Subject</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Method</span> m1<span>;</span>\n    <span>private</span> <span>static</span> <span>Method</span> m2<span>;</span>\n    <span>private</span> <span>static</span> <span>Method</span> m3<span>;</span>\n    <span>private</span> <span>static</span> <span>Method</span> m0<span>;</span>\n\n    \n    <span>public</span> $<span>Proxy0</span><span>(</span><span>InvocationHandler</span> var1<span>)</span> <span>throws</span>  <span>{</span>\n        <span>super</span><span>(</span>var1<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 这里重写了 Object 的三个方法，equals，toString，hashCode，，因此调用这些方法的实际对象都是InvocationHandler，而其他属于 Object 的方法则是直接调用 Object 本身的。</span>\n    <span>public</span> <span>final</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> var1<span>)</span> <span>throws</span>  <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> <span>(</span><span>Boolean</span><span>)</span><span>super</span><span>.</span>h<span>.</span><span>invoke</span><span>(</span><span>this</span><span>,</span> m1<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span>var1<span>}</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> <span>|</span> <span>Error</span> var3<span>)</span> <span>{</span>\n            <span>throw</span> var3<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> var4<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>UndeclaredThrowableException</span><span>(</span>var4<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>final</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>throws</span>  <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> <span>(</span><span>String</span><span>)</span><span>super</span><span>.</span>h<span>.</span><span>invoke</span><span>(</span><span>this</span><span>,</span> m2<span>,</span> <span>(</span><span>Object</span><span>[</span><span>]</span><span>)</span><span>null</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> <span>|</span> <span>Error</span> var2<span>)</span> <span>{</span>\n            <span>throw</span> var2<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> var3<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>UndeclaredThrowableException</span><span>(</span>var3<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>final</span> <span>void</span> <span>request</span><span>(</span><span>)</span> <span>throws</span>  <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>// 这里的 super.h 就是 传入 Proxy 对象的 InvocationHandler，也就是我们自定义的DynamicSubject，最后实际就是调用我们定义在 DynamicSubject 里面的 invoke 方法。</span>\n            <span>super</span><span>.</span>h<span>.</span><span>invoke</span><span>(</span><span>this</span><span>,</span> m3<span>,</span> <span>(</span><span>Object</span><span>[</span><span>]</span><span>)</span><span>null</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> <span>|</span> <span>Error</span> var2<span>)</span> <span>{</span>\n            <span>throw</span> var2<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> var3<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>UndeclaredThrowableException</span><span>(</span>var3<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>final</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>throws</span>  <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>return</span> <span>(</span><span>Integer</span><span>)</span><span>super</span><span>.</span>h<span>.</span><span>invoke</span><span>(</span><span>this</span><span>,</span> m0<span>,</span> <span>(</span><span>Object</span><span>[</span><span>]</span><span>)</span><span>null</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> <span>|</span> <span>Error</span> var2<span>)</span> <span>{</span>\n            <span>throw</span> var2<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> var3<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>UndeclaredThrowableException</span><span>(</span>var3<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            m1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"equals\"</span><span>,</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>)</span><span>;</span>\n            m2 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"toString\"</span><span>)</span><span>;</span>\n            m3 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"com.jvm.bytecode.Subject\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"request\"</span><span>)</span><span>;</span>\n            m0 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"java.lang.Object\"</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"hashCode\"</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>NoSuchMethodException</span> var2<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NoSuchMethodError</span><span>(</span>var2<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> var3<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>NoClassDefFoundError</span><span>(</span>var3<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div>",
      "date_modified": "2022-04-29T06:23:43.139Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "字段表集合：",
      "url": "https://fmiles.cn/java/jvm/bytecode/%E5%AD%97%E6%AE%B5%E8%A1%A8/",
      "id": "https://fmiles.cn/java/jvm/bytecode/%E5%AD%97%E6%AE%B5%E8%A1%A8/",
      "content_html": "<h4 id=\"字段表集合\"> 字段表集合：</h4>\n<blockquote>\n<p>​        字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。</p>\n</blockquote>\n<h5 id=\"字段表结构\"> 字段表结构：</h5>\n<p><img src=\"./images/1204119-20190317130434210-1045979033-1649057520055.png\" alt=\"img\" loading=\"lazy\"></p>\n<h5 id=\"举例说明\"> 举例说明：</h5>\n<h5 id=\"class文件\"> class文件：</h5>\n<p><img src=\"./images/1581599540431-1649057520055.png\" alt=\"1581599540431\" loading=\"lazy\"></p>\n<h5 id=\"反编译结果\"> 反编译结果：</h5>\n<p>0x 00 02：字段的访问控制符为私有</p>\n<p>0x 00 05：名称的索引，索引为常量池的第5项，这里的字段名称为 a</p>\n<p>0x 00 06 ：字段的描述，索引为常量池的第6项，根据定义字段的描述为其类型，I</p>\n<p>0x 00 00 ：说明属性总数为0，故没有后面的属性项的信息。</p>\n<div><pre><code><span>Constant</span> pool<span>:</span>\n<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n     #<span>5</span> <span>=</span> <span>Utf8</span>               a\n     #<span>6</span> <span>=</span> <span>Utf8</span>               <span>I</span>\n<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "date_modified": "2022-04-29T06:23:43.140Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "字节码结构",
      "url": "https://fmiles.cn/java/jvm/bytecode/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/",
      "id": "https://fmiles.cn/java/jvm/bytecode/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/",
      "content_html": "<h2 id=\"字节码结构\"> 字节码结构</h2>\n<h4 id=\"字节码文件的组织结构\"> 字节码文件的组织结构</h4>\n<div><pre><code><span>ClassFile</span> <span>{</span>\n    u4             magic<span>;</span> <span>//Class 文件的标志</span>\n    u2             minor_version<span>;</span><span>//Class 的小版本号  1.1  后面 .1 就是小版本号</span>\n    u2             major_version<span>;</span><span>//Class 的大版本号</span>\n    u2             constant_pool_count<span>;</span><span>//常量池的数量</span>\n    cp_info        constant_pool<span>[</span>constant_pool_count<span>-</span><span>1</span><span>]</span><span>;</span><span>//常量池</span>\n    u2             access_flags<span>;</span><span>//Class 的访问标记</span>\n    u2             this_class<span>;</span><span>//当前类</span>\n    u2             super_class<span>;</span><span>//父类</span>\n    u2             interfaces_count<span>;</span><span>//接口数量</span>\n    u2             interfaces<span>[</span>interfaces_count<span>]</span><span>;</span><span>//一个类可以实现多个接口</span>\n    u2             fields_count<span>;</span><span>//Class 文件的字段属性</span>\n    field_info     fields<span>[</span>fields_count<span>]</span><span>;</span><span>//一个类可以有多个字段</span>\n    u2             methods_count<span>;</span><span>//Class 文件的方法数量</span>\n    method_info    methods<span>[</span>methods_count<span>]</span><span>;</span><span>//一个类可以有个多个方法</span>\n    u2             attributes_count<span>;</span><span>//此类的属性表中的属性数</span>\n    attribute_info attributes<span>[</span>attributes_count<span>]</span><span>;</span><span>//属性表集合</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h5 id=\"class字节码中有两种数据类型\"> Class字节码中有两种数据类型：</h5>\n<ul>\n<li>字节数据直接量：这是基本的数据类型。共细分为 u1、u2、u4、u8四种，分别代表连续的 1个字节、2 个字节、4个字节、8个字节组成的整体数据。</li>\n<li>表（数组）：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在：组成表的成分所在的位置都是已经严格定义好的。最典型的就是常量池表。</li>\n</ul>\n<h5 id=\"组织结构补充说明\"> 组织结构补充说明：</h5>\n<p><img src=\"./images/1581596034961.png\" alt=\"1581596034961\" loading=\"lazy\"></p>\n<h5 id=\"补充\"> 补充：</h5>\n<p>一个字节 8 位二进制，一个 16 进制 = 4 位二进制，故1个字节 = 2 个16 进制.（1111 = f）</p>\n<p>如下，CA 是两位十六进制，表示一个字节。</p>\n<p><img src=\"./images/1581511989359.png\" alt=\"1581511989359\" loading=\"lazy\"></p>\n<p>​</p>\n<h4 id=\"_1、魔数\"> 1、魔数</h4>\n<div><pre><code>u4             magic<span>;</span> <span>//Class 文件的标志</span>\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<p>所有的 .class 字节码文件的前 4 个字节都是魔数，魔数值为固定值：0xCAFEBABE （十六进制必须0x 开头）</p>\n</blockquote>\n<p>如果不是这四个字节开头的，一定不是合法的字节码文件。（通过 winhex 查看的 .class 文件）</p>\n<p><img src=\"./images/1581512834054.png\" alt=\"1581512834054\" loading=\"lazy\"></p>\n<h4 id=\"_2、版本号\"> 2、版本号</h4>\n<div><pre><code>u2             minor_version<span>;</span><span>//Class 的小版本号</span>\nu2             major_version<span>;</span><span>//Class 的大版本号</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>魔数之后的四位是版本信息，前两个字节表示 minor version（次版本号），后两个字节表示 major version （主版本号）</p>\n</blockquote>\n<h5 id=\"反编译结果\"> 反编译结果：</h5>\n<p>次版本号是 0，主版本号是 50. (这里是十进制的),50对应的是jdk6，52对应的是 jdk 8。所以该文件的版本号为：1.6.0。</p>\n<p>jdk 是向下兼容的，版本号为 1.8 的可以识别和加载 1.8 之前生成的字节码文件。</p>\n<p><img src=\"./images/1581512985309.png\" alt=\"1581512985309\" loading=\"lazy\"></p>\n<p>可以通过 java -version 查看版本：</p>\n<p>0 之后的那个不是 次版本号，是更新版本号，一般在官方网站显示为 1.8.0u221 这样。</p>\n<p><img src=\"./images/1581513788671.png\" alt=\"1581513788671\" loading=\"lazy\"></p>\n<h5 id=\"源文件\"> 源文件：</h5>\n<p>前两位代表此版本号，后两位代表主版本号。</p>\n<p><img src=\"./images/1581513071935.png\" alt=\"1581513071935\" loading=\"lazy\"></p>\n<h4 id=\"_3、常量池\"> 3、常量池</h4>\n<h4 id=\"_4、access-flag-访问标志符\"> 4、Access_Flag 访问标志符</h4>\n<blockquote>\n<p>​     访问标志符信息包括该 Class文件是类还是接口，是否被定义成 public，是否是 abstract，如果是类，是否被声明成 final。通过上面的源代码，我们知道该文件是类并且是 public。</p>\n</blockquote>\n<p><img src=\"./images/20141009130149170.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>0x 00 00 代表是没有访问修饰符号。</p>\n<p>注意：</p>\n<p>这里发现字节码文件出现 21 并不在上面表中，这是因为 jvm 会把所有的标志符做并集处理。</p>\n<p>0x 00 21： 是0x 0020 和0x 0001 的并集，表示ACC_PUBLIC与 ACC_SUPER，表示本类是 public类且可以调用父类的方法。</p>\n<p><strong><img src=\"./images/1581597217517.png\" alt=\"  \" loading=\"lazy\"></strong></p>\n<h4 id=\"_5、当前类-this-class-、父类-super-class-、接口-interfaces-索引集合\"> 5、当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h4>\n<div><pre><code>u2             this_class<span>;</span><span>//当前类</span>\nu2             super_class<span>;</span><span>//父类</span>\nu2             interfaces_count<span>;</span><span>//接口</span>\nu2             interfaces<span>[</span>interfaces_count<span>]</span><span>;</span><span>//一个类可以实现多个接口</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p>\n<p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>\n<p>6、父类名</p>\n<p>7、接口个数和接口信息</p>\n<p>10、字节码文件的属性</p>\n",
      "date_modified": "2022-04-29T06:23:43.141Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "常量池(constant pool)",
      "url": "https://fmiles.cn/java/jvm/bytecode/%E5%B8%B8%E9%87%8F%E6%B1%A0/",
      "id": "https://fmiles.cn/java/jvm/bytecode/%E5%B8%B8%E9%87%8F%E6%B1%A0/",
      "content_html": "<h4 id=\"常量池-constant-pool\"> 常量池(constant pool)</h4>\n<blockquote>\n<p>1、     紧接着主主版本号之后的就是常量池入口。一个java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看做是 Class 文件的资源仓库，比如说 Java类中定义的方法与变量信息，都是存储在常量池中。</p>\n<p>2、      常量池中主要存储两类常量：字面量和与符号引用。字面量如文本字符串，Java中声明为 final 的常量值等，而符号引用如类的全局限定名，字段的名称和描述符，方法的名称和描述符等。</p>\n<p>​        常量池的总体结构：Java 类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池紧跟在主版本号后面，占据 两个字节；常量池数组则紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不同，但是每一种元素的第一个数据都是一个一个 u1 类型，该字节是个标志位，占据1个字节。JVM 在解析常量池时，会根据这个 u1 类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数 = 常量池数 -1。（其中 0 暂不使用），目的是满足某些常量池索引值的数据在特定情况下需要表达【不引用任何一个常量池】的含义；根本原因在于，索引值为 0 也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应 null 值；所以，常量池的索引从 1 而非 0 开始。</p>\n<p>3、   在jvm 规范中，每个变量/ 字段都有描述信息，描述信息主要作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述规则，基本数据类型和代表无返回值的 void 的类型都用一个大写字符来表示，对象类型则使用字符 L 加对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如下所示：</p>\n<p>B - byte，C - char，D - double，F - float，I - int，J - long， S - short ，Z - boolean，V - void,</p>\n<p>L - 对象类型，如 Ljava/lang/String</p>\n<p>4、    对于数组来说，每一个维度使用一个前置的 [ 来表示，如 int[] 被记录为 [I, String[] []被记录为 [[LJava/lang/String；</p>\n<p>5、用描述符来描述方法的时候，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组（）之内，如方法：String getName( int id , String name) 的描述符为：(I,Ljava/lang/String;)Ljava/lang/String;</p>\n</blockquote>\n<h5 id=\"常量池在字节码文件中的位置\"> 常量池在字节码文件中的位置</h5>\n<p>在class文件中的魔数、副版本号、主版本之后，紧接着就是常量池的数据区域了，如下图用红线包括的位置：</p>\n<p>![img](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\jvm\\bytecode\\images\\20141010133603275?lastModify=1651212362)</p>\n<h5 id=\"常量池结构\"> 常量池结构：</h5>\n<p>![1581516599910](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\jvm\\bytecode\\images\\1581516599910.png?lastModify=1651212362)</p>\n<p>上面的表中描述了 11 种数据类型，其实在 jdk 1.7 之后又增加了 3 种，CONSTANT_MethodHandle_info,CONSTANT_MethodType_info,CONSTANT_InvokeDynamic_info.</p>\n<hr>\n<h4 id=\"具体分析\"> 具体分析：</h4>\n<h5 id=\"java-代码\"> Java 代码：</h5>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvm<span>.</span>bytecode</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>MyTest1</span> <span>{</span>\n    <span>private</span> <span>int</span> a <span>=</span> <span>1</span><span>;</span>\n\n    <span>public</span> <span>int</span> <span>getA</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> a<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setA</span><span>(</span><span>int</span> a<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>a <span>=</span> a<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h5 id=\"class文件\"> class文件：</h5>\n<p>![1581517280047](file://C:/Users/18496/Desktop/docs/fmiles/docs/java/jvm/bytecode/images/1581517280047.png?lastModify=1651212362)</p>\n<h5 id=\"反编译结果\"> 反编译结果：</h5>\n<p>第一个常量池项 #1：</p>\n<p>u1 值为0A,十进制11： CONSTANT_Methodref_info。由表知，后 4 位，声明这个方法的类和方法名称及类型描述符的索引项，分别为 4 和 20。这里并不直观，直接查看反编译文件：</p>\n<p>u2 ，u1后两位，值为04，十进制4：索引指向常量池第四项#4，#4引用#23，返回方法所属类的完全限定名 java/lang/Object</p>\n<p>u2，u2后两位， 值为14，十进制20：索引指向常量池第二十项#20，#20引用#7，#8。#7返回方法名称 <init>，<init> 代表的是构造方法，默认生成的。#8返回描述信息（）v，这里表示的是参数为空，没有返回值的方法。</p>\n<p>整个方法的信息则是 java/lang/Object.&quot;<init>&quot;😦)V。即方法所属类.方法名称：(参数列表)返回值类型</p>\n<p>第二个常量池项 #2：</p>\n<p>u1值为09 ：CONSTANT_Fieldref_info。后4位，声明字段的类或接口和字段描述符的索引。</p>\n<p>u2 ，u1后两位，值为03，十进制3：索引指向常量池第三项#3，#3引用22，返回字段所属类名称 com/jvm/bytecode/MyTest1</p>\n<p>u2 ，u2后两位，值为15，十进制21：索引指向常量池第二十一项#21，#21引用#5，#6。#5返回名称 a,#6返回描述信息 I。</p>\n<p>整个字段的信息则是 com/jvm/bytecode/MyTest1.a:I。即字段所属类.字段名称：字段类型</p>\n<p>第三个常量池项 #3：</p>\n<p>u1值为07：CONSTANT_Class_info。后两位，类的全限定名</p>\n<p>u2，u1后两位，值为16,十进制20：索引指向索引指向常量池第二十项#20，返回类的全限定名称。</p>\n<p>第五个常量池 #5：</p>\n<p>u1值为01：CONSTANT_Utf8_info</p>\n<p>u2，u1后两位，值为01，十进制1：表示后面字符串长度为1，即只选择一个字节。</p>\n<p>u1，u2后一位，值为61：表示的是ASCII 的a。这里的一位表示的是每一位数字对应的都是ASCII码表的一个字符。</p>\n<p>其余相同的就不分析了。。。。。。</p>\n<div><pre><code><span>Constant</span> pool<span>:</span>\n   #<span>1</span> <span>=</span> <span>Methodref</span>          #<span>4.</span>#<span>20</span>         <span>// java/lang/Object.\"&lt;init>\":()V</span>\n   #<span>2</span> <span>=</span> <span>Fieldref</span>           #<span>3.</span>#<span>21</span>         <span>// com/jvm/bytecode/MyTest1.a:I</span>\n   #<span>3</span> <span>=</span> <span>Class</span>              #<span>22</span>            <span>// com/jvm/bytecode/MyTest1</span>\n   #<span>4</span> <span>=</span> <span>Class</span>              #<span>23</span>            <span>// java/lang/Object</span>\n   #<span>5</span> <span>=</span> <span>Utf8</span>               a\n   #<span>6</span> <span>=</span> <span>Utf8</span>               <span>I</span>\n   #<span>7</span> <span>=</span> <span>Utf8</span>               <span><span>&lt;</span>init<span>></span></span>\n   #<span>8</span> <span>=</span> <span>Utf8</span>               <span>(</span><span>)</span><span>V</span>\n   #<span>9</span> <span>=</span> <span>Utf8</span>               <span>Code</span>\n  #<span>10</span> <span>=</span> <span>Utf8</span>               <span>LineNumberTable</span>\n  #<span>11</span> <span>=</span> <span>Utf8</span>               <span>LocalVariableTable</span>\n  #<span>12</span> <span>=</span> <span>Utf8</span>               <span>this</span>\n  #<span>13</span> <span>=</span> <span>Utf8</span>               <span>Lcom</span><span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest1</span><span>;</span>\n  #<span>14</span> <span>=</span> <span>Utf8</span>               getA\n  #<span>15</span> <span>=</span> <span>Utf8</span>               <span>(</span><span>)</span><span>I</span>\n  #<span>16</span> <span>=</span> <span>Utf8</span>               setA\n  #<span>17</span> <span>=</span> <span>Utf8</span>               <span>(</span><span>I</span><span>)</span><span>V</span>\n  #<span>18</span> <span>=</span> <span>Utf8</span>               <span>SourceFile</span>\n  #<span>19</span> <span>=</span> <span>Utf8</span>               <span>MyTest1</span><span>.</span>java\n  #<span>20</span> <span>=</span> <span>NameAndType</span>        #<span>7</span><span>:</span>#<span>8</span>          <span>// \"&lt;init>\":()V</span>\n  #<span>21</span> <span>=</span> <span>NameAndType</span>        #<span>5</span><span>:</span>#<span>6</span>          <span>// a:I</span>\n  #<span>22</span> <span>=</span> <span>Utf8</span>               com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest1</span>\n  #<span>23</span> <span>=</span> <span>Utf8</span>               java<span>/</span>lang<span>/</span><span>Object</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>",
      "date_modified": "2022-04-29T06:23:43.142Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "方法表：",
      "url": "https://fmiles.cn/java/jvm/bytecode/%E6%96%B9%E6%B3%95%E8%A1%A8%E5%92%8C%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%E8%A1%A8/",
      "id": "https://fmiles.cn/java/jvm/bytecode/%E6%96%B9%E6%B3%95%E8%A1%A8%E5%92%8C%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7%E8%A1%A8/",
      "content_html": "<h4 id=\"方法表\"> 方法表：</h4>\n<p><img src=\"./images/1204119-20190317130450238-2064364892.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>前三个和字段和 field_info一样。</p>\n<h4 id=\"方法结构\"> 方法结构：</h4>\n<p><img src=\"./images/1581601294970.png\" alt=\"1581601294970\" loading=\"lazy\"></p>\n<hr>\n<h4 id=\"方法属性表\"> 方法属性表：</h4>\n<blockquote>\n<ul>\n<li>jvm预定了部分 attribute，但是编译器自己也可以实现自己的 attribute 写入 class 文件里，供运行时使用。</li>\n<li>不同的 attribute 通过 attribute_name_index 来区分。</li>\n<li>方法属性不等于局部变量。</li>\n</ul>\n</blockquote>\n<p><img src=\"./images/1581601549680.png\" alt=\"1581601549680\" loading=\"lazy\"></p>\n<h4 id=\"code-attribute-code-就是方法的属性之一\"> Code_attribute（Code 就是方法的属性之一）：</h4>\n<blockquote>\n<p>Code attribute 的作用是保存该方法的结构，如下所对应的字节码。</p>\n<p>这里的 Code_attribute 值得是在常量池中名称为 Code 的方法属性。则按照 Code 的结构来阅读字节码，不需要再看上面的方法属性结构。</p>\n</blockquote>\n<p><img src=\"./images/1581602168167.png\" alt=\"1581602168167\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>attribute_length表示 attribute 所包含的字节数，不包含attribute_name_index和attribute_length本身字段</p>\n</li>\n<li>\n<p>max_stack 表示这个方法运行的任何时刻所能达到的操作数栈的最大深度</p>\n</li>\n<li>\n<p>max_locals 表示方法执行期间创建的局部变量的数目（执行期间创建的局部变量可能是jvm做的事，我们看不见这个变量。而 args_size 代表的是入参个数），包含用来表示传入的参数的局部变量</p>\n</li>\n<li>\n<p>code_length 表示该方法所包含的字节码的字节数以及具体的指令码.从这个开始向后数 code_length  个字节才是真正执行的命令。</p>\n</li>\n<li>\n<p>code[code_length] 具体字节码即是该方法被调用时，虚拟机所执行的字节码,即反编译完代码那段。</p>\n</li>\n<li>\n<p>exception_table，这里存放的是处理异常的信息</p>\n</li>\n<li>\n<p>每个 exception_table 表项由 start_pc, end_pc,  handler_pc, catch_type组成</p>\n</li>\n<li>\n<p>start_pc 和 end_pc 表示在 code 数组中的从 start_pc 到 end_pc 处（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项来处理</p>\n</li>\n<li>\n<p>handler_pc 表示处理异常的代码的开始处。catch_type 表示会被处理的异常类型，它指向常量池的一个异常类。当catch_type为0时，表示处理所有的异常</p>\n</li>\n</ul>\n<h5 id=\"举例分析\"> 举例分析：</h5>\n<p>由下图可知，code_length 为 16，即后面 16 为都为 code 的内容。</p>\n<p><img src=\"./images/1581776473495.png\" alt=\"1581776473495\" loading=\"lazy\"></p>\n<p>下面的 Bytecode 的内容 0 -15 表示的就是16位。</p>\n<p>如 2A，<em>在官方的说明中助记符就是 aload_<n> （注意助记符真实并不存在于字节码文件中，是为了方便查看，真实的还是字节码文件中的 16 进制</em>）</p>\n<p>1 - 4 中间隔的两位则是 invokespecial 的参数索引，即B7 后两位，00 001，指向常量池第一项。</p>\n<p>后面的 5 -7 直接隔一个字符原因应该是字符串索引算一个字节。</p>\n<p><img src=\"./images/1581776321855.png\" alt=\"1581776321855\" loading=\"lazy\"></p>\n<p>1: invokespecial #1                  // Method java/lang/Object.&quot;<init>&quot;😦)V</p>\n<p>这行后面的这个代表的是这个 invokespecial  方法的参数。表示调用自己的私有方法，构造方法（<init>）以及父类的方法。</p>\n<p>注意：java字节码并不是会强制要求每个 method 里面都有 <init> 方法，因为这个方法的生成是因为java语言本身的规范，和jvm规范不一样。java编译器是会自动生成没有的构造方法是因为 java 语言规范的要求。</p>\n<h5 id=\"exception-table-属性\"> exception_table 属性：</h5>\n<hr>\n<h4 id=\"附加属性\"> 附加属性：</h4>\n<h5 id=\"_1、line-number-table-属性\"> 1、line_number_table 属性：</h5>\n<p>这个附加属性就是code 结构里最后的 attribute_count后attribute_info 的内容。</p>\n<p>u2 attributes_count 代表的就是方法的额外属性，不是方法的成员变量，是编译器生成的。</p>\n<blockquote>\n<p>LineNumberTable：这个属性用来表示code数组中的字节码和java代码行数之间的关系。这个属性可以用来在调试的时候定位代码执行的行数</p>\n</blockquote>\n<p><img src=\"./images/1581603964342.png\" alt=\"1581603964342\" loading=\"lazy\"></p>\n<p>start_pc : 字节码的偏移量，这里的start_pc  和上面的不同</p>\n<p>LineNumber：映射到源代码的行号</p>\n<h5 id=\"举例分析-2\"> 举例分析：</h5>\n<p><img src=\"./images/1581684439643.png\" alt=\"1581684439643\" loading=\"lazy\"></p>\n<p>0x 00 0A：10，常量池第十项， 表示是 LineNumberTable属性</p>\n<p>0x 00 00 00 0A：代表的是attribute_length 表示 attribute 所包含的字节数，不包含attribute_name_index和attribute_length本身字段</p>\n<p>0x 00 02：line_number_table_lenth，表示有两对映射，即后面8个字节码分为两部分。</p>\n<p>{</p>\n<p>0x 00 00：表示离 line_number_table_lenth 这个字节码的偏移量，这里就是 0，代表第一个</p>\n<p>0x 00 09：代表这个映射到源文件的第九行。这里动idea看见构造方法在 类名称这里，原因是不是自己生产的，编译器自动在这里生成构造方法。</p>\n<p>0x 00 04，0x 00 0A 同上面这对。</p>\n<p>}</p>\n<h5 id=\"_2、-local-variable-table-属性\"> 2、  Local_Variable_Table 属性：</h5>\n<blockquote>\n<p>局部变量表。</p>\n</blockquote>\n<h5 id=\"举例分析-图同上\"> 举例分析（图同上）：</h5>\n<p>0x 00 0B:11,常量池第十一项，表示的是 LocalVariableTable。</p>\n<p>0x 00 00 00 0C：属性长度。</p>\n<p>0x 00 01：方法的局部变量个数 1。</p>\n<blockquote>\n<p>注意，这里无参构造方法为什么会有局部变量（这里的局部变量就是this）</p>\n<p>原因：在java里面，每一方法都可以访问 this，即对象本身，但是在源码角度，this 是作为第一个参数传入方法。这样就使得每一个实例对象里面都有 this。即如果某个方法是 非static的，此方法至少拥有一个局部变量 this，this指向的就是当前对象本身，在反编译文件中体现为 args_size 比方法的传入参数多一个。</p>\n<p>还得注意：这里此类的无参构造是 Object 类的无参构造方法，不是本类的，因为所有的类都默认继承 Object类。</p>\n</blockquote>\n<p>{</p>\n<p>0x 00 00：局部变量开始位置</p>\n<p>0x 00 0A：局部变量结束位置</p>\n<p>。。。还有没完的。</p>\n<p>}</p>\n<hr>\n<h4 id=\"分析构造方法和静态变量\"> 分析构造方法和静态变量：</h4>\n<p><img src=\"./images/1581861922632.png\" alt=\"1581861922632\" loading=\"lazy\"></p>\n<p><init>  默认构造方法，所有的实例变量都会在这里初始化。在默认没有写构造方法的时候，编译器会自动添加无参构造方法。</p>\n<p><clinit> 类变量的初始化方法。</p>\n<h5 id=\"举例\"> 举例：</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest</span><span>(</span><span>)</span><span>{</span>\n    <span>String</span> str <span>=</span> <span>\"Welcome\"</span><span>;</span>\n\n    <span>private</span> <span>int</span> x<span>=</span> <span>5</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>Integer</span> in <span>=</span> <span>10</span><span>;</span>\n    \n    <span>public</span> <span>MyTest</span><span>(</span><span>)</span><span>{</span>\n        \n    <span>}</span>\n\n    <span>public</span> <span>MyTest</span><span>(</span><span>int</span> i<span>)</span><span>{</span>\n        \n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h6 id=\"成员变量\"> 成员变量：</h6>\n<p>str 和 x 都是在构造方法里面完成赋值的，即使没有手动书写构造方法，编译器都会默认添加。切记：这里成员变量赋值是在构造方法里面！！！！！！！！！！！</p>\n<p>即使有两个构造方法，它们执行代码的内容都是一样，都会为成员变量赋值。</p>\n<p><img src=\"./images/1581862507947.png\" alt=\"1581862507947\" loading=\"lazy\"></p>\n<h6 id=\"类变量\"> 类变量：</h6>\n<p>首先，所有静态代码块和类变量会合并成一个静态代码块（即使只有类变量，也会生成这个静态代码块），然后会在 <clinit> 方法中初始化。</p>\n<hr>\n<h4 id=\"分析-this-和-异常处理\"> 分析 this 和 异常处理：</h4>\n<h5 id=\"this\"> this：</h5>\n<p>​        对于 Java 类中的每一个实例方法（非 static方法，因为static方法是属于 Class对象的），其在编译后生成的字节码中，方法的参数数量总是会比源代码中方法的参数的数量多一个（this），它位于方法的第一个参数位置处；这样，我们就可以在java的实例方法中使用this来去访问当前对象的属性及其他方法。</p>\n<p>​        这个操作是在编译器完成的，即由javac编译器在编译的时候将对this的访问转换为对一个普通实例方法参数的访问，接下来在运行期间，由JVM在调用实例方法的时，自动向实例方法传入该this参数。所以，在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量。</p>\n<h5 id=\"java-字节码对于异常的处理方式\"> Java 字节码对于异常的处理方式：</h5>\n<p>1、统一采用异常表的方式来对异常进行处理。</p>\n<p>2、在 JDK 1.4.2 之前版本中，并不是使用异常表的方法来对异常进行处理的，而是采用特定的指令方式。</p>\n<p>3、当异常处理存在 finally 语句块时，现代化的JVM采取的处理方法是将finally语句块的字节码拼接到每一个catch块后面。  换句话说，程序中存在多少个 catch 块，就会在每一个catch块后面重复多少个finally语句块的字节码。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest3</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>FileNotFoundException</span><span>,</span><span>IOException</span><span>{</span>\n        <span>try</span><span>{</span>\n            <span>InputStream</span> is <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span><span>\"test.java\"</span><span>)</span><span>;</span>\n\n            <span>ServerSocket</span> serverSocket <span>=</span> <span>new</span> <span>ServerSocket</span><span>(</span><span>9999</span><span>)</span><span>;</span>\n            serverSocket<span>.</span><span>accept</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>\n\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n\n        <span>}</span><span>catch</span> <span>(</span><span>Exception</span> e<span>)</span><span>{</span>\n\n        <span>}</span><span>finally</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"finally\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>当使用catch语句执行的时候，结果如下：</p>\n<p>这里的 any 则表示可以处理前面 catch所有不能处理的异常，这个是编译器在编译的时候自动生成的：</p>\n<p><img src=\"./images/1581949040222.png\" alt=\"1581949040222\" loading=\"lazy\"></p>\n<p>​         当使用 throws 时，如下，方法会生成一个属性，对应的是常量池的33项，并不是和 catch 一样会在方法的字节码中执行出来。所以，catch 比 throw 要复杂，也是因为如此，throw并不是解决异常，只是向上抛出异常。</p>\n<p><img src=\"./images/1581949769364.png\" alt=\"1581949769364\" loading=\"lazy\"></p>\n<hr>\n<p>javap  -verbose 不会打印私有的方法的信息，javap -verbose -p 加上 -p 参数会显示所有的信息</p>\n<h5 id=\"字节码查看工具\"> 字节码查看工具：</h5>\n<p>jclasslib 插件，它可以可视化已编译的Java类文件和所包含的字节码的所有方面。比 javap -ververbose  更详细。</p>\n<p>https://github.com/ingokegel/jclasslib</p>\n",
      "date_modified": "2022-04-29T06:23:43.143Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "classloader 类：",
      "url": "https://fmiles.cn/java/jvm/classloader/ClassLoader%E7%B1%BB%E6%BA%90%E7%A0%81/",
      "id": "https://fmiles.cn/java/jvm/classloader/ClassLoader%E7%B1%BB%E6%BA%90%E7%A0%81/",
      "content_html": "<h4 id=\"classloader-类\"> classloader 类：</h4>\n<h5 id=\"源码文档\"> 源码文档：</h5>\n<p>1、类加载器是加载类的对象，并且类加载器本身是抽象类。在给定一个类的二进制名称时，类加载器应该能定位这个类或者生成构成这个类定义的数据。典型的做法是将给的二进制名称转换为文件名，然后从文件系统中读取和文件名一致的二进制文件。</p>\n<blockquote>\n<p>第一句解释：二进制名称下面有定义。</p>\n<p>第二句解释：定位是说这个类的数据已经真正的存在于某个地方，而类加载器能找到这个地方。</p>\n<p>第三局解释：生成是说有些类是在运行期动态生成的，比如说动态代理，</p>\n<p>第三局解释：和我们日常开发是一样的，表示是从磁盘上（也就是文件系统中）去读取二进制名称所对应的 class 信息。当然也可以从网络上获取字节码文件。</p>\n</blockquote>\n<p>2、每一个Class对象都包含了定义它的classloader的引用。</p>\n<blockquote>\n<p>这里解释了为什么Class这个类有getClassLoader这个方法，故而每一个类的Class类都会有这个方法。注意，一个类的 .class 和实例对象的 getClass 方法获取的都是 Class 对象。</p>\n</blockquote>\n<div><pre><code> <span>MyParent1</span> my <span>=</span> <span>new</span> <span>MyChild1</span><span>(</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span> my<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span>）<span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>MyParent1</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>3、对于数组类的Class对象，并不是由类加载器创建的，而是由java运行时在需要的时候自动创建。对于数组类的类加载器来说，其通过getClassLoader方法返回的类加载器和数组元素类型返回的类加载器相同；如果元素类型是原生类型，则数组类并没有类加载。</p>\n<blockquote>\n<p>第一句解释：除了数组类的Class对象，其他类的Class对象一定是由类加载创建的，类加载器从磁盘上加载字节码文件，然后把Class对象创建出来。而数组的类型在详见 MyTest4。</p>\n<p>第二句解释：详见 MyTest15,数组返回的类加载器就是数组元素返回的类加载器。</p>\n<p>第三句解释：详见 MyTest15，原生类型指的是八大类型，是没有类加载器的，getClassLoader返回的是null。注意和启动类加载器返回的null 性质是不一样的。</p>\n</blockquote>\n<p>4、应用实现了ClassLoader类的子类是为了扩展java虚拟机动态加载类的方式。</p>\n<blockquote>\n<p>这句话就说明了自定义类加载器的用途，继承了ClassLoader类形成子类，就可以扩展类加载器，形成自己的加载方式。</p>\n</blockquote>\n<p>5、类加载器典型情况下是可以被安全管理器所使用去表示安全域问题。</p>\n<blockquote>\n<p>确保类加载的过程一定是安全的。（安全管理器，安全域不知道是啥）</p>\n</blockquote>\n<p>6、ClassLoader使用双亲委托模型去寻找类和资源。ClassLoader的每一个实例都有一个与之关联的父类ClassLoader。当ClassLoader寻找类或者资源的时候，ClassLoader的实例会把寻找类或者资源的任务委托给父类，在它自己去尝试寻找类或者资源之前。虚拟机内建的类加载器，称之为启动类加载器，它本身是没有双亲的，但是它可以作为其他类加载器的双亲。</p>\n<blockquote>\n<p>第一句解释：类加载器使用的是双亲委托模型。</p>\n<p>第二局解释：每一个类加载器都有一个父类加载器</p>\n</blockquote>\n<p>7、不会，略过。</p>\n<p>8、通常情况下，java虚拟机是从与平台相关的文件系统中加载类。举个例子，在UNIX系统上，虚拟机会从CLASSPATH环境变量所定义的路径上去加载类。</p>\n<blockquote>\n<p>意思就是在不同的从操作系统里面，虚拟机加载类有所不同。</p>\n</blockquote>\n<p>9、然而，一些类并不是来自于文件；它们可能来自其他地方，比如网上，或者由应用本身创建的。在这种情况下，defineClass方法就会把字节数组转换为Class类的实例。而这个新定义的类实例是可以通过Class.newInstance方法创建。</p>\n<blockquote>\n<p>第一句解释：应用本身创建的例子就是动态代理，它的类就是运行时产生的。</p>\n<p>第二三句解释：这里分为两个步骤，第一步是通过defineClass方法把字节数组转换为Class类对象，这个Class类对象指的就是存在于虚拟机中的Class而不是通过Class创建的实例，而要想创建Class所对应的真正实例，要通过Class.newInstance方法创建,而调用的 Class.newInstance 底层会默认调用要实例化的类的无参构造，若是没有指定有参构造的话。</p>\n</blockquote>\n<p>10、由类加载器创建的对象的方法和构造方法还可能引用其他的类。为了确定被引用的类都是什么，java虚拟机会调用 loadClass 方法去加载这个类所引用的其他的类。</p>\n<blockquote>\n<p>这里注意，调用ClassLoader 的loadClass 方法不是对类的主动使用，因此并不会初始化这个类。</p>\n</blockquote>\n<p><img src=\"./images/1605192455077.png\" alt=\"1605192455077\" loading=\"lazy\"></p>\n<p><img src=\"./images/1605192486988.png\" alt=\"1605192486988\" loading=\"lazy\"></p>\n<hr>\n<h4 id=\"classloader-类方法说明\"> ClassLoader 类方法说明：</h4>\n<h5 id=\"getsystemclassloader-方法文档说明\"> getSystemClassLoader（） 方法文档说明：</h5>\n<p>1、返回用于委托的系统类加载器。它是新的ClassLoader实例的默认委托双亲，并且通常也是用于启动应用的类加载器。</p>\n<blockquote>\n<p>解释：像包含 main 方法的类都会由系统类加载器加载</p>\n</blockquote>\n<p>2、这个方法在运行启动过程中的很早期就会被调用，在此方法被调用的这个时刻会创建系统类加载器而且它会将这个系统类加载器设置为调用本方法的线程的上下文加载器。</p>\n<blockquote>\n<p>解释：getSystemClassLoader 不仅会返回系统类加载器，并且在最开始调用此方法也会创建系统类加载器。</p>\n</blockquote>\n<p>3、默认的系统类加载器是一个与这个类实现相关实现的一个实例。</p>\n<p>4、在 getSystemLoader 这个方法第一次被调用的时候，如果系统属性 java.system.class.loader 被定义了，那么这个属性的值就会被作为系统类加载器的相应的名称。这个类（就是我们定义的属性值指向的自定义的那个classloader类）会被系统类加载并且这个类必须定义一个公有的构造器能够接受单个的 ClassLoader类型的参数用作委托双亲。这个构造方法会使用默认的系统类加载器作为父类加载器在创建自定义的类加载器实例的时候。</p>\n<blockquote>\n<p>解释：这里的这个类会被系统类加载器加载的意思是，自定义的这个类会成为系统类加载器，调用getSystemLoader方法返回的就是自定义类加载器，但是当自定义类加载器的实例调用getClassLoader方法的时候，返回的是 AppClassLoader。</p>\n<p>最后一句解释:自定义的系统类加载器会使用 JDK 自带的系统类加载器作为父类，虽然此时getSystemLoader 方法返回的已经不是  JDK 自带的系统类加载器，而是自定义的系统类加载器。因为已经通过 java.system.class.loader 参数更改了系统类加载器。</p>\n</blockquote>\n<p>源码文档：</p>\n<p><img src=\"./images/1605793051142.png\" alt=\"1605793051142\" loading=\"lazy\"></p>\n<h5 id=\"getsystemclassloader-源代码分析\"> getSystemClassLoader (）  源代码分析：</h5>\n<div><pre><code> <span>public</span> <span>abstract</span> <span>class</span> <span>ClassLoader</span> <span>{</span>\n      <span>// The class loader for the system</span>\n    <span>private</span> <span>static</span> <span>ClassLoader</span> scl<span>;</span>   <span>// 系统类加载器</span>\n\n    <span>// Set to true once the system class loader has been set</span>\n    <span>private</span> <span>static</span> <span>boolean</span> sclSet<span>;</span>  <span>// 系统类加载器是否被设置</span>\n\n     <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>\n         \n    <span>public</span> <span>static</span> <span>ClassLoader</span> <span>getSystemClassLoader</span><span>(</span><span>)</span> <span>{</span>\n        <span>initSystemClassLoader</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>scl <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n         <span>// 安全验证</span>\n        <span>SecurityManager</span> sm <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>sm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>checkClassLoaderPermission</span><span>(</span>scl<span>,</span> <span>Reflection</span><span>.</span><span>getCallerClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> scl<span>;</span>\n    <span>}</span>\n\n    <span>// 、、初始化加载器的方法、、//</span>\n    <span>private</span> <span>static</span> <span>synchronized</span> <span>void</span> <span>initSystemClassLoader</span><span>(</span><span>)</span> <span>{</span>\n        <span>//如果系统类加载器没有被设置</span>\n        <span>if</span> <span>(</span><span>!</span>sclSet<span>)</span> <span>{</span>\n            <span>// 系统类加载器不为空</span>\n            <span>if</span> <span>(</span>scl <span>!=</span> <span>null</span><span>)</span>\n                 <span>// 抛出递归调用异常。原因是系统类没被设置肯定为空</span>\n                <span>throw</span> <span>new</span> <span>IllegalStateException</span><span>(</span><span>\"recursive invocation\"</span><span>)</span><span>;</span>\n            <span>// 获取系统类加载器和扩展类加载器的外层类对象。（系统类加载器和扩展类加载器都是Launcher类的内部类,下面是针对 Launcher类的分析）</span>\n            <span><span>sun<span>.</span>misc<span>.</span></span>Launcher</span> l <span>=</span> <span><span>sun<span>.</span>misc<span>.</span></span>Launcher</span><span>.</span><span>getLauncher</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>l <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>Throwable</span> oops <span>=</span> <span>null</span><span>;</span>\n                <span>// 分析Launcher得知这里返回的是 应用类加载器</span>\n                scl <span>=</span> l<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    <span>// new SystemClassLoaderAction 就是为了处理开发者自定义的系统加载器。这里的scl可能是自定义的系统类加载器也可能是系统类加载</span>\n                    scl <span>=</span> <span>AccessController</span><span>.</span><span>doPrivileged</span><span>(</span><span>new</span> <span>SystemClassLoaderAction</span><span>(</span>scl<span>)</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>PrivilegedActionException</span> pae<span>)</span> <span>{</span>\n                    oops <span>=</span> pae<span>.</span><span>getCause</span><span>(</span><span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>oops <span>instanceof</span> <span>InvocationTargetException</span><span>)</span> <span>{</span>\n                        oops <span>=</span> oops<span>.</span><span>getCause</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>oops <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>if</span> <span>(</span>oops <span>instanceof</span> <span>Error</span><span>)</span> <span>{</span>\n                        <span>throw</span> <span>(</span><span>Error</span><span>)</span> oops<span>;</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        <span>// wrap the exception</span>\n                        <span>throw</span> <span>new</span> <span>Error</span><span>(</span>oops<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n            <span>// 系统类加载器设置成功</span>\n            sclSet <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n            \n<span>}</span>\n\n\t<span>.</span>\n        <span>.</span>\n        <span>.</span>\n        \n<span>//、、 这个是存在于 ClassLoader 这个类文件里面的一个类、、//</span>\n<span>class</span> <span>SystemClassLoaderAction</span> <span>implements</span> <span>PrivilegedExceptionAction</span><span><span>&lt;</span><span>ClassLoader</span><span>></span></span> <span>{</span>\n    <span>private</span> <span>ClassLoader</span> parent<span>;</span>\n\n    <span>SystemClassLoaderAction</span><span>(</span><span>ClassLoader</span> parent<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>parent <span>=</span> parent<span>;</span>\n    <span>}</span>\n    \n    <span>// 实现了 PrivilegedExceptionAction 的run方法，以便在权限检查完后调用此 run 方法。</span>\n    <span>public</span> <span>ClassLoader</span> <span>run</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 自定义系统类加载器的系统属性</span>\n        <span>String</span> cls <span>=</span> <span>System</span><span>.</span><span>getProperty</span><span>(</span><span>\"java.system.class.loader\"</span><span>)</span><span>;</span>\n        <span>// 为空表示没有自定义系统类加载器，直接返回创建的  scl 系统类加载器。</span>\n        <span>if</span> <span>(</span>cls <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> parent<span>;</span>\n        <span>}</span>\n        <span>// new Class&lt;?>[] { ClassLoader.class } 匿名内部类会调用接受一个ClassLoader类型参数的构造方法。这里就解释了为什么自定义的系统类ClassLoader 需要添加接受一个ClassLoader类型参数的构造方法</span>\n        <span>// 这里要用 指定的parent类加载器加载的是 cls（也就验证了我们自定义的系统类加载器的父类加载器是系统生成的系统类加载器），加载完后初始化，</span>\n        <span>Constructor</span><span><span>&lt;</span><span>?</span><span>></span></span> ctor <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>cls<span>,</span> <span>true</span><span>,</span> parent<span>)</span>\n            <span>.</span><span>getDeclaredConstructor</span><span>(</span><span>new</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>{</span> <span>ClassLoader</span><span>.</span><span>class</span> <span>}</span><span>)</span><span>;</span>\n        <span>// 生成新的类加载器实例。这里是把之前系统生成的系统类加载器作为我们自定义的系统类加载器的父类加载器</span>\n        <span>ClassLoader</span> sys <span>=</span> <span>(</span><span>ClassLoader</span><span>)</span> ctor<span>.</span><span>newInstance</span><span>(</span>\n            <span>new</span> <span>Object</span><span>[</span><span>]</span> <span>{</span> parent <span>}</span><span>)</span><span>;</span>\n        <span>// 把新生成的类加载器作为当前线程上下文加载器。</span>\n        <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>setContextClassLoader</span><span>(</span>sys<span>)</span><span>;</span>\n        <span>return</span> sys<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br></div></div><p>补充说明 newInstance，一般获取的 Class对象用 newInstance 是调用的无参构造，而通过getDeclaredConstructor（参数的Class对象）方法获取到构造器，再通过构造器对象调用 newInstance(参数的Class对象)  就可以调用有参构造。比如 A 类的有参构造 public A(String str,int a)，那么获取其实例对象的写法就是</p>\n<div><pre><code><span>Class</span><span>[</span><span>]</span> classes <span>=</span> <span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span><span>String</span><span>.</span><span>class</span> <span>,</span> <span>int</span><span>.</span><span>class</span><span>}</span>\n<span>A</span><span>.</span><span>class</span><span>.</span><span>getDeclaredConstructor</span><span>(</span>classes<span>)</span><span>.</span><span>newInstance</span><span>(</span><span>\"hello\"</span><span>,</span><span>10</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><hr>\n<h4 id=\"getresources\"> getResources()</h4>\n<h6 id=\"代码示例\"> 代码示例：</h6>\n<div><pre><code><span>// 资源文件路径</span>\n <span>String</span> resourceName <span>=</span> <span>\"com/jvm/classloader/MyTest13.class\"</span><span>;</span>\n <span>Enumeration</span><span><span>&lt;</span>URL<span>></span></span> urls <span>=</span> classLoader<span>.</span><span>getResources</span><span>(</span>resourceName<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h6 id=\"源码文档-2\"> 源码文档：</h6>\n<p><img src=\"./images/1605107235732.png\" alt=\"1605107235732\" loading=\"lazy\"></p>\n<p>重要的几点就是：系统类加载器，原生类型或空 会返回 null</p>\n<hr>\n<h4 id=\"getclassloader\"> getClassLoader()</h4>\n<h6 id=\"源码文档-3\"> 源码文档：</h6>\n<p><img src=\"./images/1605019720319-1606485773846.png\" alt=\"1605019720319\" loading=\"lazy\"></p>\n<hr>\n<h4 id=\"defineclass\"> defineClass()</h4>\n<p>源码：</p>\n<p><img src=\"./images/1605282515078.png\" alt=\"1605282515078\" loading=\"lazy\"></p>\n<p>源码文档：</p>\n<p><img src=\"./images/1605282499759.png\" alt=\"1605282499759\" loading=\"lazy\"></p>\n<p>这个 byte[] 里面的内容必须是符合jvm虚拟机规范的字节码内容，如果不符合规定，则就一定会报错。这个 off,len 的作用，其实就是开始位置，和长度，这样就可以在开头和结尾去定义一些和字节码文件本身相关的一些其他信息，而不是执行的字节码。</p>\n<hr>\n<h4 id=\"findclass\"> findClass()</h4>\n<p>源码：</p>\n<p><img src=\"./images/1605282723048.png\" alt=\"1605282723048\" loading=\"lazy\"></p>\n<p>源码文档：</p>\n<p><img src=\"./images/1605282744113.png\" alt=\"1605282744113\" loading=\"lazy\"></p>\n<p>这个类仅仅是抛出异常，它是作为自定义类加载器必须要重写的方法，用于调用 defineClass 生成Class 对象，让 loadClass 方法调用。</p>\n<hr>\n",
      "date_modified": "2022-04-29T06:23:43.144Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "数组加载",
      "url": "https://fmiles.cn/java/jvm/classloader/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B8%B8%E9%87%8F%E5%8A%A0%E8%BD%BD/",
      "id": "https://fmiles.cn/java/jvm/classloader/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B8%B8%E9%87%8F%E5%8A%A0%E8%BD%BD/",
      "content_html": "<h2 id=\"数组加载\"> 数组加载</h2>\n<p>数组类型的 class 对象，并不是由类加载器加载器的，是 java 虚拟机在运行期的时候帮我们自动创建的。用数组对象调用 getClassLoader 和数组里面任意元素调用 getClassLoader 返回的结果是一样的。</p>\n<h5 id=\"数组类加载器是由数组元素类加载器决定验证\"> 数组类加载器是由数组元素类加载器决定验证：</h5>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvm<span>.</span>classloader</span><span>;</span>\n\n<span>//对于类加载器的解释说明</span>\n<span>public</span> <span>class</span> <span>MyTest13</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>String</span><span>[</span><span>]</span> strings <span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span><span>}</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>strings<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"---------------------\"</span><span>)</span><span>;</span>\n\n        <span>MyTest13</span><span>[</span><span>]</span> myTest13 <span>=</span> <span>new</span> <span>MyTest13</span><span>[</span><span>]</span><span>{</span><span>}</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myTest13<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"---------------------\"</span><span>)</span><span>;</span>\n\n        <span>int</span><span>[</span><span>]</span> ints <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>}</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ints<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>结果：</p>\n<div><pre><code><span>null</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>\n<span><span>sun<span>.</span>misc<span>.</span></span>Launcher</span>$<span>AppClassLoader</span><span>@18b4aac2</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>\n<span>null</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>分析：</p>\n<p>第一个 null 是因为在 jvm 中，string 类型是由 bootstrop 加载的。第二个是我们自定义的类型，一般都是 AppClassLoader 加载的，而第三个 null 和第一个不一样，对于原生类型（八大基本类型)，是没有类加载器的。</p>\n<h5 id=\"数组类型验证\"> 数组类型验证：</h5>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvm<span>.</span>classloader</span><span>;</span>\n<span>/*\n  对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为 \n  class [Lcom.jvm.classloader.MyParent4\n  这种形式。由jvm动态生成的类型，其父类就是 Object.\n\n  对于数组来说，JavaDoc 经常将构成数组的元素为Component，实际就是将数组降低一个维度后的类型\n\n  助记符：\n  anewarray：表示创建一个引用类型的（如类，接口，数组）数组，并将其引用值压入栈顶。\n  newarray：表示创建一个指定的原始类型，（如int，float，char）的数组，并将其引用值压入栈顶\n* */</span>\n\n<span>public</span> <span>class</span> <span>MyTest4</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>//        MyParent4 myParent4 = new MyParent4();</span>\n\n        <span>//静态代码块在初始化的时候执行，而初始化只会在类的首次主动使用时才会，故而只会执行一次</span>\n        <span>//        System.out.println(\"---------------\");</span>\n        <span>//        MyParent4 myParent41 = new MyParent4();</span>\n\n        <span>MyParent4</span><span>[</span><span>]</span> myParent4s <span>=</span> <span>new</span> <span>MyParent4</span><span>[</span><span>1</span><span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myParent4s<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//输出类型</span>\n\n        <span>MyParent4</span><span>[</span><span>]</span><span>[</span><span>]</span> myParent4s1 <span>=</span> <span>new</span> <span>MyParent4</span><span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myParent4s1<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>// 证明数组的父类都是 Object</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myParent4s<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>myParent4s1<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"=============下面是原生类型==============\"</span><span>)</span><span>;</span>\n\n        <span>int</span><span>[</span><span>]</span> ints <span>=</span> <span>new</span> <span>int</span><span>[</span><span>1</span><span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ints<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ints<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>boolean</span><span>[</span><span>]</span> booleans <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>1</span><span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>booleans<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>short</span><span>[</span><span>]</span> shorts <span>=</span> <span>new</span> <span>short</span><span>[</span><span>1</span><span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>shorts<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyParent4</span><span>{</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyParent4 static block\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p>结果：</p>\n<div><pre><code><span>class</span> <span>[</span><span>Lcom</span><span>.</span>jvm<span>.</span>classloader<span>.</span>MyParent4<span>;</span>  <span>// 半个 [ 代表的是一维数组 ，[ 类型后面的是类型。两个 [[ 代表的是二维数组</span>\n<span>class</span> <span>[</span><span>[</span><span>Lcom</span><span>.</span>jvm<span>.</span>classloader<span>.</span>MyParent4<span>;</span>\n<span>class</span> <span><span>java<span>.</span>lang<span>.</span></span>Object</span>\n<span>class</span> <span><span>java<span>.</span>lang<span>.</span></span>Object</span>\n<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>=</span>下面是原生类型<span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>\n<span>class</span> <span>[</span><span>I</span>\n<span>class</span> <span><span>java<span>.</span>lang<span>.</span></span>Object</span>\n<span>class</span> <span>[</span><span>Z</span>    <span>//注意 bolean 类型是 z</span>\n<span>class</span> <span>[</span><span>S</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>原因：</p>\n<p>​         数组类型的class对象，并不是由类加载器加载器的，是java虚拟机在运行期的时候帮我们自动创建的。用数组对象调用getClassLoader和数组里面任意元素调用getClassLoader返回的结果是一样的</p>\n<h2 id=\"常量加载\"> 常量加载</h2>\n<p>常量会进入常量池</p>\n<h5 id=\"常量进入调用者常量池验证\"> 常量进入调用者常量池验证：</h5>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvmm<span>.</span>classloader</span><span>;</span>\n\n<span>/*\n   常量在编译阶段会存入到调用这个常量的方法所在类的常量池中，本质上，调用类并没有\n直接引用到定义常量的类，因此并不会触发定义常量的类的初始化\n注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了。\n甚至我们可以将MyParent2的class文件删除（指的是编译完后，不是不写这个类)\n*/</span>\n\n<span>/*\n    助记符：\n    ldc 表示将int，float 或者是 String类型的常量值从常量池中推送至栈顶\n    bipush 表示将单字节的常量值推送至栈顶\n    sipush 表示将一个短整型常量值推送至栈顶\n    iconst_1 表示将int类型的1推送至栈顶 （iconst_1 ~ iconst_5，jvm至给了5个，6开始就变为bipush）\n*/</span>\n<span>public</span> <span>class</span> <span>MyTest2</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>MyParent2</span><span>.</span>str<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyParent2</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> str <span>=</span> <span>\"hello world\"</span><span>;</span>\n    <span>//public static final short s = 127;</span>\n    <span>//public static final int i = 128;</span>\n    <span>//public static final int m =6;</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>\"MyParent2 static block\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>结果：</p>\n<div><pre><code>hello world\n</code></pre>\n<div><span>1</span><br></div></div><p>分析：</p>\n<p>这里常量在编译阶段就确定了，因此常量在编译阶段<code>会存入到调用这个常量的方法所在类的常量池中</code>，本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。（甚至如果没有其他地方用到，都不会去加载）</p>\n<p>通过反编译可以证明(javap -c)，这个静态变量是MyTest2的常量（反编译的是编译完以后的文件），甚至连 MyParent2 这个类都没有加载：</p>\n<p>![1578670363384](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\classloader\\1578670363384.png?lastModify=1648994526)</p>\n<h5 id=\"编译器不确定的常量不能进入常量池验证\"> 编译器不确定的常量不能进入常量池验证：</h5>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvm<span>.</span>classloader</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span>UUID<span>;</span>\n<span>/*\n    当一个常量的值并非编译期可以确定的，那么其值就不会被放到调用类的常量池中，\n    这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。\n*/</span>\n<span>public</span> <span>class</span> <span>MyTest3</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>MyParent3</span><span>.</span>str<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyParent3</span><span>{</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>String</span> str <span>=</span> UUID<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>\"MyParent3 static code\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>结果：</p>\n<div><pre><code><span>MyParent3</span> <span>static</span> code\n<span>64e908d</span><span>7</span><span>-</span><span>5</span>c25<span>-</span><span>4376</span><span>-</span><span>996e-717017163295</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>​       和例二的区别在于，同样是常量，但是这里的常量在编译期是不能够确定的，因此必须是依赖 MyParent3 这个类，而不是直接放入调用类的常量池，因为无法确定值。</p>\n",
      "image": "file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\classloader\\1578670363384.png?lastModify=1648994526",
      "date_modified": "2022-04-29T06:23:43.148Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "初始化阶段静态变量赋值验证：",
      "url": "https://fmiles.cn/java/jvm/classloader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90/",
      "id": "https://fmiles.cn/java/jvm/classloader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E5%88%86%E6%9E%90/",
      "content_html": "<h4 id=\"初始化阶段静态变量赋值验证\"> 初始化阶段静态变量赋值验证：</h4>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvm<span>.</span>classloader</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>MyTest6</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>//Singleton singleton = Singleton.getSingleton();</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"counter1=\"</span><span>+</span><span>Singleton</span><span>.</span>counter1<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"counter2=\"</span><span>+</span><span>Singleton</span><span>.</span>counter2<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Singleton</span><span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> counter1<span>;</span>\n    <span>public</span> <span>static</span> <span>int</span> counter2 <span>=</span> <span>0</span><span>;</span>\n\n    <span>private</span> <span>static</span> <span>Singleton</span> singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span><span>{</span>\n        counter1<span>++</span><span>;</span>\n        counter2<span>++</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> singleton<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>///输出结果为 1,1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>结果：</p>\n<div><pre><code><span>1</span><span>,</span><span>1</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>分析：在准备阶段给静态变量赋初始值 0，然后再会执行构造方法，因此结果为1，1</p>\n<h4 id=\"静态变量位置对初始化结果的影响\"> 静态变量位置对初始化结果的影响：</h4>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvm<span>.</span>classloader</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>MyTest6</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Singleton</span> singleton <span>=</span> <span>Singleton</span><span>.</span><span>getSingleton</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"counter1=\"</span><span>+</span><span>Singleton</span><span>.</span>counter1<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"counter2=\"</span><span>+</span><span>Singleton</span><span>.</span>counter2<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Singleton</span><span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> counter1<span>;</span>\n    <span>private</span> <span>static</span> <span>Singleton</span> singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span><span>{</span>\n        counter1<span>++</span><span>;</span>\n        counter2<span>++</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>counter1<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>counter2<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"a:\"</span><span>+</span>a<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"singleton2:\"</span><span>+</span>singleton2<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> counter2 <span>=</span> <span>0</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> singleton<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>结果：</p>\n<div><pre><code><span>1</span>\n<span>1</span>\ncounter1<span>=</span><span>1</span>\ncounter2<span>=</span><span>0</span>\na<span>:</span><span>null</span>  <span>// 这里就证明了包装类的静态变量值默认值是null</span>\nsingleton2<span>:</span><span>null</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>分析：</p>\n<p>因为调用了类的静态变量，因此会对类进行初始化，这里注意，仅仅是在首次主动使用的时候才会初始化。先是在准备阶段，给counter1，counter2赋值为0，给singleton赋值为 null。然后在初始化阶段，会按顺序从上到下给静态变量赋给定的值，counter1还是 0，执行到 private static Singleton singleton = new Singleton(); 会去调用 private Singleton(){} ,这时候，构造函数内部的 counter1 使用的是已经被初始化以后的值，也就是0，而 counter2 使用的还是准备阶段的默认值 0，因为还没执行到 counter2 的初始化。因此在执行完 private static Singleton singleton = new Singleton()  的初始化以后，counter1，counter2都变为了 1，但是接下来又对 counter2 进行初始化，因此 counter2 变为了0.</p>\n<p>构造方法是在 new 的时候调用的，这就是初始化的时候。</p>\n<blockquote>\n<p>这里就体现了准备阶段的意义，如果没有准备阶段，这里的counter2是没有值的，counter2 是不能被使用的因为没有值</p>\n</blockquote>\n",
      "date_modified": "2022-04-29T06:23:43.149Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "类的加载、连接与初始化 阶段",
      "url": "https://fmiles.cn/java/jvm/classloader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/",
      "id": "https://fmiles.cn/java/jvm/classloader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/",
      "content_html": "<h2 id=\"类的加载、连接与初始化-阶段\"> 类的加载、连接与初始化 阶段</h2>\n<ul>\n<li>[x] <code>类的加载、连接和初始化都是在运行期间完成的。</code></li>\n</ul>\n<p><img src=\"./images/类加载过程-完善.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>1、加载：查找并加载类的二进制文件</p>\n<p>2、连接：</p>\n<ol>\n<li>\n<p>验证：确保被加载的类的正确性</p>\n</li>\n<li>\n<p>准备：为类的 <code>静态变量</code> 分配内存，并将其初始化为默认值</p>\n</li>\n<li>\n<p>解析：把类中的符号引用转换为直接引用</p>\n<p>注意连接的准备阶段，已经分配内存给静态变量了，故而类不需要实例化就能调用它。而实例变量则是在实例化以后才会分配内存。</p>\n</li>\n</ol>\n<p>3、初始化：为类的静态变量赋予正确的初始值</p>\n<p>4、使用：使用类的实例</p>\n<p>5、卸载：不使用这个类，从内存中去除。</p>\n<h5 id=\"标准的生命周期\"> 标准的生命周期：</h5>\n<p>![img](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\classloader{C0399D4A-E347-8D33-F905-D0E97E354790}.jpg?lastModify=1648980159)</p>\n<p><init> 方法是对实例变量的初始化。</p>\n<h5 id=\"对于类变量的补充\"> 对于类变量的补充：</h5>\n<p>成员变量就是类里面的变量，不区分static。没有static的成员变量叫实例变量，加了static就叫类变量。</p>\n<div><pre><code><span>class</span> <span>Test</span><span>{</span>\n     \n    <span>public</span> <span>static</span> <span>String</span> CLASS_VAR <span>=</span> <span>\"test\"</span><span>;</span><span>//类变量、静态变量、全局变量</span>\n     \n    <span>private</span> <span>String</span> instance_var<span>;</span><span>//实例变量</span>\n     \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"加载\"> 加载</h2>\n<p>类加载的最终产品是位于内存中的Class对象</p>\n<p>编译后的字节码文件就是一个Class对象。加载是把字节码加载进内存中。</p>\n<blockquote>\n<p>​\t\t 类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象放在哪里，HotSpot虚拟机将其放在了方法区中，这就是元空间的元数据）用来封装类在方法区内的数据结构，并且Class 对象向java程序员提供了访问方法区内的数据结构的接口。</p>\n</blockquote>\n<h5 id=\"加载-class-文件的方式\"> 加载 .class 文件的方式</h5>\n<p>jvm并不限制加载字节码文件的方式，因此可以是很多种。</p>\n<ul>\n<li>从本地系统中直接加载     （就是在classpath路径下，存在磁盘里面的文件)</li>\n<li>通过网络下载 .class文件</li>\n<li>从zip，jar等归档文件中加载 .class 文件</li>\n<li>从专有数据库中提取 .class 文件 （不必过多了解）</li>\n<li>将 Java 源文件动态编译为 .class文件       （动态代理，类在运行期生成的，编译期是不存在的)</li>\n</ul>\n<h2 id=\"连接\"> 连接</h2>\n<blockquote>\n<p>类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。</p>\n</blockquote>\n<h5 id=\"类的验证的内容\"> 类的验证的内容：</h5>\n<ul>\n<li>类文件的结构检查</li>\n<li>语义检查</li>\n<li>字节码验证</li>\n<li>二进制兼容性的验证</li>\n</ul>\n<h2 id=\"初始化\"> 初始化</h2>\n<p>初始化阶段为类的<code>静态变量</code>赋予正确的初始值。</p>\n<h4 id=\"静态变量的初始化有两种途径\"> 静态变量的初始化有两种途径：</h4>\n<ol>\n<li>在静态变量的声明处进行初始化。</li>\n<li>在静态代码块中初始化。静态变量的声明语句，以及静态代码块都被看做类的初始化语句，java虚拟机会按照语句在类文件中的先后顺序来依次执行它们 (这也静态代码块只会摆加载一次的原因，类只会被初始化一次)。</li>\n</ol>\n<p>例子：</p>\n<div><pre><code><span>class</span> <span>Test</span><span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> a <span>=</span> <span>1</span><span>;</span>    <span>//在静态变量的声明处进行初始化。</span>\n    \n    <span>static</span> <span>{</span> \n        b <span>=</span> <span>2</span><span>;</span>   <span>//  在静态代码块中初始化</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这里在连接的准备阶段,会把 a 赋值为默认的0，因为在准备阶段，是没有类的实例。而在初始化阶段才会赋值为 1。</p>\n<h4 id=\"初始化步骤\"> 初始化步骤：</h4>\n<ul>\n<li>假如这个类还没有被加载和连接，那就首先进行加载和连接</li>\n<li>假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类</li>\n<li>假如类中存在初始化语句，那就依次执行这些初始化语句</li>\n</ul>\n<h4 id=\"什么时候初始化\"> 什么时候初始化？</h4>\n<h6 id=\"java程序对类的使用方式可分为两种\"> java程序对类的使用方式可分为两种：</h6>\n<ul>\n<li>主动使用</li>\n<li>被动使用</li>\n</ul>\n<p>所有的 java 虚拟机实现必须在每个类或接口被 java 程序 <code>首次主动使用</code>时才初始化他们 。（<em>首次主动使用就是说只会在主动使用类时初始化这个类，且只初始化一次。</em>）。注意：被动使用是不会导致类的初始化，但这不意味着不去加载，连接这个类。</p>\n<h4 id=\"主动使用情况\"> 主动使用情况：</h4>\n<blockquote>\n<ol>\n<li>\n<p>创建类的实例        （new一个对象）</p>\n</li>\n<li>\n<p>访问某个类或接口的静态变量，或者对该静态变量赋值（常量除外）</p>\n</li>\n<li>\n<p>调用类的静态方法</p>\n<p>（2，3其实类似，访问静态变量getstatic，对静态变量赋值 putstatic ，调用静态方法 invokestatic。这些都是助记符）</p>\n<p>（MyTest 11。虽然是调通过子类调用父类的静态变量，但这本质上是对父类的主动使用，静态变量定义在哪就是对那哪个类的主动使用）</p>\n</li>\n<li>\n<p>反射       (如 Class.forname(&quot;com.test.Test&quot;))</p>\n</li>\n<li>\n<p>初始化一个类的子类     （A类继承B类，在对类A初始化的时候，也会对B类进行初始化）</p>\n</li>\n<li>\n<p>Java虚拟机启动时被标明为启动类的类     （包含了 main 方法的类）</p>\n</li>\n<li>\n<p>JDK1.7开始提供的动态语言支持：</p>\n<p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化。</p>\n</li>\n</ol>\n</blockquote>\n<p>除了以上七种情况，其他使用 Java类的方式都被看做是对类的被动使用，都不会导致类的初始化。</p>\n<h5 id=\"子类初始化父类会先初始化验证\"> 子类初始化父类会先初始化验证：</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest1</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>MyChild1</span><span>.</span>str<span>)</span><span>;</span>\n        <span>// System.out.print(MyChild1.str2);</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyParent1</span><span>{</span>\n    <span>public</span> <span>static</span> <span>String</span> str <span>=</span> <span>\"hello word\"</span><span>;</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>\"MyParent1 static block\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MyChild1</span> <span>extends</span> <span>MyParent1</span><span>{</span>\n    <span>public</span> <span>static</span> <span>String</span> str2 <span>=</span> <span>\"welcome\"</span><span>;</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>\"MyChild1 static block\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>结果：</p>\n<div><pre><code><span>MyParent1</span> <span>static</span> block\nhello word\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>分析：<code>对于静态字段来说，只有直接定义了该字段的类才会被初始化</code>。这里是对 MyParent1的主动使用，符合主动使用的第二条，但是并没有主动使用 MyChild1。</p>\n<p>这里虽然没有初始化 MyChild1，但是同样会加载 这个类，通过添加虚拟机参数 -XX:+TraceClassLoading  就可以看到如下结果：</p>\n<p>![1568119614669](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\classloader\\1568119614669-1578668393305.png?lastModify=1648981530)</p>\n<p>如果执行  System.out.print(MyChild1.str2）</p>\n<p>结果：</p>\n<div><pre><code><span>MyParent1</span> <span>static</span> block\n<span>MyChild1</span> <span>static</span> block\nwelcome\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>分析：这里主用使用了 MyChild1，但是由主用使用第五条可知，他会先去初始化所有的父类，再初始化自己。</p>\n<h5 id=\"父接口不会初始化验证\"> 父接口不会初始化验证：</h5>\n<div><pre><code><span>package</span> <span>com<span>.</span>jvm<span>.</span>classloader</span><span>;</span>\n<span>/*\n    当一个接口在初始化时，并不要求其父类接口都完成了初始化\n    只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化\n* */</span>\n<span>public</span> <span>class</span> <span>MyTest5</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>MyChild5</span><span>.</span>b<span>)</span><span>;</span>\n        <span>//System.out.println(MyChild5_02.thread);</span>\n    <span>}</span>\n<span>}</span>\n\n<span>//验证初始化类的时候并不会先初始化它实现的接口</span>\n<span>interface</span> <span>MyParent5</span><span>{</span>\n    <span>public</span> <span>static</span> <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>{</span>\n        <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyParent5 invoked\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>MyChild5</span> <span>implements</span> <span>MyParent5</span><span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> b <span>=</span> <span>6</span><span>;</span>\n<span>}</span>\n\n<span>//验证在初始化一个接口时，并不会先初始化它的父接口</span>\n<span>interface</span> <span>MyParent5_02</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>{</span>\n        <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyParent5_02 invoked\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n<span>}</span>\n\n<span>interface</span> <span>MyChild5_02</span> <span>extends</span> <span>MyParent5_02</span><span>{</span>\n    <span>public</span> <span>static</span> <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>{</span>\n        <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyChild5_02 invoked\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><p>结果：</p>\n<div><pre><code><span>6</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>分析：</p>\n<p>对于接口来说，在定义的时候即使不加 final，默认也是 final，因此加 static 的字段会就变为常量，直接进入调用类的常量池。但是这里的常量如果在编译器不能够确定，则无法进入 MyTest5 常量池。并且接口是不要求父接口被初始化的。</p>\n<ul>\n<li>在初始化一个类时，并不会先初始化它实现的接口</li>\n<li>在初始化一个接口时，并不会先初始化它继承的父接口</li>\n</ul>\n<p>只有在真正使用到父接口的时候（如引用接口中所定义的常量，这里的 thread），才会初始化。类在初始化的时候，会先初始化父类，如果父类还有父类，则会继续初始化父类的父类，直到初始化完</p>\n<h2 id=\"卸载\"> 卸载</h2>\n<p>当类被加载，连接和初始化后，它的生命周期就开始了。当代表类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区的数据也会被卸载，从而结束类的生命周期</p>\n<p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p>\n<p>​       由java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的 Class 对象，因此这些 Class 对象始终是可触及的。</p>\n<p>由用户自定义的类加载器所加载的类是可以被卸载的。</p>\n<p>在类加载器的内部实现中，用一个 Java 集合来存放所加载的类的引用。</p>\n",
      "date_modified": "2022-04-29T06:23:43.156Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "CMS垃圾收集器执行过程：",
      "url": "https://fmiles.cn/java/jvm/gc/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%AA%8C%E8%AF%81/",
      "id": "https://fmiles.cn/java/jvm/gc/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%AA%8C%E8%AF%81/",
      "content_html": "<h5 id=\"cms垃圾收集器执行过程\"> CMS垃圾收集器执行过程：</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest5</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span> size <span>=</span> <span>1024</span><span>*</span><span>1024</span><span>;</span>\n\n        <span>// 1m = 1026 kb，1kb = 1024 Byte</span>\n        <span>byte</span><span>[</span><span>]</span> myAllocl <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>4</span><span>*</span>size<span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"1111111111\"</span><span>)</span><span>;</span>\n\n        <span>byte</span><span>[</span><span>]</span> myAllocl2 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>4</span><span>*</span>size<span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"222222222\"</span><span>)</span><span>;</span>\n\n        <span>byte</span><span>[</span><span>]</span> myAllocl3 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>4</span><span>*</span>size<span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"33333333333\"</span><span>)</span><span>;</span>\n\n        <span>byte</span><span>[</span><span>]</span> myAllocl4 <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>2</span><span>*</span>size<span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"444444444444\"</span><span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"hello world\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h5 id=\"jvm参数\"> JVM参数:</h5>\n<div><pre><code><span>-</span>verbose<span>:</span>gc\n<span>-</span><span>Xms20M</span>\n<span>-</span><span>Xmx20m</span>\n<span>-</span><span>Xmn10m</span>\n<span>-</span>XX<span>:</span><span>+</span><span>PrintGCDetails</span>\n<span>-</span>XX<span>:</span><span>SurvivorRatio</span><span>=</span><span>8</span>\n<span>-</span>XX<span>:</span><span>+</span><span>UseConcMarkSweepGC</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在选择 CMS 垃圾收集器作为老年代垃圾收集器的时候，JVM 会自动将 ParNew 垃圾收集器作为新生代垃圾收集器</p>\n<h5 id=\"运行结果\"> 运行结果：</h5>\n<p><img src=\"./images/1583162482044.png\" alt=\"1583162482044\" loading=\"lazy\"></p>\n<p><img src=\"./images/1583162504696.png\" alt=\"1583162504696\" loading=\"lazy\"></p>\n<p>[GC (CMS Initial Mark) [1 CMS-initial-mark: 8807K(10240K)] 13324K(19456K), 0.0047288 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p>\n<p>8807k 代表老年代存活对象占据空间大小。</p>\n<div><pre><code><span>[</span>GC <span>(</span>CMS <span>Final</span> <span>Remark</span><span>)</span> <span>[</span>YG occupancy<span>:</span> <span>6721</span> <span>K</span> <span>(</span><span>9216</span> <span>K</span><span>)</span><span>]</span><span>[</span><span>Rescan</span> <span>(</span>parallel<span>)</span> <span>,</span> <span>0.0024227</span> secs<span>]</span><span>[</span>weak refs processing<span>,</span> <span>0.0000259</span> secs<span>]</span><span>[</span><span>class</span> unloading<span>,</span> <span>0.0005945</span> secs<span>]</span><span>[</span>scrub symbol table<span>,</span> <span>0.0014044</span> secs<span>]</span><span>[</span>scrub string table<span>,</span> <span>0.0003958</span> secs<span>]</span><span>[</span><span>1</span> CMS<span>-</span>remark<span>:</span> <span>8807K</span><span>(</span><span>10240</span>K<span>)</span><span>]</span> <span>15529K</span><span>(</span><span>19456</span>K<span>)</span><span>,</span> <span>0.0050765</span> secs<span>]</span> <span>[</span><span>Times</span><span>:</span> user<span>=</span><span>0.02</span> sys<span>=</span><span>0.00</span><span>,</span> real<span>=</span><span>0.01</span> secs<span>]</span> \n</code></pre>\n<div><span>1</span><br></div></div><p>YG occupancy：年轻代占用的空间；Rescan:重新扫描；class unloading 类卸载；scrub symbol table符号表的处理；scrub string table 表的处理；</p>\n",
      "date_modified": "2022-04-29T06:23:43.159Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "串行回收器",
      "url": "https://fmiles.cn/java/jvm/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/",
      "id": "https://fmiles.cn/java/jvm/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/",
      "content_html": "<h2 id=\"串行回收器\"> 串行回收器</h2>\n<p>串行回收器两个特点：</p>\n<p>1、使用单线程进行垃圾回收的收集器，每次回收只有一个工作线程</p>\n<p>2、是独占式的垃圾回收</p>\n<p>​\t\t因为串行回收器是独占的，所以在垃圾回收的时候，会暂停所有的工作线程，即 STW。这种用户体验很糟糕，但是因为是单线程 GC，没有多线程切换的额外开销，简单实用。</p>\n<p><img src=\"./images/image-20220305124739242.png\" alt=\"image-20220305124739242\" loading=\"lazy\"></p>\n<h3 id=\"serial-回收器\"> Serial 回收器</h3>\n<ul>\n<li>新生代回收器，虚拟机运行在 Client 模式时的默认新生代收集器。</li>\n<li>复制收集算法</li>\n</ul>\n<p>启用新生代串行回收器：</p>\n<div><pre><code><span>-</span>XX<span>:</span><span>+</span><span>UseSerialGC</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"serial-old-回收器\"> Serial Old 回收器</h3>\n<ul>\n<li>\n<p>老年代回收器</p>\n</li>\n<li>\n<p>标记整理算法</p>\n</li>\n</ul>\n<p>启用老年代串行回收器：</p>\n<div><pre><code><span>-</span>XX<span>:</span><span>+</span><span>UseSerialGC</span>  <span>// 新生代老年代都使用串行收集器</span>\n<span>-</span>XX<span>:</span><span>+</span><span>UseParNewGC</span> <span>// 新生代使用 ParNew 回收器，老年代使用串行回收器</span>\n<span>-</span>XX<span>:</span><span>+</span><span>UseParallelGC</span>  <span>// 新生代使用 ParallelGC 回收器，老年代使用串行回收器</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"并行回收器\"> 并行回收器</h2>\n<p>​\t\t在串行回收期基础上改进，使用多个线程同时进行垃圾回收。对于并行能力强的计算器机，可以有效缩短STW时间。</p>\n<p><img src=\"./images/image-20220305131214990.png\" alt=\"image-20220305131214990\" loading=\"lazy\"></p>\n<h3 id=\"parnew-回收器\"> ParNew 回收器</h3>\n<ul>\n<li>新生代回收器。Serial 的多线程版本，除了使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与 Serial 回收器一模一样。</li>\n<li>对应的这种回收器是虚拟机运行在 Server 模式的默认新生代收集器，在单 CPU 的环境中，ParNew 收集器并不会比 Serial 收集器有更好的效果。只有在多CPU 的环境下，效率才会比 Serial 收集器要高。</li>\n</ul>\n<p>开启 ParNew 回收器：</p>\n<div><pre><code><span>-</span>XX<span>:</span><span>+</span><span>UseParNewGC</span>  <span>// 新生代使用 ParNew 回收器，老年代使用串行回收器</span>\n<span>-</span>XX<span>:</span><span>+</span><span>UseConcMarkSweepGC</span>  <span>//新生代 ParNew 回收器，老年代 CMS</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"parallel-scavenge-回收器\"> Parallel Scavenge 回收器</h3>\n<ul>\n<li>新生代回收器。Parallel Scavenge 收集器也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与 ParNew 收集器有所不同，它是以吞吐量最大化（即GC 时间占总运行时间最小）为目的的收集器实现，它运行较长时间的 STW 换取总吞吐量最大化。</li>\n<li>JDK 1.8 默认在新生代的垃圾收集器</li>\n</ul>\n<p>开启 Parallel Scavenge 回收器：</p>\n<div><pre><code><span>-</span>XX<span>:</span><span>UseParallelGC</span>  <span>// 新生代使用 ParallelGC 回收器，老年代使用串行回收器</span>\n<span>-</span>XX<span>:</span><span>UseParallelOldGC</span> <span>// 新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"parallel-old-回收器\"> Parallel Old 回收器</h3>\n<p>​\t\t老年版本吞吐量优先级收集器，使用多线程和标记-整理算法，JVM1.6 提供，在此之前，新生代使用了 PS 收集器的话，老年代除 Serial Old 外别无选择，因为 PS 无法与 CMS 收集器配合工作。</p>\n<ul>\n<li>Parallel Scavenge 在老年代的实现</li>\n<li>在JVM 1.6 才出现Parallel Old</li>\n<li>标记整理算法</li>\n<li>JDK 1.8 默认在老年代的垃圾收集器</li>\n</ul>\n<p>开启 Parallel Old 回收器：</p>\n<div><pre><code><span>-</span>XX<span>:</span><span>UseParallelOldGC</span> <span>// 新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"cms-回收器\"> CMS 回收器</h2>\n<p>CMS （Concurrent Mark Sweep）回收器，以获取最短回收停顿时间为目标。</p>\n<p>CMS 是基于 “标记-清除” 算法实现的，整个过程分为4个过程：</p>\n<blockquote>\n<ol>\n<li>初始标记（CMS initial mark）</li>\n<li>并发标记（CMS concurrent mark）</li>\n<li>重新标记（CMS remark）</li>\n<li>并发清除（CMS concurrent sweep）</li>\n</ol>\n</blockquote>\n<p>补充说明：</p>\n<ul>\n<li>初始标记、重新标记这两个步骤仍需要 STW。</li>\n<li>初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快。</li>\n<li>并发标记阶段是进行 GC Roots Tracing 的过程（即从 GC Root 开始找到被 GC Root 引用或者关联的对象，再从被引用对象开始找他自己能引用 或关联的对象）。</li>\n<li>重新标记阶段是为了修正并发标记阶段因用户程序继续运行而导致的标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记阶段稍长，但远比并发标记的时间短。</li>\n</ul>\n<p><img src=\"./images/{0A780C2E-6189-18D9-B694-E23FD4C166DC}-1583157449453.jpg\" alt=\"{0A780C2E-6189-18D9-B694-E23FD4C166DC}-1583157449453\" loading=\"lazy\"></p>\n<p>如图，在初始标记和重新标记阶段是没有用户线程执行的。</p>\n<h4 id=\"cms-工作流程\"> CMS 工作流程</h4>\n<p>第一个阶段：初始标记</p>\n<p><img src=\"./images/{68B10D66-D07A-9360-1B75-93DEE1647578}.jpg\" alt=\"{68B10D66-D07A-9360-1B75-93DEE1647578}\" loading=\"lazy\"></p>\n<p>第二个阶段：并发标记</p>\n<p><img src=\"./images/{0BE881BF-66A4-EC00-7290-386E3859F86B}.jpg\" alt=\"{0BE881BF-66A4-EC00-7290-386E3859F86B}\" loading=\"lazy\"></p>\n<p>第三个阶段：并发的预先清理</p>\n<p><img src=\"./images/{A66F64C3-232B-3195-E74E-6A17791F7CC2}.jpg\" alt=\"{A66F64C3-232B-3195-E74E-6A17791F7CC2}\" loading=\"lazy\"></p>\n<p>第四个阶段：并发的可失败的预先清理</p>\n<p><img src=\"./images/{407133D3-4F56-A115-EBA6-C64CBE3B7186}.jpg\" alt=\"{407133D3-4F56-A115-EBA6-C64CBE3B7186}\" loading=\"lazy\"></p>\n<p>第五个阶段：重新标记\t<img src=\"./images/{E11DFB54-2D55-C0FC-E8A5-DDF573CC6841}.jpg\" alt=\"{E11DFB54-2D55-C0FC-E8A5-DDF573CC6841}\" loading=\"lazy\"></p>\n<p>第六个阶段：并发清除</p>\n<p><img src=\"./images/{A07C7E2C-D981-CAB7-7D8E-7590C169D772}.jpg\" alt=\"{A07C7E2C-D981-CAB7-7D8E-7590C169D772}\" loading=\"lazy\"></p>\n<p>第七个对象：并发重置</p>\n<p>这个阶段也是并发执行的，它会重设 CMS 内部的数据结构，为下次的 GC 做准备。</p>\n<h2 id=\"g1-回收器\"> G1 回收器</h2>\n<h2 id=\"总结\"> 总结</h2>\n<p>![1583156975006](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\typora-user-images\\1583156975006.png?lastModify=1649055215)</p>\n",
      "date_modified": "2022-04-29T06:23:43.163Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "前言",
      "url": "https://fmiles.cn/java/jvm/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/",
      "id": "https://fmiles.cn/java/jvm/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/",
      "content_html": "<h2 id=\"前言\"> 前言</h2>\n<p>垃圾回收的出现是为了防止忘记回收对象造成内存溢出，更多是让开发者专注于业务。</p>\n<h2 id=\"垃圾回收算法\"> 垃圾回收算法</h2>\n<h3 id=\"_1、引用计数-reference-counting\"> 1、引用计数（Reference Counting）</h3>\n<p><strong>原理</strong>：对象 A 被引用则 A 的引用计数器 + 1，当引用失效计数器 -1。当 A 的引用计数器为 0，则对象不可被引用。</p>\n<p><strong>缺点</strong>：不可达对象会循环引用。</p>\n<p>循环引用：</p>\n<p>​\t\tA 持有 B 对象，B 持有 A。在之前，可能会有其他引用分别指向这两个类，但是渐渐消失，最后剩下 A，B 相互引用。而这时候不会有其他类的引用，这两个类是没作用了。但是引用计数算法会判断计数器是否为0,此时 A ,B 都是1，故而无法被回收。</p>\n<p><img src=\"./images/image-20220305010408379.png\" alt=\"image-20220305010408379\" loading=\"lazy\"></p>\n<h3 id=\"_2、标记清除-mark-sweep\"> 2、标记清除（Mark-Sweep）</h3>\n<p><strong>原理</strong>：标记阶段和清除阶段。从根节点标记所有可达对象，然后清除不可达对象。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>\n<p>效率问题，标记和清理两个过程效率都不高。因为需要扫描所有对象。堆越大，GC 越慢。</p>\n</li>\n<li>\n<p>空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾收集动作。并且 GC 次数越多，碎片越严重。</p>\n</li>\n</ul>\n<p>标记清除示意图：</p>\n<p><img src=\"./images/image-20220305000750000.png\" alt=\"image-20220305000750000\" loading=\"lazy\"></p>\n<h3 id=\"_3、复制算法-copying\"> 3、复制算法（Copying）</h3>\n<p><strong>原理</strong>：将一块内存分为两块，每次使用一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到未使用的内存中。</p>\n<p><strong>优点</strong>：内存回收都是对整个半区的回收，内存分配也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。</p>\n<p><strong>缺点</strong>：内存浪费一半。如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>\n<p>复制算法适用于用于新生代，在存活对象少、垃圾对象多的前提下效率高。虚拟机将内存分为一块较大的 eden 空间和 2 块较少的 survivor （from，to） 空间，每次使用 eden 和其中一块 survivor，当回收时将 eden 和 survivor 还存活的对象一次性拷贝到另外一块 survivor 空间上，然后清理掉 eden 和用过的 survivor。</p>\n<h3 id=\"_4、标记压缩-mark-compact\"> 4、标记压缩（Mark-Compact）</h3>\n<p><strong>原理</strong>：标记阶段同标记清除，从根节点开始标记可达对象，将不可达对象压缩到内存的一端，再清除边界外的所有空间。</p>\n<p><strong>优点</strong>：没有内存碎片。</p>\n<p><strong>缺点</strong>：耗费更多时间压缩。</p>\n<h3 id=\"_5、分代算法-generational-collecting\"> 5、分代算法（Generational Collecting）</h3>\n<p><strong>原理</strong>：将内存区域根据特点分成几块，根据每块内存区域的特点，选择不同的回收算法。</p>\n<p>对新生代和老年代来说，通常新生代的回收频率很高，耗时短，但老年代回收频率低，耗时长。为了支持高频率新生代回收，虚拟机使用卡表。卡表是比特位的集合，每一个比特用来表示老年代中的某一区域是否持有新生代对象。这样在新生代GC时候，就可通过扫描卡表而不需要扫描老年代。</p>\n<h5 id=\"卡表图\"> 卡表图：</h5>\n<p><img src=\"./images/image-20220305002356745.png\" alt=\"image-20220305002356745\" loading=\"lazy\"></p>\n<h4 id=\"补充说明\"> 补充说明：</h4>\n<p>新生代：</p>\n<blockquote>\n<ol>\n<li>新生成的对象都放在新生代</li>\n<li>Eden 和 2个 Survivor 的缺省比例是 8：1：1，也就是10% 的空间会被浪费</li>\n<li>年轻代触发的 gc 是 minor gc 不会导致应用进程停顿</li>\n</ol>\n</blockquote>\n<p>老年代：</p>\n<blockquote>\n<ol>\n<li>年轻代gc 15 次后还存活的对象会进入老年代</li>\n<li>大对象直接进入老年代 (大对象就是需要大量连续内存空间的对象，比如：字符串、数组)</li>\n<li>老年代触发的 gc 是 full gc 会导致应用进程停顿 对性能的影响比较大</li>\n<li>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2</li>\n</ol>\n</blockquote>\n<h3 id=\"_6、分区算法-region\"> 6、分区算法（Region）</h3>\n<p><strong>原理</strong>：将整个堆空间划分成连续的不同小区域，每个小区域独立使用、回收。可以减少一次 GC 所产生的停顿。</p>\n<h2 id=\"判断可触及性\"> 判断可触及性</h2>\n<p>垃圾回收的基本思想是考察每一个对象的可触及性，即从根节点开始是否可以访问到这个对象，如果可以，这说明当前对象正在被使用，如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，一般来说，此对象需要被回收。但事实上，一个无法触及的对象有可能在某一条件下 “复活自己”，如果这样那么对它的回收就是不合理的，为此，需要给除一个对象可触及对象的定义，并规定在什么状态下，才可以安全的回收对象。</p>\n<p>无法触及的对象也可以在某一条件复活，需要定义对象的可触及性状态。</p>\n<ul>\n<li>可触及的：从根节点开始，可以到达这个对象。</li>\n<li>可复活的：对象引用都被释放，但是对象可能在 finalize()函数中复活。</li>\n<li>不可触及的：对象 finalize()函数被调用，且未复活。</li>\n</ul>\n<h4 id=\"引用和可触及性\"> 引用和可触及性</h4>\n<h5 id=\"强引用-对象是可触及的-不会被回收。\"> 强引用：对象是可触及的，不会被回收。</h5>\n<p>特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p>\n<h5 id=\"软引用-软可触及-内存不够就回收-softreference。\"> 软引用：软可触及，内存不够就回收，SoftReference。</h5>\n<p>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</p>\n<h5 id=\"弱引用-弱可触及-只要发现弱引用就会回收-weakreference。\"> 弱引用：弱可触及，只要发现弱引用就会回收，WeakReference。</h5>\n<p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h5 id=\"虚引用-虚可触及-和没有引用几乎一样-作用是跟踪垃圾回收过程-phantomreference。\"> 虚引用：虚可触及，和没有引用几乎一样，作用是跟踪垃圾回收过程，PhantomReference。</h5>\n<p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<p>​    ReferenceQueue queue = new ReferenceQueue ();</p>\n<p>​    PhantomReference pr = new PhantomReference (object, queue);</p>\n<p>​    程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</p>\n<p>​    应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</p>\n<h2 id=\"对象生命周期\"> <strong>对象生命周期</strong></h2>\n<p>创建阶段(Created)</p>\n<p>应用阶段(In Use)</p>\n<p>不可见阶段(Invisible)</p>\n<p>不可达阶段(Unreachable)</p>\n<p>收集阶段(Collected)</p>\n<p>终结阶段(Finalized)</p>\n<p>对象空间重分配阶段(De-allocated)</p>\n",
      "date_modified": "2022-04-29T06:23:43.167Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "枚举根节点：",
      "url": "https://fmiles.cn/java/jvm/gc/%E5%AE%89%E5%85%A8%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E5%9F%9F/",
      "id": "https://fmiles.cn/java/jvm/gc/%E5%AE%89%E5%85%A8%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E5%9F%9F/",
      "content_html": "<h4 id=\"枚举根节点\"> 枚举根节点：</h4>\n<p>​\t\t当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的。</p>\n<h4 id=\"安全点\"> 安全点：</h4>\n<p>​\t\t在OopMap 的协助下，HotSpot 可以快速且准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本就将会变得更高。</p>\n<p>​\t\t实际上，HotSpot 并没有为每条指令都生成 OopMap，而只是在“特定位置”记录了这些信息，这些位置称为 安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始 GC，只有在达到安全点时才能暂停。</p>\n<p>Safepoint 的选定既不能太少以至于让 GC 等待时间太长，也不能过于频繁以至于过分增大运行时的负载。所以，安全点的选定基本上是以  “是否具有让程序长时间执行的特征”  为标准进行选定的--因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 SafePoint。</p>\n<p>对于 SafePoint 。另一个需要考虑的问题是如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都 “跑”到最近的安全点上在停顿下来： 抢占式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</p>\n<p><img src=\"./images/{5C5B166E-3CCD-655A-3B33-F812B9A3BA91}.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<h4 id=\"安全区域\"> 安全区域：</h4>\n<p><img src=\"./images/{2BB80CC4-7CFB-F7C5-179A-592D2DD71395}.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<p><img src=\"./images/{955F23F4-7EF6-1560-1919-D02BDAD7F737}.jpg\" alt=\"img\" loading=\"lazy\"></p>\n",
      "date_modified": "2022-04-29T06:23:43.167Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "创建对象的过程",
      "url": "https://fmiles.cn/java/jvm/memory/%E5%86%85%E5%AD%98%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/",
      "id": "https://fmiles.cn/java/jvm/memory/%E5%86%85%E5%AD%98%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/",
      "content_html": "<h2 id=\"创建对象的过程\"> 创建对象的过程</h2>\n<p>关于Java对象创建的过程：</p>\n<p>![Java创建对象的过程](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\memory\\Java创建对象的过程.png?lastModify=1648978507)</p>\n<h4 id=\"step1-类加载检查\"> Step1:类加载检查</h4>\n<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>\n<h4 id=\"step2-分配内存\"> Step2:分配内存</h4>\n<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>\n<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>\n<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的</p>\n<p>![内存分配的两种方式](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\memory\\内存分配的两种方式.png?lastModify=1648978697)</p>\n<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>\n<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>\n<ul>\n<li>\n<p><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></p>\n</li>\n<li>\n<p><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</p>\n</li>\n</ul>\n<h4 id=\"step3-初始化零值\"> Step3:初始化零值</h4>\n<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>\n<h4 id=\"step4-设置对象头\"> Step4:设置对象头</h4>\n<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>\n<h4 id=\"step5-执行-init-方法\"> Step5:执行 init 方法</h4>\n<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>\n<h3 id=\"tlab\"> TLAB</h3>\n<p>虽然堆内存是线程共享的，但是TLAB区是线程私有的。</p>\n<p>​\t\tJVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。\n​\t\t也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。</p>\n<p>![img](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\typora-user-images\\1137223-20180724163533976-1404788272-1583145637758.png?lastModify=1648978887)</p>\n",
      "image": "file://C:\\Users\\18496\\Desktop\\linux\\blogs\\java博客\\JVM\\memory\\Java创建对象的过程.png?lastModify=1648978507",
      "date_modified": "2022-04-29T06:23:43.170Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "运行时数据区域",
      "url": "https://fmiles.cn/java/jvm/memory/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/",
      "id": "https://fmiles.cn/java/jvm/memory/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/",
      "content_html": "<h2 id=\"运行时数据区域\"> 运行时数据区域</h2>\n<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p>\n<p><strong>JDK 1.8 之前</strong> ：</p>\n<p><img src=\"./images/JVM运行时数据区域.5f095134.png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>JDK 1.8</strong> ：</p>\n<p><img src=\"./images/Java运行时数据区域JDK1.8.5a3971fc.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>方法区是 Java 虚拟机规范中的一个逻辑概念，常量池是方法区的一部分，而永久代和元空间则是方法区的具体实现。1.8 的元空间是方法区代替永久代的一种实现，与永久代不同是元空间并不在虚拟机中，而是使用本地内存</p>\n<p><strong>线程私有的：</strong></p>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n</ul>\n<p><strong>线程共享的：</strong></p>\n<ul>\n<li>堆</li>\n<li>方法区</li>\n<li>直接内存 (非运行时数据区的一部分)</li>\n</ul>\n<h4 id=\"_1、虚拟机栈\"> 1、虚拟机栈：</h4>\n<p>​\t主要数据是栈帧（Stack Frame）。线程私有的内存空间，当线程创建的时候，与之相关的虚拟机栈就诞生了，当线程消亡了，与之对应的虚拟机栈也就消失。</p>\n<p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p>\n<p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p>\n<img src=\"images/stack.b24530b8.png\" alt=\"栈\" style=\"zoom: 80%;\" />\n<p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n<p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p>\n<p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在Class 文件的常量池里。*当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。*动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p>\n<p><img src=\"./images/jvmimage-20220331175738692.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p>\n<h4 id=\"_2、程序计数器-program-counter\"> 2、程序计数器（Program Counter）：</h4>\n<ul>\n<li>主要标识当前线程执行代码的行号，存放下一条执行代码的位置，比如第三行执行完后执行到哪行，可能执行到第四行，也可能执行到第八行。</li>\n<li>多个线程同时执行的时候，按照时间片的方式，多个线程轮执行，比如在第一个线程执行到一半的时候执行其他线程，这时候程序计数器就得记住线程挂起的位置。其他的线程是不能获取这个线程的代码执行的位置，即程序计数器线程私有的。</li>\n</ul>\n<h4 id=\"_3、本地方法栈\"> 3、本地方法栈：</h4>\n<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>\n<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误</p>\n<h4 id=\"_4、堆\"> 4、堆</h4>\n<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>\n<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<h5 id=\"_4-1-字符串常量池\"> 4.1 字符串常量池：</h5>\n<p>字符串常量池和静态变量在堆上。</p>\n<h5 id=\"字符串常量池作用\"> 字符串常量池作用？</h5>\n<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<div><pre><code><span>String</span> aa <span>=</span> <span>\"ab\"</span><span>;</span> <span>// 放在常量池中</span>\n<span>String</span> bb <span>=</span> <span>\"ab\"</span><span>;</span> <span>// 从常量池中查找</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa<span>==</span>bb<span>)</span><span>;</span><span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p>\n<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>\n<h4 id=\"_5、方法区\"> 5、方法区</h4>\n<p>方法区是 Java 虚拟机规范中的一个逻辑概念，常量池是方法区的一部分，而永久代和元空间则是方法区的具体实现。1.8 的元空间是方法区代替永久代的一种实现，与永久代不同是元空间并不在虚拟机中，而是使用本地内存。</p>\n<p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量即时编译器编译后的代码缓存等数据</strong>。</p>\n<h5 id=\"_5-1-运行时常量池\"> 5.1 运行时常量池：</h5>\n<p>在编译期间就能确定好的。是方法区一部分内容，就是字节码中的常量池，再加载完以后就会进入运行时常量池。</p>\n<blockquote>\n<ol>\n<li>JDK1.7 之前，运行时常量池包含的字符串常量池和静态变量存放在方法区, 此时 HotSpot 虚拟机对方法区的实现为永久代。</li>\n<li>JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 HotSpot 中的永久代 。</li>\n<li>JDK1.8 HotSpot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池和静态变量还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</li>\n</ol>\n</blockquote>\n<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p>\n<p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>\n<p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>\n<h4 id=\"_6、直接内存\"> 6、直接内存</h4>\n<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p>\n<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</p>\n<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>\n",
      "date_modified": "2022-04-29T06:23:43.170Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "栈帧（stack frame）：",
      "url": "https://fmiles.cn/java/jvm/memory/%E6%A0%88%E5%B8%A7%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/",
      "id": "https://fmiles.cn/java/jvm/memory/%E6%A0%88%E5%B8%A7%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/",
      "content_html": "<h4 id=\"栈帧-stack-frame\"> 栈帧（stack frame）：</h4>\n<p>​\t\t栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构。栈帧本身是一种数据结构，封装了方法的局部变量表、动态链接信息、方法的返回地址以及操作数栈等信息。</p>\n<p>动态链接：符号引用，直接引用。</p>\n<p>符号引用：是指在A类里面调用B类的时候，会在A的常量池维护一个指向B的唯一限定名称，如果引用B的属性或者调用B的方法等，就会将符号引用转换为直接引用。</p>\n<p>直接引用：可以直接在内存中寻找到被调用的方法的地址。</p>\n<h5 id=\"符号引用转换为直接引用\"> 符号引用转换为直接引用：</h5>\n<p>​\t\t有些符号引用是在类加载阶段或时第一次使用时就会转换为直接引用，这种转换叫做静态解析；另外一些符号引用则是在每次运行转换为直接引用（即使是同一个符号引用在运行期后都可能被解析成不同的直接引用，详解下面的方法重写），这种转换叫做动态链接，（动态连接是一个将符号引用解析为直接引用的过程）。这体现为 Java 的多态。</p>\n<h5 id=\"静态解析的4-中情形\"> 静态解析的4 中情形：</h5>\n<p>1、父类的方法</p>\n<p>2、静态方法</p>\n<p>3、构造方法</p>\n<p>4、私有方法（private），原因是私有方法是不能被重写的的，故而可以在加载的时候就可以唯一确定。</p>\n<p>以上四种方法称为非虚方法，他们是在类加载阶段就可以将符号引用转换为直接引用。</p>\n<h4 id=\"slot\"> slot：</h4>\n<p>存储局部变量的最小单位。</p>\n<p>​         虚拟机没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这两个类型占2个Slot，其它基本类型固定占用1个Slot。读取的时候也会连续的读取两个 slot，表明这是 long 或者double类型。</p>\n<p>一般来说，有几个局部变量，就会有几个 slot存储，但是不绝对。因为slot是可以复用的，因为在方法体中会存在更小的作用域。</p>\n<h5 id=\"复用情况的分析\"> 复用情况的分析：</h5>\n<p>如下，在方法体中的都是方法的局部变量，在局部变量角度，它表并不区分这些局部变量有什么作用域之分。但是实际运行的时候这些变量其实会有作用域之分，比如 b，c值只存在于 if之中。在运行的时候，在if执行完后，bc占据的slot位置就有可能被de占据，只是有可能，具体和虚拟机的实现有关。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest4</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>int</span> a <span>=</span> <span>3</span><span>;</span>\n        <span>if</span> <span>(</span>a<span>&lt;</span><span>4</span><span>)</span><span>{</span>\n            <span>int</span> b <span>=</span> <span>4</span><span>;</span>\n            <span>int</span> c <span>=</span> <span>5</span><span>;</span>\n        <span>}</span>\n        \n        <span>int</span> d <span>=</span> <span>7</span><span>;</span>\n        <span>int</span> e <span>=</span> <span>8</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><hr>\n<blockquote>\n<p>1、invokeinterface：调用接口的默认实现方法，实际上是在运行期决定的，决定到底调用实现该接 口的哪个对象方法。</p>\n<p>2、invokestatic：调用静态方法。</p>\n<p>3、invokespecial：调用自己的私有方法，构造方法（<init>）以及父类的方法。</p>\n<p>4、invokevirtual：调用虚方法，运行期动态查找的过程。</p>\n<p>5、invokedynamic：动态调用方法。（自己的理解是普通的方法的调用）</p>\n</blockquote>\n<p>2、3 可以调用的方法是在解析阶段就可以确定的方法，符合这个类型的方法主要有四类：父类的方法，静态方法，构造方法，私有方法（private）。即他们在加载的时候就会直接把类的符号引用转化为直接引用。</p>\n<h5 id=\"_1、调用静态方法分析-invokestatic\"> 1、调用静态方法分析 （invokestatic）</h5>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest5</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"test invoked\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>test</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>通过字节码可以发现，这里main方法通过 invokestatic 调用了静态方法test。</p>\n<p><img src=\"./images/1582026546582.png\" alt=\"1582026546582\" loading=\"lazy\"></p>\n<h5 id=\"_2、重载的分析-invokespecial\"> 2、重载的分析（invokespecial）：</h5>\n<div><pre><code><span>/*\n*   方法的静态分配：\n*   Grandpa p1 = new Father();\n*   以上代码，p1 的静态类型是Grandpa，而p1的实际类型（真正指向的类型）是 Father。静态类型本身是不会改变的。\n*   实际类型是在运行期间才可确定。\n* */</span>\n<span>public</span> <span>class</span> <span>MyTest6</span> <span>{</span>\n\n    <span>// 方法的重载，是一种静态行为，编译期就可以完全确定。jvm是根据方法参数的本身类型去决定调用的方法。</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>Grandpa</span> grandpa<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"gradpa\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>Father</span> father<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"father\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>Son</span> son<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"son\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Grandpa</span> p1 <span>=</span> <span>new</span> <span>Father</span><span>(</span><span>)</span><span>;</span>\n        <span>Grandpa</span> p2 <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>)</span><span>;</span>\n\n        <span>MyTest6</span> myTest6 <span>=</span> <span>new</span> <span>MyTest6</span><span>(</span><span>)</span><span>;</span>\n\n        myTest6<span>.</span><span>test</span><span>(</span>p1<span>)</span><span>;</span>\n        myTest6<span>.</span><span>test</span><span>(</span>p2<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Grandpa</span><span>{</span>\n\n<span>}</span>\n\n<span>class</span> <span>Father</span> <span>extends</span> <span>Grandpa</span><span>{</span>\n\n<span>}</span>\n\n<span>class</span> <span>Son</span> <span>extends</span> <span>Father</span><span>{</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><div><pre><code> <span>0</span> <span>new</span> #<span>7</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Father</span><span>></span>\n <span>3</span> dup\n <span>4</span> invokespecial #<span>8</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Father</span><span>.</span><span><span>&lt;</span>init<span>></span></span><span>></span> <span>// 静态分派，构造方法属于静态分派</span>\n <span>7</span> astore_1\n <span>8</span> <span>new</span> #<span>9</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Son</span><span>></span>\n<span>11</span> dup\n<span>12</span> invokespecial #<span>10</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Son</span><span>.</span><span><span>&lt;</span>init<span>></span></span><span>></span>\n<span>15</span> astore_2\n<span>16</span> <span>new</span> #<span>11</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest6</span><span>></span>\n<span>19</span> dup\n<span>20</span> invokespecial #<span>12</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest6</span><span>.</span><span><span>&lt;</span>init<span>></span></span><span>></span>\n<span>23</span> astore_3\n<span>24</span> aload_3\n<span>25</span> aload_1\n<span>26</span> invokevirtual #<span>13</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest6</span><span>.</span>test<span>></span>\n<span>29</span> aload_3\n<span>30</span> aload_2\n<span>31</span> invokevirtual #<span>13</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>MyTest6</span><span>.</span>test<span>></span>\n<span>34</span> <span>return</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>invokespecial 只会调用自己的私有方法，构造方法（<init>）以及父类的方法，而类的其他方法则是会通过 invokevirtual 去调用，动态分配。</p>\n<h5 id=\"_3、重写的分析-invokevirtual\"> 3、重写的分析（invokevirtual）：</h5>\n<p>源码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest7</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Fruit</span> apple <span>=</span> <span>new</span> <span>Apple</span><span>(</span><span>)</span><span>;</span>\n        <span>Fruit</span> orange  <span>=</span> <span>new</span> <span>Orange</span><span>(</span><span>)</span><span>;</span>\n\n        apple<span>.</span><span>test</span><span>(</span><span>)</span><span>;</span>\n        orange<span>.</span><span>test</span><span>(</span><span>)</span><span>;</span>\n\n        apple <span>=</span> <span>new</span> <span>Orange</span><span>(</span><span>)</span><span>;</span>\n        apple<span>.</span><span>test</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Fruit</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Fruit\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Apple</span> <span>extends</span> <span>Fruit</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Apple\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Orange</span> <span>extends</span> <span>Fruit</span><span>{</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Orange\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>字节码分析：</p>\n<div><pre><code> <span>0</span> <span>new</span> #<span>2</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Apple</span><span>></span> <span>// new 代表在堆空间开辟内存空间，存放新的实例对象</span>\n <span>3</span> dup   <span>// 复制操作数栈上的顶部值，并将复制后的值压入操作数栈。</span>\n <span>4</span> invokespecial #<span>3</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Apple</span><span>.</span><span><span>&lt;</span>init<span>></span></span><span>></span> <span>// 调用构造方法</span>\n <span>7</span> astore_1 <span>// 将对象在堆上的实例对象的地赋值给变量。即将实例对象地址赋值给局部变量表的第一项。</span>\n <span>8</span> <span>new</span> #<span>4</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Orange</span><span>></span> <span>// 同上</span>\n<span>11</span> dup\n<span>12</span> invokespecial #<span>5</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Orange</span><span>.</span><span><span>&lt;</span>init<span>></span></span><span>></span>\n<span>15</span> astore_2\n<span>16</span> aload_1  <span>// 从局部变量表加载索引为1的引用，即 apple。</span>\n<span>17</span> invokevirtual #<span>6</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Fruit</span><span>.</span>test<span>></span> <span>//这里和实际调用的方法是不一样，原因在下面。</span>\n<span>20</span> aload_2\n<span>21</span> invokevirtual #<span>6</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Fruit</span><span>.</span>test<span>></span>\n<span>24</span> <span>new</span> #<span>4</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Orange</span><span>></span>\n<span>27</span> dup\n<span>28</span> invokespecial #<span>5</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Orange</span><span>.</span><span><span>&lt;</span>init<span>></span></span><span>></span>\n<span>31</span> astore_1\n<span>32</span> aload_1\n<span>33</span> invokevirtual #<span>6</span> <span>&lt;</span>com<span>/</span>jvm<span>/</span>bytecode<span>/</span><span>Fruit</span><span>.</span>test<span>></span>\n<span>36</span> <span>return</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>方法的动态分派：方法的动态分派设计到一个重要概念:方法接收者。</p>\n<h5 id=\"invokevirtual字节码指令的多态查找过程\"> invokevirtual字节码指令的多态查找过程：</h5>\n<blockquote>\n<p>1、找到操作数栈的栈顶元素所指向的对象的实际类型。</p>\n<p>2、如果在实际类型当中，它寻找到了与常量池中名称和描述符相同的方法，并且具有相应的访问权限，就直接返回这个方法的直接引用。如果找不到，依次从子类到父类重复查找的流程。直到真正找到特定的对象的方法。</p>\n</blockquote>\n<p>比较方法重载和方法重写：方法重载是静态分派的，是编译器行为；方法重写是动态分派的，是运行期行为。多态与方法重写有紧密联系。动态分配是由方法调用决定的。</p>\n<p>上面的例子，在invokevirtual执行的时候，会查找栈顶元素，这时候是Apple类，即会查找Apple类常量池中是否有相同名称和描述符的方法，这里有test方法，并且权限等于父类test方法的权限，故而调用这个方法。因此，即便是完全相同的两个符号引用，这里是 Fruit，在运行期也会被解析为两个不同的直接引用。</p>\n<h5 id=\"虚方法表\"> 虚方法表：</h5>\n<p>​\t\t   针对于方法调用的动态分配的过程，虚拟机会在类的方法区建立一个虚方法表的数据结构（virtual method table，vtable）针对于 invokeinterface 指令来说，虚拟机会建立一个叫做接口方法表的数据结构（interface method table，itable）</p>\n<p>​       虚方法表中存放的是每一个方法实际真正调用入口的地址，如果子类没有重写父类的方法，则子类的虚方法表中指向的是父类的虚方法表中方法的地址，如果子类重写了父类方法，则子类的虚方法表中就会标识这个方法，指向本类的此方法地址。</p>\n<p><img src=\"./images/1582034527039.png\" alt=\"1582034527039\" loading=\"lazy\"></p>\n<p>动态分配，静态分配。</p>\n<p>符号引用，直接引用。</p>\n",
      "date_modified": "2022-04-29T06:23:43.171Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "逃逸分析",
      "url": "https://fmiles.cn/java/jvm/memory/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/",
      "id": "https://fmiles.cn/java/jvm/memory/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/",
      "content_html": "<h2 id=\"逃逸分析\"> 逃逸分析</h2>\n<h3 id=\"_1-何为-逃逸-escape\"> 1.何为&quot;逃逸&quot;(Escape)?</h3>\n<p>当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。</p>\n<p>例子 :</p>\n<div><pre><code><span>public</span> <span>StringBuilder</span> <span>escapeDemo1</span><span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>{</span>\n\t<span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n      stringBuilder<span>.</span><span>append</span><span>(</span>a<span>)</span><span>;</span>\n      stringBuilder<span>.</span><span>append</span><span>(</span>b<span>)</span><span>;</span>\n      <span>return</span> stringBuilder<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上述代码则会发生逃逸</p>\n<p>如果改成 ：</p>\n<div><pre><code><span>public</span> <span>String</span> <span>escapeDemo2</span><span>(</span><span>String</span> a<span>,</span> <span>String</span> b<span>)</span> <span>{</span>\n     <span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n     stringBuilder<span>.</span><span>append</span><span>(</span>a<span>)</span><span>;</span>\n     stringBuilder<span>.</span><span>append</span><span>(</span>b<span>)</span><span>;</span>\n     <span>return</span> stringBuilder<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>就不会发生逃逸</p>\n<h3 id=\"_2-什么是逃逸分析\"> 2.什么是逃逸分析</h3>\n<p>逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。\n逃逸分析（Escape Analysis）算是目前Java虚拟机中比较前沿的优化技术了。</p>\n<h3 id=\"_3-逃逸分析的原理\"> 3.逃逸分析的原理</h3>\n<p>Java本身的限制（对象只能分配到堆中），为了减少临时对象在堆内分配的数量，会在一个方法体内定义一个局部变量，并且该变量在方法执行过程中未发生逃逸，按照JVM调优机制，</p>\n<p>优化前 : 首先会在堆内存创建类的实例，然后将此对象的引用压入调用栈，继续执行\n优化后 : 针对栈的重新分配方式，首先找出未逃逸的变量，将该变量直接存到栈里，无需进入堆，分配完成后，继续调用栈内执行，最后线程执行结束，栈空间被回收，局部变量也被回收了。如此操作，是优化前在堆中，优化后在栈中，从而减少了堆中对象的分配和销毁，从而优化性能。</p>\n<blockquote>\n<p>总结: 不逃逸的对象, 只存在栈中, 减少了堆压力, 从而得到优化效果;</p>\n</blockquote>\n<h3 id=\"_4-逃逸的方式\"> 4.逃逸的方式</h3>\n<p>方法逃逸： 在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。\n线程逃逸： 这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。</p>\n<h3 id=\"_5-逃逸分析的好处\"> 5.逃逸分析的好处</h3>\n<p>如果一个对象不会在方法体内，或线程内发生逃逸（或者说是通过逃逸分析后，使其未能发生逃逸）</p>\n<p>逃逸分析后的三大优点 :</p>\n<p>栈上分配 : 一般情况下，不会逃逸的对象所占空间比较大，如果能使用栈上的空间，那么大量的对象将随方法的结束而销毁，减轻了GC压力</p>\n<p>同步消除 : 如果你定义的类的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>\n<p>标量替换 :</p>\n<p>Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。</p>\n<p>如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。</p>\n<h3 id=\"_6-相关jvm参数\"> 6.相关JVM参数</h3>\n<p>参数开启 :</p>\n<p>在JDK 6u23以上是默认开启，这里将设置重新明确一下：</p>\n<p>强制开启：-server -XX:+DoEscapeAnalysis -XX:+PrintGCDetail -Xmx10m -Xms10m</p>\n<p>关闭逃逸分析：　 -server -XX:-DoEscapeAnalysis -XX:+PrintGCDetail -Xmx10m -Xms10m</p>\n",
      "date_modified": "2022-04-29T06:23:43.172Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "命令工具",
      "url": "https://fmiles.cn/java/jvm/tools/%E5%B7%A5%E5%85%B7/",
      "id": "https://fmiles.cn/java/jvm/tools/%E5%B7%A5%E5%85%B7/",
      "content_html": "<h2 id=\"命令工具\"> 命令工具</h2>\n<p>jvisualvm其实就是这些命令的集合，显示为图形化</p>\n<h3 id=\"jmap\"> jmap</h3>\n<p>(Memory Map for Java) : 生成堆转储快照;</p>\n<div><pre><code>jmap [option] &lt;pid&gt;   // 参数 ， 进程 id\n</code></pre>\n<div><span>1</span><br></div></div><p>获取 jvm 进程 id。其实就是 java.exe 的进程id。在win上cmd命令 tasklist，快捷方式就是 jps。</p>\n<h5 id=\"_1、jmap-clstats-pid-打印类加载器数据。\"> 1、jmap -clstats PID  打印类加载器数据。</h5>\n<p>类加载器，类，字节，父类加载器，是否存活，类型</p>\n<p>![1582458692126](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\jvm\\tools\\images\\1582458692126.png?lastModify=1651212530)</p>\n<p>注：internal 是因为启动类加载器地层是 c++ 编写的。</p>\n<h5 id=\"_2、jmap-heap-pid-打印堆的信息\"> 2、jmap -heap PID  打印堆的信息</h5>\n<hr>\n<h3 id=\"jstat\"> <strong>jstat</strong></h3>\n<p>（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</p>\n<p>jstat -gc LVMID 用来打印元空间的信息。（LVMID 这里就是 java.exe 的进程号）</p>\n<p>![img](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\jvm\\tools\\images\\640-1582459278070.webp?lastModify=1651212530)</p>\n<p>MC：当前元空间容量。 MU：已经被使用的元空间的大小</p>\n<p>以下这段代码并不会增大元空间内存，因为元数据并没有增加。除非是动态代理这样不断的生成元数据。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyTest5</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>for</span><span>(</span><span>;</span><span>;</span><span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"hello world\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><hr>\n<h3 id=\"jcmd\"> <strong>jcmd</strong></h3>\n<p>jcmd 是从jdk1.7 开始增加的命令。</p>\n<h5 id=\"_1、jcmd-pid-vm-flags-打印进程的所有的-vm-参数\"> 1、jcmd pid VM.flags   打印进程的所有的 vm 参数</h5>\n<p><img src=\"./images/1582460123799.png\" alt=\"1582460123799\" loading=\"lazy\"></p>\n<h5 id=\"_2、jcmd-pid-help-列出当前运行的java进程可以执行的操作\"> 2、jcmd pid help    列出当前运行的java进程可以执行的操作</h5>\n<p><img src=\"./images/1582460415638.png\" alt=\"1582460415638\" loading=\"lazy\"></p>\n<h5 id=\"_3、jcmd-pid-help-command-查看具体命令的选项有哪些\"> 3、jcmd pid help command    查看具体命令的选项有哪些</h5>\n<p><img src=\"./images/1582460576174.png\" alt=\"1582460576174\" loading=\"lazy\"></p>\n<h5 id=\"_4、jcmd-pid-perfcounter-print-查看jvm性能相关的参数\"> 4、jcmd pid PerfCounter.print      查看JVM性能相关的参数</h5>\n<p><img src=\"./images/1582460762884.png\" alt=\"1582460762884\" loading=\"lazy\"></p>\n<h5 id=\"_5、jcmd-pid-vm-uptime-查看-jvm-的启动时长\"> 5、jcmd pid VM.uptime     查看 JVM 的启动时长</h5>\n<p><img src=\"./images/1582460826522.png\" alt=\"1582460826522\" loading=\"lazy\"></p>\n<h5 id=\"_6、jcmd-pid-gc-class-histogram-查看当前系统中类的统计信息\"> 6、jcmd pid GC.class_histogram     查看当前系统中类的统计信息</h5>\n<p><img src=\"./images/1582460969426.png\" alt=\"1582460969426\" loading=\"lazy\"></p>\n<h5 id=\"_7、jcmd-pid-thread-print-查看线程的堆栈信息\"> 7、jcmd pid Thread.print      查看线程的堆栈信息</h5>\n<p><img src=\"./images/1582461134210.png\" alt=\"1582461134210\" loading=\"lazy\"></p>\n<h5 id=\"_8、jcmd-pid-gc-heap-dump-文件路径-导出heap-dump-文件。\"> 8、jcmd pid GC.heap_dump 文件路径           导出Heap dump 文件。</h5>\n<p>和之前的 jvisualvm 一样，可以打开这个文件。</p>\n<h5 id=\"_9、-jcmd-pid-vm-system-properties-查看jvm-的属性信息\"> 9、 jcmd pid VM.system_properties      查看JVM 的属性信息</h5>\n<p><img src=\"./images/1582461588470.png\" alt=\"1582461588470\" loading=\"lazy\"></p>\n<h5 id=\"_9、jcmd-pid-vm-version-查看目标-jvm-进程的版本信息。-和jdk版本不是一个东西\"> 9、jcmd pid VM.version  \t 查看目标 JVM 进程的版本信息。（和jdk版本不是一个东西）</h5>\n<h5 id=\"_10、jcmd-pid-vm-command-line-查看jvm启动的命令行参数信息\"> 10、jcmd pid VM.command_line  查看JVM启动的命令行参数信息</h5>\n<p><img src=\"./images/1582462567387.png\" alt=\"1582462567387\" loading=\"lazy\"></p>\n<hr>\n<h3 id=\"jstack\"> jstack</h3>\n<p>(Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p>\n<h5 id=\"jstack-pid-可以查看或者是导出java应用程序中线程的堆栈信息\"> jstack pid  可以查看或者是导出Java应用程序中线程的堆栈信息</h5>\n<p>和 jcmd pid Thread.print 命令效果一样。</p>\n<p><img src=\"./images/1582462824212.png\" alt=\"1582462824212\" loading=\"lazy\"></p>\n<hr>\n<h3 id=\"jhat\"> jhat</h3>\n<p>(JVM Heap Dump Browser) :: 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</p>\n<h5 id=\"jhat-文件路径-对堆转储文件进行分析。\"> jhat 文件路径        对堆转储文件进行分析。</h5>\n<p>和 jvisualvm 分析转储文件的作用是一样的。差不多也是被 jvisualvm 集成的命令工具。</p>\n<hr>\n<h3 id=\"jps\"> jps</h3>\n<p>(JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</p>\n<p><img src=\"./images/1582459779830.png\" alt=\"1582459779830\" loading=\"lazy\"></p>\n<p>jps -l  显示进程所在的包名。（最常用的也是这个参数）</p>\n<p><img src=\"./images/1582459888926.png\" alt=\"1582459888926\" loading=\"lazy\"></p>\n<hr>\n<h3 id=\"jinfo\"> jinfo</h3>\n<p>(Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</p>\n<h2 id=\"可视化工具\"> 可视化工具</h2>\n<h3 id=\"jmc\"> JMC</h3>\n<p>Oracle Java Mission Control 是一个用于对 Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。首次安装时，Java Mission Control 包括 JMX 控制台和 Java 飞行记录器。从 Mission Control 中可以轻松安装更多插件。</p>\n<p>java 飞行记录器 （jfr : Java Flight Recorder）。</p>\n<h4 id=\"jmc-2\"> jmc：</h4>\n<p>这里是集成了命令行工具，尤其是诊断命令，就是 jcmd 的图形化界面。</p>\n<p>![1582463378599](file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\jvm\\tools\\images\\1582463378599.png?lastModify=1651212530)</p>\n<h4 id=\"jfr\"> jfr：</h4>\n<p>![1582463662553](file://C:\\Users\\18496\\Desktop\\linux\\blogs\\typora-user-images\\1582463662553.png?lastModify=1649055726)</p>\n",
      "image": "file://C:\\Users\\18496\\Desktop\\docs\\fmiles\\docs\\java\\jvm\\tools\\images\\1582458692126.png?lastModify=1651212530",
      "date_modified": "2022-04-29T06:23:43.173Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    },
    {
      "title": "CPU Cache 的数据写入",
      "url": "https://fmiles.cn/operating-system/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/",
      "id": "https://fmiles.cn/operating-system/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/",
      "content_html": "<h2 id=\"cpu-cache-的数据写入\"> CPU Cache 的数据写入</h2>\n<p>随着时间的推移，CPU 和内存的访问性能相差越来越大，于是就在 CPU 内部嵌入了 CPU Cache（高速缓存），CPU Cache 离 CPU 核心相当近，因此它的访问速度是很快的，于是它充当了 CPU 与内存之间的缓存角色。</p>\n<p>CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度也快，但是存储容量相对就会越小。其中，在多核心的 CPU 里，每个核心都有各自的 L1/L2 Cache，而 L3 Cache 是所有核心共享使用的。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPPKJan1icpeMMyiawV2UvVwcCayaDLWJ00D3rh78LYZqBwOv9tSTYCvRog/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom: 67%;\" />\n<p>​\t我们先简单了解下 CPU Cache 的结构，CPU Cache 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成，你可以在下图清晰的看到：</p>\n<img src=\"images/640\" alt=\"图片\" style=\"zoom: 80%;\" />\n<p>我们当然期望 CPU 读取数据的时候，都是尽可能地从 CPU Cache 中读取，而不是每一次都要从内存中获取数据。所以，身为程序员，我们要尽可能写出缓存命中率高的代码，这样就有效提高程序的性能，具体的做法，你可以参考我上一篇文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247486022&amp;idx=1&amp;sn=8bb5a066d81f77523a06cd09251055da&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">「如何写出让 CPU 跑得更快的代码？」</a></p>\n<p>事实上，数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。</p>\n<p>问题来了，那在什么时机才把 Cache 中的数据写回到内存呢？为了应对这个问题，下面介绍两种针对写入数据的方法：</p>\n<ul>\n<li>写直达（<em>Write Through</em>）</li>\n<li>写回（<em>Write Back</em>）</li>\n</ul>\n<h4 id=\"写直达\"> 写直达</h4>\n<p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达（*Write Through*）</strong>。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPPxAqS638ehVB4PrVWegKibqcweFjcM7QboHV7ialgHJzjfv4NyP6ELStg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>在这个方法里，写入前会先判断数据是否已经在 CPU Cache 里面了：</p>\n<ul>\n<li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li>\n<li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li>\n</ul>\n<p>写直达法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</p>\n<h4 id=\"写回\"> 写回</h4>\n<p>既然写直达由于每次写操作都会把数据写回到内存，而导致影响性能，于是为了要减少数据写回内存的频率，就出现了<strong>写回（*Write Back*）的方法</strong>。</p>\n<p>在写回机制中，<strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率，这样便可以提高系统的性能。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPP4mia18R69AbGx4dxQfekrlm0GIpBf4TZeGlFl5uzoEvmCwo3ibfr26mA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>那具体如何做到的呢？下面来详细说一下：</p>\n<ul>\n<li>如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，我们 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；</li>\n<li>如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的，如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Block 里，同时也把它标记为脏的；如果 Cache Block 里面的数据没有被标记为脏，则就直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了。</li>\n</ul>\n<p>可以发现写回这个方法，在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。</p>\n<p>这样的好处是，如果我们大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。</p>\n<h2 id=\"缓存一致性问题\"> 缓存一致性问题</h2>\n<p>现在 CPU 都是多核的，由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的<strong>缓存一致性（*Cache Coherence*）</strong> 的问题，如果不能保证缓存一致性的问题，就可能造成结果错误。</p>\n<p>那缓存一致性的问题具体是怎么发生的呢？我们以一个含有两个核心的 CPU  作为例子看一看。</p>\n<p>假设 A 号核心和 B 号核心同时运行两个线程，都操作共同的变量 i（初始值为 0 ）。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPPYibKuToa682yhIE7RiaUq0KLxRNtib9EBGUe1L8ZNCBMYtVxL5EgHIfMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>这时如果 A 号核心执行了 <code>i++</code> 语句的时候，为了考虑性能，使用了我们前面所说的写回策略，先把值为 <code>1</code> 的执行结果写入到 L1/L2 Cache 中，然后把 L1/L2 Cache 中对应的 Block 标记为脏的，这个时候数据其实没有被同步到内存中的，因为写回策略，只有在 A 号核心中的这个 Cache Block 要被替换的时候，数据才会写入到内存里。</p>\n<p>如果这时旁边的 B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0。<strong>这个就是所谓的缓存一致性问题，A 号核心和 B 号核心的缓存，在这个时候是不一致，从而会导致执行结果的错误。</strong></p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPP0X3HRe9Z0A85WXDVBR41or8nlKew9QwCh73eh3YBIibDwCGicQ0E3M9A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\" />\n<p>那么，要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：</p>\n<ul>\n<li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（*Wreite Propagation*）</strong>；</li>\n<li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化（*Transaction Serialization*）</strong>。</li>\n</ul>\n<p>第一点写传播很容易就理解，当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里。</p>\n<p>而对于第二点事务的串形化，我们举个例子来理解它。</p>\n<p>假设我们有一个含有 4 个核心的 CPU，这 4 个核心都操作共同的变量 i（初始值为 0 ）。A 号核心先把 i 值变为 100，而此时同一时间，B 号核心先把 i 值变为 200，这里两个修改，都会「传播」到 C 和 D 号核心。</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPPAvJH3fcHDgr9GcU9icCCDM8mHKnQYyQ9p0JicUqEicjV4IMbfVhBETp8w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom: 80%;\" />\n<p>那么问题就来了，C 号核心先收到了 A 号核心更新数据的事件，再收到 B 号核心更新数据的事件，因此 C 号核心看到的变量 i 是先变成 100，后变成 200。</p>\n<p>而如果 D 号核心收到的事件是反过来的，则 D 号核心看到的是变量 i 先变成 200，再变成 100，虽然是做到了写传播，但是各个 Cache 里面的数据还是不一致的。</p>\n<p>所以，我们要保证 C 号核心和 D 号核心都能看到<strong>相同顺序的数据变化</strong>，比如变量 i 都是先变成 100，再变成 200，这样的过程就是事务的串形化。</p>\n<p>要实现事务串形化，要做到 2 点：</p>\n<ul>\n<li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；</li>\n<li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</li>\n</ul>\n<p>那接下来我们看看，写传播和事务串形化具体是用什么技术实现的。</p>\n<h2 id=\"总线嗅探\"> 总线嗅探</h2>\n<p>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是<strong>总线嗅探（*Bus Snooping*）</strong>。</p>\n<p>我还是以前面的 i 变量例子来说明总线嗅探的工作机制，当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的广播事件，并检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache。</p>\n<p>可以发现，总线嗅探方法很简单， CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。</p>\n<p>另外，总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串形化。</p>\n<p>于是，有一个协议基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。</p>\n<h2 id=\"mesi-协议\"> MESI 协议</h2>\n<p>MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：</p>\n<ul>\n<li><em>Modified</em>，已修改</li>\n<li><em>Exclusive</em>，独占</li>\n<li><em>Shared</em>，共享</li>\n<li><em>Invalidated</em>，已失效</li>\n</ul>\n<p>这四个状态来标记 Cache Line 四个不同的状态。</p>\n<p>「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。</p>\n<p>「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。</p>\n<p>「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。</p>\n<p>另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。</p>\n<p>那么，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</p>\n<p>我们举个具体的例子来看看这四个状态的转换：</p>\n<ol>\n<li>当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的；</li>\n<li>然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；</li>\n<li>当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。</li>\n<li>如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。</li>\n<li>如果 A 号 CPU 核心的 Cache 里的 i 变量对应的  Cache Line 要被「替换」，发现  Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。</li>\n</ol>\n<p>所以，可以发现当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力。</p>\n<p>事实上，整个 MESI 的状态可以用一个有限状态机来表示它的状态流转。还有一点，对于不同状态触发的事件操作，可能是来自本地 CPU 核心发出的广播事件，也可以是来自其他 CPU 核心通过总线发出的广播事件。下图即是 MESI 协议的状态图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPP3P2XZDHKy7EzWzfnOUugqByGVarxSnst6y78DkSmNHksLMlcd2Vlpg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\" loading=\"lazy\"></p>\n<p>MESI 协议的四种状态之间的流转过程，我汇总成了下面的表格，你可以更详细的看到每个状态转换的原因：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPPdCgFBj2uKBIfZGl2eYo2Wk0jPHSEN8ibcQo2icdUurOOs51IPKveiaTsA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\" loading=\"lazy\"></p>\n<h2 id=\"性能优化\"> 性能优化</h2>\n<p>当 cpu 需要的数据在其他 cpu 的 cache 内时，需要请求，并且等待响应，这显然是一个同步行为，优化的方案也很明显，采用异步。思路大概是在cpu 和 cache 之间加一个 store buffer，cpu 可以先将数据写到 store buffer，同时给其他cpu发送消息，然后继续做其它事情，等到收到其它 cpu发过来的响应消息，再将数据从 store buffer 移到 cache line。</p>\n<p><img src=\"https://pic4.zhimg.com/v2-33d2ebb3b786f50e0b6226c59c3d7c74_b.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<p>参数：</p>\n<p>https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247486479&amp;idx=1&amp;sn=433a551c37a445d068ffbf8ac85f0346&amp;chksm=f98e48a5cef9c1b3fadb691fee5ebe99eb29d83fd448595239ac8a2f755fa75cacaf8e4e8576&amp;scene=178&amp;cur_album_id=1408057986861416450&amp;rd2werd=1#wechat_redirect</p>\n<p>性能优化。</p>\n<p>https://blog.csdn.net/wll1228/article/details/107775976</p>\n",
      "image": "https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0RnQxwibdcyFOTw0NvInPP3P2XZDHKy7EzWzfnOUugqByGVarxSnst6y78DkSmNHksLMlcd2Vlpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1",
      "date_modified": "2022-04-29T06:23:43.175Z",
      "authors": [
        {
          "name": "siyue"
        }
      ],
      "tags": []
    }
  ]
}